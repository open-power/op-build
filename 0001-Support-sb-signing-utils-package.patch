From f6c6b3ffa443e6e5120193840253b3506a282dcd Mon Sep 17 00:00:00 2001
From: Nick Bofferding <bofferdn@us.ibm.com>
Date: Wed, 7 Sep 2016 11:34:53 -0500
Subject: [PATCH] Support sb-signing-utils package

- Added patch containing highly experimental signing utilities
- Added configuration file with option to configure package
- Added public HW + SW keys
- Added package makefile
- Registered package with buildroot
---
 openpower/package/Config.in                        |    1 +
 openpower/package/sb-signing-utils/Config.in       |    5 +
 .../package/sb-signing-utils/keys/hash_keys.bash   |   13 +
 .../package/sb-signing-utils/keys/hw_key_a.key     |   16 +
 .../package/sb-signing-utils/keys/hw_key_a.pem     |  Bin 0 -> 133 bytes
 .../package/sb-signing-utils/keys/hw_key_b.key     |   17 +
 .../package/sb-signing-utils/keys/hw_key_b.pem     |  Bin 0 -> 133 bytes
 .../package/sb-signing-utils/keys/hw_key_c.key     |   17 +
 .../package/sb-signing-utils/keys/hw_key_c.pem     |  Bin 0 -> 133 bytes
 .../package/sb-signing-utils/keys/sw_key_a.key     |    7 +
 .../package/sb-signing-utils/keys/sw_key_a.pem     |  Bin 0 -> 133 bytes
 ...001-Highly-experimental-signing-utilities.patch | 7574 ++++++++++++++++++++
 .../package/sb-signing-utils/sb-signing-utils.mk   |   28 +
 13 files changed, 7678 insertions(+)
 create mode 100644 openpower/package/sb-signing-utils/Config.in
 create mode 100755 openpower/package/sb-signing-utils/keys/hash_keys.bash
 create mode 100644 openpower/package/sb-signing-utils/keys/hw_key_a.key
 create mode 100644 openpower/package/sb-signing-utils/keys/hw_key_a.pem
 create mode 100644 openpower/package/sb-signing-utils/keys/hw_key_b.key
 create mode 100644 openpower/package/sb-signing-utils/keys/hw_key_b.pem
 create mode 100644 openpower/package/sb-signing-utils/keys/hw_key_c.key
 create mode 100644 openpower/package/sb-signing-utils/keys/hw_key_c.pem
 create mode 100644 openpower/package/sb-signing-utils/keys/sw_key_a.key
 create mode 100644 openpower/package/sb-signing-utils/keys/sw_key_a.pem
 create mode 100644 openpower/package/sb-signing-utils/sb-signing-utils-0001-Highly-experimental-signing-utilities.patch
 create mode 100644 openpower/package/sb-signing-utils/sb-signing-utils.mk

diff --git a/openpower/package/Config.in b/openpower/package/Config.in
index cbeae17..00f6231 100755
--- a/openpower/package/Config.in
+++ b/openpower/package/Config.in
@@ -19,3 +19,4 @@ source "$BR2_EXTERNAL/package/loadkeys/Config.in"
 source "$BR2_EXTERNAL/package/witherspoon-xml/Config.in"
 source "$BR2_EXTERNAL/package/ppe42-binutils/Config.in"
 source "$BR2_EXTERNAL/package/ppe42-gcc/Config.in"
+source "$BR2_EXTERNAL/package/sb-signing-utils/Config.in"
diff --git a/openpower/package/sb-signing-utils/Config.in b/openpower/package/sb-signing-utils/Config.in
new file mode 100644
index 0000000..4e8f7f5
--- /dev/null
+++ b/openpower/package/sb-signing-utils/Config.in
@@ -0,0 +1,5 @@
+config BR2_PACKAGE_HOST_SB_SIGNING_UTILS
+        bool "OpenPOWER secureboot signing utilities"
+        default y if (BR2_OPENPOWER_PLATFORM && BR2_powerpc_power8 && BR2_OPENPOWER_SECUREBOOT_ENABLED)
+        help
+            Secureboot utilities for signing OpenPOWER firmware images
diff --git a/openpower/package/sb-signing-utils/keys/hash_keys.bash b/openpower/package/sb-signing-utils/keys/hash_keys.bash
new file mode 100755
index 0000000..afafdcf
--- /dev/null
+++ b/openpower/package/sb-signing-utils/keys/hash_keys.bash
@@ -0,0 +1,13 @@
+#!/bin/bash
+
+dd if=hw_key_a.pem bs=1c skip=1 > a
+dd if=hw_key_b.pem bs=1c skip=1 > b
+dd if=hw_key_c.pem bs=1c skip=1 > c
+
+cat a b c > combined.keys
+
+echo
+echo "SHA512 combined key hash:"
+sha512sum combined.keys 
+
+rm a b c combined.keys
diff --git a/openpower/package/sb-signing-utils/keys/hw_key_a.key b/openpower/package/sb-signing-utils/keys/hw_key_a.key
new file mode 100644
index 0000000..9f0c480
--- /dev/null
+++ b/openpower/package/sb-signing-utils/keys/hw_key_a.key
@@ -0,0 +1,16 @@
+-----BEGIN EC PRIVATE KEY-----
+MIICnAIBAQRBVvu38Sbtau77TPvsvEmYHwAD8WY12vTjRE6SowkePCI0+3k5bawC
+J9rKnafuMLCxE2SzTh5JPonVKhBPZeUpaOugggHGMIIBwgIBATBNBgcqhkjOPQEB
+AkIB////////////////////////////////////////////////////////////
+//////////////////////////8wgZ4EQgH/////////////////////////////
+/////////////////////////////////////////////////////////ARBUZU+
+uWGOHJofkpohoLaFQO6i2nJbmbMV87i0iZGO8QnhVhk5Uex+k3sWUsC9O7G/BzVz
+34g9LDTx70Uf1GtQPwADFQDQnogAKRy4U5bMZxc5MoSqoNpkugSBhQQAxoWOBrcE
+BOnNnj7LZiOVtEKcZIE5BT+1Ifgor2BrTT26oUted+/nWSj+HcEnov+o3jNIs8GF
+akKb+X5+McLlvWYBGDkpaniaO8AEXIpftCx9G9mY9URJV5tEaBevvRcnPmYsl+5y
+mV70JkDFULkBP60HYTU8cIaicsJAiL6Udp/RZlACQgH/////////////////////
+//////////////////////pRhoeDvy+Wa3/MAUj3CaXQO7XJuImcR667b7cekThk
+CQIBAaGBiQOBhgAEALseCHiWoJ4wcnQGjefKigKgnFVDj1D03ikeYzefc2y3wnoe
+8neyeB+X071kpXg83nEAVuxqm1Yn1IMJCP9Tz7NhALhglEF2RzciUSwF+GDx8CW7
+RlSBlxbtEPxpODD8/tImnjRig/OngZFce8fds7NPEUxPsoS7xCQ6V+dSAaYM+QYi
+-----END EC PRIVATE KEY-----
diff --git a/openpower/package/sb-signing-utils/keys/hw_key_a.pem b/openpower/package/sb-signing-utils/keys/hw_key_a.pem
new file mode 100644
index 0000000000000000000000000000000000000000..1a37a0d5aceff1718b1ae0a0ac9c7ab88a415022
GIT binary patch
literal 133
zcmV;00DAuf0J|Otc$T1^FmiMTjpxdW0-&5#Lyu7O-YFhqH=lECx59cJ@^`X$AD7d;
zWTkjK-f;j{>}s1<C)9%p2>(;hvta<ZV3a|2M>ir-ECu*r@$e<PMpS{97VQxHX*e+a
n{?aC%G-8AEr-6}Nd&k|gvriFBPqKu&#3VXb=TZTt4EY8k2Pr-)

literal 0
HcmV?d00001

diff --git a/openpower/package/sb-signing-utils/keys/hw_key_b.key b/openpower/package/sb-signing-utils/keys/hw_key_b.key
new file mode 100644
index 0000000..db1fd18
--- /dev/null
+++ b/openpower/package/sb-signing-utils/keys/hw_key_b.key
@@ -0,0 +1,17 @@
+-----BEGIN EC PRIVATE KEY-----
+MIICnQIBAQRCAQ0nt+2t5RDGWJF6S326TEWyHPdI/VHm+pKvFgCCrVujE7P5oUlv
+GP3HZ3qemUX0RgmRjD27RflVdyOL6IlekHSsoIIBxjCCAcICAQEwTQYHKoZIzj0B
+AQJCAf//////////////////////////////////////////////////////////
+////////////////////////////MIGeBEIB////////////////////////////
+//////////////////////////////////////////////////////////wEQVGV
+PrlhjhyaH5KaIaC2hUDuotpyW5mzFfO4tImRjvEJ4VYZOVHsfpN7FlLAvTuxvwc1
+c9+IPSw08e9FH9RrUD8AAxUA0J6IACkcuFOWzGcXOTKEqqDaZLoEgYUEAMaFjga3
+BATpzZ4+y2YjlbRCnGSBOQU/tSH4KK9ga009uqFLXnfv51ko/h3BJ6L/qN4zSLPB
+hWpCm/l+fjHC5b1mARg5KWp4mjvABFyKX7QsfRvZmPVESVebRGgXr70XJz5mLJfu
+cple9CZAxVC5AT+tB2E1PHCGonLCQIi+lHaf0WZQAkIB////////////////////
+///////////////////////6UYaHg78vlmt/zAFI9wml0Du1ybiJnEeuu2+3HpE4
+ZAkCAQGhgYkDgYYABACTA8hhnkYIZKrc1O0tojIuF5Mhs9/XLMoSfPmDeqSXg2X9
+tjq598htT5uDWU/9WfrISQ9w81RR+blEvcY+GctkEQFJPYdOapsX2TVoNwvlJeVp
+gsQFwer4TOkmNV0FVbH7sJiHRw+ROHC5TOmy9YfQHCc2uAqInaZqPKTz13D8zQCG
+Cw==
+-----END EC PRIVATE KEY-----
diff --git a/openpower/package/sb-signing-utils/keys/hw_key_b.pem b/openpower/package/sb-signing-utils/keys/hw_key_b.pem
new file mode 100644
index 0000000000000000000000000000000000000000..ab2f50f02da94904f9b5929ee30480ab902b9392
GIT binary patch
literal 133
zcmV;00DAuf0FwjAVV*_^WUAcM?Jc4*E*Fy_v)|V&$`X9}gL<TwgJu1;I=T1AZBLtn
zSx^00`p8KSaPw4A`ME^B#y%O#WDx;LJ%>(en-|$NXg3SxCFN;?#0A0X_)O_0HC+W&
nvHP%?her>QIB>a4>9X~Q&>SZ=xC)4!rfNK-^Ve|v%>afA@IXOf

literal 0
HcmV?d00001

diff --git a/openpower/package/sb-signing-utils/keys/hw_key_c.key b/openpower/package/sb-signing-utils/keys/hw_key_c.key
new file mode 100644
index 0000000..7c338fe
--- /dev/null
+++ b/openpower/package/sb-signing-utils/keys/hw_key_c.key
@@ -0,0 +1,17 @@
+-----BEGIN EC PRIVATE KEY-----
+MIICnQIBAQRCASomU+ACnQy0UDtFX53VV2bwBrc3GPK3hbMrsU1E98YmU4eh/Dpj
+FYQOyCPV27GRK8V46a1xvWs57per+X4R9LVdoIIBxjCCAcICAQEwTQYHKoZIzj0B
+AQJCAf//////////////////////////////////////////////////////////
+////////////////////////////MIGeBEIB////////////////////////////
+//////////////////////////////////////////////////////////wEQVGV
+PrlhjhyaH5KaIaC2hUDuotpyW5mzFfO4tImRjvEJ4VYZOVHsfpN7FlLAvTuxvwc1
+c9+IPSw08e9FH9RrUD8AAxUA0J6IACkcuFOWzGcXOTKEqqDaZLoEgYUEAMaFjga3
+BATpzZ4+y2YjlbRCnGSBOQU/tSH4KK9ga009uqFLXnfv51ko/h3BJ6L/qN4zSLPB
+hWpCm/l+fjHC5b1mARg5KWp4mjvABFyKX7QsfRvZmPVESVebRGgXr70XJz5mLJfu
+cple9CZAxVC5AT+tB2E1PHCGonLCQIi+lHaf0WZQAkIB////////////////////
+///////////////////////6UYaHg78vlmt/zAFI9wml0Du1ybiJnEeuu2+3HpE4
+ZAkCAQGhgYkDgYYABAFUBCtSjR9PiJqVhg/EIsNGp0phvJ8gE5XBFTnox8n8a+Ji
+4e7r8Uae9Qea6hnvWa6HzAup1KEJAl6vobyhyItaegDEHRy56UIij9nDVYhSIXia
+EEln8xLVz5cB//hToEtexHUvdax85Nacwco6FyGNxzptGddL+/ds/rkZ05Q1fFUr
+WQ==
+-----END EC PRIVATE KEY-----
diff --git a/openpower/package/sb-signing-utils/keys/hw_key_c.pem b/openpower/package/sb-signing-utils/keys/hw_key_c.pem
new file mode 100644
index 0000000000000000000000000000000000000000..86d46fa81752d6d278cf8784611d6b679fb05dad
GIT binary patch
literal 133
zcmV;00DAuf0aOGlQjH%^h?<p#55ywFMyE<)yq_QwmBAG`=*P+YYvN+z?(6YJp7jTs
z>KX4@u7}JEsnnqf0$#77yrIa8T6zG)9UQsoLL!gZ!&Qh<A$Xb)NoVsC)z6m!|M*j&
nOJ2lvFLkVZ<kp<Q$~qSzjmJ7|8P`ku_iX;T8Pk+Cd{rx1;S54x

literal 0
HcmV?d00001

diff --git a/openpower/package/sb-signing-utils/keys/sw_key_a.key b/openpower/package/sb-signing-utils/keys/sw_key_a.key
new file mode 100644
index 0000000..e5536a9
--- /dev/null
+++ b/openpower/package/sb-signing-utils/keys/sw_key_a.key
@@ -0,0 +1,7 @@
+-----BEGIN EC PRIVATE KEY-----
+MIHcAgEBBEIA1vyq2cSPgwWxVtPIEOqGL3UVsy5juBQz8XekOq6aeYf/nqC9u8u+
+GqCiffgBCPnXfWOWLtkaokYEPuMe7TekzomgBwYFK4EEACOhgYkDgYYABAD8W6NM
+6nVfsYps75ko1gfNrJO9XqbWAuUuyFA/O8S5tPwVP+atGpc4PE+uTEI24t7mkYLa
+kZhnGlmQpjr4fjkFvgAZDwhcQ+hWmzXYEBobYIPgItJi+8GvxBHBZvQWqpVWRfU9
+nSOxLTjjZ3i3dvBnQpCnx4cpTtIJPzFuE+kXqxLDnQ==
+-----END EC PRIVATE KEY-----
diff --git a/openpower/package/sb-signing-utils/keys/sw_key_a.pem b/openpower/package/sb-signing-utils/keys/sw_key_a.pem
new file mode 100644
index 0000000000000000000000000000000000000000..7451ba8d3abd426af3564102396855a201b00c8c
GIT binary patch
literal 133
zcmV;00DAuf0Q_5{OzL%Cv5IW(nJCr=&8(BXUZ&Op<u1rjKRd*^wEPu6=B*l+I6P0T
zOhPu|-sX{l+L4%N8d;F0I{1D$1-<|o4+vaC=vJFG*bo{UV1wWy(qj9;uf!3-X7m=S
nl~zUdJ)I-5EjZ(6c(-=&XF`yt$A>9S(g{B?ZWHMjs}jSV3lBfc

literal 0
HcmV?d00001

diff --git a/openpower/package/sb-signing-utils/sb-signing-utils-0001-Highly-experimental-signing-utilities.patch b/openpower/package/sb-signing-utils/sb-signing-utils-0001-Highly-experimental-signing-utilities.patch
new file mode 100644
index 0000000..dda5ed0
--- /dev/null
+++ b/openpower/package/sb-signing-utils/sb-signing-utils-0001-Highly-experimental-signing-utilities.patch
@@ -0,0 +1,7574 @@
+From 1095222d605543cda0196e84cb93a8585ac04031 Mon Sep 17 00:00:00 2001
+From: SUBRAMANIAN SWAMINATHAN <subras@us.ibm.com>
+Date: Fri, 26 Aug 2016 13:27:14 -0400
+Subject: [PATCH] Support highly experimental secureboot signing utilities
+
+- Support highly experimental signing utilities
+- Support highly experimental signing utilities wrapper script
+---
+ Makefile.am                    |   29 +
+ README.md                      |    8 +
+ bootstrap.sh                   |   37 +
+ configure.ac                   |  124 +++
+ docs/AutomatedSigning.odt      |  Bin 0 -> 35984 bytes
+ m4/ax_cxx_compile_stdcxx.m4    |  562 +++++++++++++
+ m4/ax_cxx_compile_stdcxx_11.m4 |   39 +
+ scripts/Makefile.am            |   29 +
+ scripts/SignImage              |  114 +++
+ scripts/crtSignedContainer.pl  | 1622 ++++++++++++++++++++++++++++++++++++
+ src/Makefile.am                |   26 +
+ src/signtool/IBM_Container.cpp | 1767 ++++++++++++++++++++++++++++++++++++++++
+ src/signtool/IBM_Container.h   |  253 ++++++
+ src/signtool/IBM_Crypto.cpp    |  702 ++++++++++++++++
+ src/signtool/IBM_Crypto.h      |   93 +++
+ src/signtool/IBM_Exception.cpp |   69 ++
+ src/signtool/IBM_Exception.h   |   59 ++
+ src/signtool/IBM_HexString.h   |  194 +++++
+ src/signtool/IBM_Utils.cpp     |  262 ++++++
+ src/signtool/IBM_Utils.h       |   92 +++
+ src/signtool/Makefile.am       |   48 ++
+ src/signtool/signtool.cpp      |  593 ++++++++++++++
+ 22 files changed, 6722 insertions(+)
+ create mode 100755 Makefile.am
+ create mode 100755 README.md
+ create mode 100755 bootstrap.sh
+ create mode 100755 configure.ac
+ create mode 100644 docs/AutomatedSigning.odt
+ create mode 100644 m4/ax_cxx_compile_stdcxx.m4
+ create mode 100644 m4/ax_cxx_compile_stdcxx_11.m4
+ create mode 100755 scripts/Makefile.am
+ create mode 100755 scripts/SignImage
+ create mode 100755 scripts/crtSignedContainer.pl
+ create mode 100755 src/Makefile.am
+ create mode 100644 src/signtool/IBM_Container.cpp
+ create mode 100644 src/signtool/IBM_Container.h
+ create mode 100644 src/signtool/IBM_Crypto.cpp
+ create mode 100644 src/signtool/IBM_Crypto.h
+ create mode 100644 src/signtool/IBM_Exception.cpp
+ create mode 100644 src/signtool/IBM_Exception.h
+ create mode 100644 src/signtool/IBM_HexString.h
+ create mode 100755 src/signtool/IBM_Utils.cpp
+ create mode 100755 src/signtool/IBM_Utils.h
+ create mode 100755 src/signtool/Makefile.am
+ create mode 100755 src/signtool/signtool.cpp
+
+diff --git a/Makefile.am b/Makefile.am
+new file mode 100755
+index 0000000..c4e014f
+--- /dev/null
++++ b/Makefile.am
+@@ -0,0 +1,29 @@
++# IBM_PROLOG_BEGIN_TAG
++# This is an automatically generated prolog.
++#
++# $Source: Makefile.am $
++#
++# OpenPOWER sb-signing-utils Project
++#
++# Contributors Listed Below - COPYRIGHT 2016
++# [+] International Business Machines Corp.
++#
++#
++# Licensed under the Apache License, Version 2.0 (the "License");
++# you may not use this file except in compliance with the License.
++# You may obtain a copy of the License at
++#
++#     http://www.apache.org/licenses/LICENSE-2.0
++#
++# Unless required by applicable law or agreed to in writing, software
++# distributed under the License is distributed on an "AS IS" BASIS,
++# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
++# implied. See the License for the specific language governing
++# permissions and limitations under the License.
++#
++# IBM_PROLOG_END_TAG
++
++# Import the c++11 detection macros in the m4 dir
++ACLOCAL_AMFLAGS = -I m4
++
++SUBDIRS = src scripts
+diff --git a/README.md b/README.md
+new file mode 100755
+index 0000000..691a593
+--- /dev/null
++++ b/README.md
+@@ -0,0 +1,8 @@
++The signtool is an utility that can be used to issue sign/verify requests for a development or
++production mode.
++
++The development mode uses keys generated from an OpenSSL environment, while a production mode
++uses the IBM Crypto Card to generate and sign builds.
++
++A more detailed info about the signtool is in AutomatedSigning.odt file under the docs directory, a
++more complete example of signtool usage is in SignImage under the scripts directory.
+diff --git a/bootstrap.sh b/bootstrap.sh
+new file mode 100755
+index 0000000..fa2ffe7
+--- /dev/null
++++ b/bootstrap.sh
+@@ -0,0 +1,37 @@
++#!/bin/sh
++
++# IBM_PROLOG_BEGIN_TAG
++# This is an automatically generated prolog.
++#
++# $Source: bootstrap.sh $
++#
++# OpenPOWER sb-signing-utils Project
++#
++# Contributors Listed Below - COPYRIGHT 2016
++# [+] International Business Machines Corp.
++#
++#
++# Licensed under the Apache License, Version 2.0 (the "License");
++# you may not use this file except in compliance with the License.
++# You may obtain a copy of the License at
++#
++#     http://www.apache.org/licenses/LICENSE-2.0
++#
++# Unless required by applicable law or agreed to in writing, software
++# distributed under the License is distributed on an "AS IS" BASIS,
++# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
++# implied. See the License for the specific language governing
++# permissions and limitations under the License.
++#
++# IBM_PROLOG_END_TAG
++
++# get things started by running autoreconf 
++AUTORECONF=`which autoreconf`
++
++if [ $? != 0 ]
++then
++    echo "Install autoconf package and run this command again"
++    exit 1
++fi
++
++$AUTORECONF -i
+diff --git a/configure.ac b/configure.ac
+new file mode 100755
+index 0000000..4d32d7e
+--- /dev/null
++++ b/configure.ac
+@@ -0,0 +1,124 @@
++# IBM_PROLOG_BEGIN_TAG
++# This is an automatically generated prolog.
++#
++# $Source: configure.ac $
++#
++# OpenPOWER sb-signing-utils Project
++#
++# Contributors Listed Below - COPYRIGHT 2016
++# [+] International Business Machines Corp.
++#
++#
++# Licensed under the Apache License, Version 2.0 (the "License");
++# you may not use this file except in compliance with the License.
++# You may obtain a copy of the License at
++#
++#     http://www.apache.org/licenses/LICENSE-2.0
++#
++# Unless required by applicable law or agreed to in writing, software
++# distributed under the License is distributed on an "AS IS" BASIS,
++# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
++# implied. See the License for the specific language governing
++# permissions and limitations under the License.
++#
++# IBM_PROLOG_END_TAG
++
++AC_INIT(SecurebootSigningUtils, 1.0.0, subras@us.ibm.com)
++AC_CONFIG_AUX_DIR([config])
++AM_INIT_AUTOMAKE([-Wall -Werror foreign -Wno-portability])
++AM_SILENT_RULES([yes])
++AC_CONFIG_MACRO_DIR([m4])
++
++# not using config.h yet
++AC_CONFIG_HEADER([config.h])
++
++# Checks for programs.
++AC_PROG_CC
++AC_PROG_RANLIB
++AC_PROG_CXX
++
++# Checks for c++11 compatibility
++AX_CXX_COMPILE_STDCXX_11([noext],[optional])
++
++# Checks for libraries.
++ # FIXME: Replace `main' with a function in `-lrt':
++ AC_CHECK_LIB([rt], [main])
++
++# Checks for header files.
++
++# Checks for typedefs, structures, and compiler characteristics.
++ AC_C_CONST
++ AC_TYPE_PID_T
++ AC_HEADER_TIME
++ AC_STRUCT_TM
++ AC_TYPE_UINT16_T
++ AC_TYPE_UINT32_T
++ AC_TYPE_UINT8_T
++
++# Checks for library functions.
++ AC_FUNC_FORK
++ AC_PROG_GCC_TRADITIONAL
++ AC_FUNC_MALLOC
++ AC_HEADER_STDC
++ AC_TYPE_SIGNAL
++ AC_FUNC_VPRINTF
++ AC_CHECK_FUNCS([gettimeofday memset strchr])
++
++#--------------------------------------------------------------------
++# set top level dir, export dir and config dir
++#--------------------------------------------------------------------
++# the upper level dir
++project_dir="\$(top_srcdir)"
++AC_SUBST(project_dir)
++
++# exported files destination
++EXPORT_DIR="\$(project_dir)/export"
++AC_SUBST(EXPORT_DIR)
++
++# initialize name of library directory
++if test "x$host_cpu" != "x"; then
++   EXPORT_LIBDIR=$EXPORT_DIR/lib/$(host_cpu)
++else
++   # assume x86
++   EXPORT_LIBDIR=$EXPORT_DIR/lib/x86
++fi
++AC_SUBST(EXPORT_LIBDIR)
++
++
++# Check host for build type
++AM_CONDITIONAL(BLD_X86,  [test x${host}  = x] )
++
++# Set #define in config.h
++AH_TEMPLATE([__X86], [Defined if compiling for x86])
++AC_DEFINE(__X86,1)
++
++# initialize name of include directory
++EXPORT_INCDIR=$EXPORT_DIR/include
++AC_SUBST(EXPORT_INCDIR)
++
++#--------------------------------------------------------------------
++# compiler stuff
++#--------------------------------------------------------------------
++MY_CFLAGS="-Wall -Wno-sign-compare  -include config.h  -I \$(EXPORT_INCDIR)"
++
++AM_CPPFLAGS="$MY_CFLAGS"
++
++AC_SUBST(AM_CPPFLAGS)
++
++AM_CFLAGS="-I \$(EXPORT_INCDIR)"
++
++AC_SUBST(AM_CFLAGS)
++
++# extra config/make files
++config_dir="\$(project_dir)/config"
++AC_SUBST(config_dir)
++
++
++AC_CONFIG_FILES([
++   Makefile 
++   src/Makefile
++   src/signtool/Makefile
++   scripts/Makefile
++])
++
++AC_OUTPUT
+diff --git a/docs/AutomatedSigning.odt b/docs/AutomatedSigning.odt
+new file mode 100644
+index 0000000000000000000000000000000000000000..6acf5a0d195579ace2d1e4e75cd1469520b76e21
+GIT binary patch
+literal 35984
+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
+
+literal 0
+HcmV?d00001
+
+diff --git a/m4/ax_cxx_compile_stdcxx.m4 b/m4/ax_cxx_compile_stdcxx.m4
+new file mode 100644
+index 0000000..2c18e49
+--- /dev/null
++++ b/m4/ax_cxx_compile_stdcxx.m4
+@@ -0,0 +1,562 @@
++# ===========================================================================
++#   http://www.gnu.org/software/autoconf-archive/ax_cxx_compile_stdcxx.html
++# ===========================================================================
++#
++# SYNOPSIS
++#
++#   AX_CXX_COMPILE_STDCXX(VERSION, [ext|noext], [mandatory|optional])
++#
++# DESCRIPTION
++#
++#   Check for baseline language coverage in the compiler for the specified
++#   version of the C++ standard.  If necessary, add switches to CXX and
++#   CXXCPP to enable support.  VERSION may be '11' (for the C++11 standard)
++#   or '14' (for the C++14 standard).
++#
++#   The second argument, if specified, indicates whether you insist on an
++#   extended mode (e.g. -std=gnu++11) or a strict conformance mode (e.g.
++#   -std=c++11).  If neither is specified, you get whatever works, with
++#   preference for an extended mode.
++#
++#   The third argument, if specified 'mandatory' or if left unspecified,
++#   indicates that baseline support for the specified C++ standard is
++#   required and that the macro should error out if no mode with that
++#   support is found.  If specified 'optional', then configuration proceeds
++#   regardless, after defining HAVE_CXX${VERSION} if and only if a
++#   supporting mode is found.
++#
++# LICENSE
++#
++#   Copyright (c) 2008 Benjamin Kosnik <bkoz@redhat.com>
++#   Copyright (c) 2012 Zack Weinberg <zackw@panix.com>
++#   Copyright (c) 2013 Roy Stogner <roystgnr@ices.utexas.edu>
++#   Copyright (c) 2014, 2015 Google Inc.; contributed by Alexey Sokolov <sokolov@google.com>
++#   Copyright (c) 2015 Paul Norman <penorman@mac.com>
++#   Copyright (c) 2015 Moritz Klammler <moritz@klammler.eu>
++#
++#   Copying and distribution of this file, with or without modification, are
++#   permitted in any medium without royalty provided the copyright notice
++#   and this notice are preserved.  This file is offered as-is, without any
++#   warranty.
++
++#serial 4
++
++dnl  This macro is based on the code from the AX_CXX_COMPILE_STDCXX_11 macro
++dnl  (serial version number 13).
++
++AC_DEFUN([AX_CXX_COMPILE_STDCXX], [dnl
++  m4_if([$1], [11], [],
++        [$1], [14], [],
++        [$1], [17], [m4_fatal([support for C++17 not yet implemented in AX_CXX_COMPILE_STDCXX])],
++        [m4_fatal([invalid first argument `$1' to AX_CXX_COMPILE_STDCXX])])dnl
++  m4_if([$2], [], [],
++        [$2], [ext], [],
++        [$2], [noext], [],
++        [m4_fatal([invalid second argument `$2' to AX_CXX_COMPILE_STDCXX])])dnl
++  m4_if([$3], [], [ax_cxx_compile_cxx$1_required=true],
++        [$3], [mandatory], [ax_cxx_compile_cxx$1_required=true],
++        [$3], [optional], [ax_cxx_compile_cxx$1_required=false],
++        [m4_fatal([invalid third argument `$3' to AX_CXX_COMPILE_STDCXX])])
++  AC_LANG_PUSH([C++])dnl
++  ac_success=no
++  AC_CACHE_CHECK(whether $CXX supports C++$1 features by default,
++  ax_cv_cxx_compile_cxx$1,
++  [AC_COMPILE_IFELSE([AC_LANG_SOURCE([_AX_CXX_COMPILE_STDCXX_testbody_$1])],
++    [ax_cv_cxx_compile_cxx$1=yes],
++    [ax_cv_cxx_compile_cxx$1=no])])
++  if test x$ax_cv_cxx_compile_cxx$1 = xyes; then
++    ac_success=yes
++  fi
++
++  m4_if([$2], [noext], [], [dnl
++  if test x$ac_success = xno; then
++    for switch in -std=gnu++$1 -std=gnu++0x; do
++      cachevar=AS_TR_SH([ax_cv_cxx_compile_cxx$1_$switch])
++      AC_CACHE_CHECK(whether $CXX supports C++$1 features with $switch,
++                     $cachevar,
++        [ac_save_CXX="$CXX"
++         CXX="$CXX $switch"
++         AC_COMPILE_IFELSE([AC_LANG_SOURCE([_AX_CXX_COMPILE_STDCXX_testbody_$1])],
++          [eval $cachevar=yes],
++          [eval $cachevar=no])
++         CXX="$ac_save_CXX"])
++      if eval test x\$$cachevar = xyes; then
++        CXX="$CXX $switch"
++        if test -n "$CXXCPP" ; then
++          CXXCPP="$CXXCPP $switch"
++        fi
++        ac_success=yes
++        break
++      fi
++    done
++  fi])
++
++  m4_if([$2], [ext], [], [dnl
++  if test x$ac_success = xno; then
++    dnl HP's aCC needs +std=c++11 according to:
++    dnl http://h21007.www2.hp.com/portal/download/files/unprot/aCxx/PDF_Release_Notes/769149-001.pdf
++    dnl Cray's crayCC needs "-h std=c++11"
++    for switch in -std=c++$1 -std=c++0x +std=c++$1 "-h std=c++$1"; do
++      cachevar=AS_TR_SH([ax_cv_cxx_compile_cxx$1_$switch])
++      AC_CACHE_CHECK(whether $CXX supports C++$1 features with $switch,
++                     $cachevar,
++        [ac_save_CXX="$CXX"
++         CXX="$CXX $switch"
++         AC_COMPILE_IFELSE([AC_LANG_SOURCE([_AX_CXX_COMPILE_STDCXX_testbody_$1])],
++          [eval $cachevar=yes],
++          [eval $cachevar=no])
++         CXX="$ac_save_CXX"])
++      if eval test x\$$cachevar = xyes; then
++        CXX="$CXX $switch"
++        if test -n "$CXXCPP" ; then
++          CXXCPP="$CXXCPP $switch"
++        fi
++        ac_success=yes
++        break
++      fi
++    done
++  fi])
++  AC_LANG_POP([C++])
++  if test x$ax_cxx_compile_cxx$1_required = xtrue; then
++    if test x$ac_success = xno; then
++      AC_MSG_ERROR([*** A compiler with support for C++$1 language features is required.])
++    fi
++  fi
++  if test x$ac_success = xno; then
++    HAVE_CXX$1=0
++    AC_MSG_NOTICE([No compiler with C++$1 support was found])
++  else
++    HAVE_CXX$1=1
++    AC_DEFINE(HAVE_CXX$1,1,
++              [define if the compiler supports basic C++$1 syntax])
++  fi
++  AC_SUBST(HAVE_CXX$1)
++])
++
++
++dnl  Test body for checking C++11 support
++
++m4_define([_AX_CXX_COMPILE_STDCXX_testbody_11],
++  _AX_CXX_COMPILE_STDCXX_testbody_new_in_11
++)
++
++
++dnl  Test body for checking C++14 support
++
++m4_define([_AX_CXX_COMPILE_STDCXX_testbody_14],
++  _AX_CXX_COMPILE_STDCXX_testbody_new_in_11
++  _AX_CXX_COMPILE_STDCXX_testbody_new_in_14
++)
++
++
++dnl  Tests for new features in C++11
++
++m4_define([_AX_CXX_COMPILE_STDCXX_testbody_new_in_11], [[
++
++// If the compiler admits that it is not ready for C++11, why torture it?
++// Hopefully, this will speed up the test.
++
++#ifndef __cplusplus
++
++#error "This is not a C++ compiler"
++
++#elif __cplusplus < 201103L
++
++#error "This is not a C++11 compiler"
++
++#else
++
++namespace cxx11
++{
++
++  namespace test_static_assert
++  {
++
++    template <typename T>
++    struct check
++    {
++      static_assert(sizeof(int) <= sizeof(T), "not big enough");
++    };
++
++  }
++
++  namespace test_final_override
++  {
++
++    struct Base
++    {
++      virtual void f() {}
++    };
++
++    struct Derived : public Base
++    {
++      virtual void f() override {}
++    };
++
++  }
++
++  namespace test_double_right_angle_brackets
++  {
++
++    template < typename T >
++    struct check {};
++
++    typedef check<void> single_type;
++    typedef check<check<void>> double_type;
++    typedef check<check<check<void>>> triple_type;
++    typedef check<check<check<check<void>>>> quadruple_type;
++
++  }
++
++  namespace test_decltype
++  {
++
++    int
++    f()
++    {
++      int a = 1;
++      decltype(a) b = 2;
++      return a + b;
++    }
++
++  }
++
++  namespace test_type_deduction
++  {
++
++    template < typename T1, typename T2 >
++    struct is_same
++    {
++      static const bool value = false;
++    };
++
++    template < typename T >
++    struct is_same<T, T>
++    {
++      static const bool value = true;
++    };
++
++    template < typename T1, typename T2 >
++    auto
++    add(T1 a1, T2 a2) -> decltype(a1 + a2)
++    {
++      return a1 + a2;
++    }
++
++    int
++    test(const int c, volatile int v)
++    {
++      static_assert(is_same<int, decltype(0)>::value == true, "");
++      static_assert(is_same<int, decltype(c)>::value == false, "");
++      static_assert(is_same<int, decltype(v)>::value == false, "");
++      auto ac = c;
++      auto av = v;
++      auto sumi = ac + av + 'x';
++      auto sumf = ac + av + 1.0;
++      static_assert(is_same<int, decltype(ac)>::value == true, "");
++      static_assert(is_same<int, decltype(av)>::value == true, "");
++      static_assert(is_same<int, decltype(sumi)>::value == true, "");
++      static_assert(is_same<int, decltype(sumf)>::value == false, "");
++      static_assert(is_same<int, decltype(add(c, v))>::value == true, "");
++      return (sumf > 0.0) ? sumi : add(c, v);
++    }
++
++  }
++
++  namespace test_noexcept
++  {
++
++    int f() { return 0; }
++    int g() noexcept { return 0; }
++
++    static_assert(noexcept(f()) == false, "");
++    static_assert(noexcept(g()) == true, "");
++
++  }
++
++  namespace test_constexpr
++  {
++
++    template < typename CharT >
++    unsigned long constexpr
++    strlen_c_r(const CharT *const s, const unsigned long acc) noexcept
++    {
++      return *s ? strlen_c_r(s + 1, acc + 1) : acc;
++    }
++
++    template < typename CharT >
++    unsigned long constexpr
++    strlen_c(const CharT *const s) noexcept
++    {
++      return strlen_c_r(s, 0UL);
++    }
++
++    static_assert(strlen_c("") == 0UL, "");
++    static_assert(strlen_c("1") == 1UL, "");
++    static_assert(strlen_c("example") == 7UL, "");
++    static_assert(strlen_c("another\0example") == 7UL, "");
++
++  }
++
++  namespace test_rvalue_references
++  {
++
++    template < int N >
++    struct answer
++    {
++      static constexpr int value = N;
++    };
++
++    answer<1> f(int&)       { return answer<1>(); }
++    answer<2> f(const int&) { return answer<2>(); }
++    answer<3> f(int&&)      { return answer<3>(); }
++
++    void
++    test()
++    {
++      int i = 0;
++      const int c = 0;
++      static_assert(decltype(f(i))::value == 1, "");
++      static_assert(decltype(f(c))::value == 2, "");
++      static_assert(decltype(f(0))::value == 3, "");
++    }
++
++  }
++
++  namespace test_uniform_initialization
++  {
++
++    struct test
++    {
++      static const int zero {};
++      static const int one {1};
++    };
++
++    static_assert(test::zero == 0, "");
++    static_assert(test::one == 1, "");
++
++  }
++
++  namespace test_lambdas
++  {
++
++    void
++    test1()
++    {
++      auto lambda1 = [](){};
++      auto lambda2 = lambda1;
++      lambda1();
++      lambda2();
++    }
++
++    int
++    test2()
++    {
++      auto a = [](int i, int j){ return i + j; }(1, 2);
++      auto b = []() -> int { return '0'; }();
++      auto c = [=](){ return a + b; }();
++      auto d = [&](){ return c; }();
++      auto e = [a, &b](int x) mutable {
++        const auto identity = [](int y){ return y; };
++        for (auto i = 0; i < a; ++i)
++          a += b--;
++        return x + identity(a + b);
++      }(0);
++      return a + b + c + d + e;
++    }
++
++    int
++    test3()
++    {
++      const auto nullary = [](){ return 0; };
++      const auto unary = [](int x){ return x; };
++      using nullary_t = decltype(nullary);
++      using unary_t = decltype(unary);
++      const auto higher1st = [](nullary_t f){ return f(); };
++      const auto higher2nd = [unary](nullary_t f1){
++        return [unary, f1](unary_t f2){ return f2(unary(f1())); };
++      };
++      return higher1st(nullary) + higher2nd(nullary)(unary);
++    }
++
++  }
++
++  namespace test_variadic_templates
++  {
++
++    template <int...>
++    struct sum;
++
++    template <int N0, int... N1toN>
++    struct sum<N0, N1toN...>
++    {
++      static constexpr auto value = N0 + sum<N1toN...>::value;
++    };
++
++    template <>
++    struct sum<>
++    {
++      static constexpr auto value = 0;
++    };
++
++    static_assert(sum<>::value == 0, "");
++    static_assert(sum<1>::value == 1, "");
++    static_assert(sum<23>::value == 23, "");
++    static_assert(sum<1, 2>::value == 3, "");
++    static_assert(sum<5, 5, 11>::value == 21, "");
++    static_assert(sum<2, 3, 5, 7, 11, 13>::value == 41, "");
++
++  }
++
++  // http://stackoverflow.com/questions/13728184/template-aliases-and-sfinae
++  // Clang 3.1 fails with headers of libstd++ 4.8.3 when using std::function
++  // because of this.
++  namespace test_template_alias_sfinae
++  {
++
++    struct foo {};
++
++    template<typename T>
++    using member = typename T::member_type;
++
++    template<typename T>
++    void func(...) {}
++
++    template<typename T>
++    void func(member<T>*) {}
++
++    void test();
++
++    void test() { func<foo>(0); }
++
++  }
++
++}  // namespace cxx11
++
++#endif  // __cplusplus >= 201103L
++
++]])
++
++
++dnl  Tests for new features in C++14
++
++m4_define([_AX_CXX_COMPILE_STDCXX_testbody_new_in_14], [[
++
++// If the compiler admits that it is not ready for C++14, why torture it?
++// Hopefully, this will speed up the test.
++
++#ifndef __cplusplus
++
++#error "This is not a C++ compiler"
++
++#elif __cplusplus < 201402L
++
++#error "This is not a C++14 compiler"
++
++#else
++
++namespace cxx14
++{
++
++  namespace test_polymorphic_lambdas
++  {
++
++    int
++    test()
++    {
++      const auto lambda = [](auto&&... args){
++        const auto istiny = [](auto x){
++          return (sizeof(x) == 1UL) ? 1 : 0;
++        };
++        const int aretiny[] = { istiny(args)... };
++        return aretiny[0];
++      };
++      return lambda(1, 1L, 1.0f, '1');
++    }
++
++  }
++
++  namespace test_binary_literals
++  {
++
++    constexpr auto ivii = 0b0000000000101010;
++    static_assert(ivii == 42, "wrong value");
++
++  }
++
++  namespace test_generalized_constexpr
++  {
++
++    template < typename CharT >
++    constexpr unsigned long
++    strlen_c(const CharT *const s) noexcept
++    {
++      auto length = 0UL;
++      for (auto p = s; *p; ++p)
++        ++length;
++      return length;
++    }
++
++    static_assert(strlen_c("") == 0UL, "");
++    static_assert(strlen_c("x") == 1UL, "");
++    static_assert(strlen_c("test") == 4UL, "");
++    static_assert(strlen_c("another\0test") == 7UL, "");
++
++  }
++
++  namespace test_lambda_init_capture
++  {
++
++    int
++    test()
++    {
++      auto x = 0;
++      const auto lambda1 = [a = x](int b){ return a + b; };
++      const auto lambda2 = [a = lambda1(x)](){ return a; };
++      return lambda2();
++    }
++
++  }
++
++  namespace test_digit_seperators
++  {
++
++    constexpr auto ten_million = 100'000'000;
++    static_assert(ten_million == 100000000, "");
++
++  }
++
++  namespace test_return_type_deduction
++  {
++
++    auto f(int& x) { return x; }
++    decltype(auto) g(int& x) { return x; }
++
++    template < typename T1, typename T2 >
++    struct is_same
++    {
++      static constexpr auto value = false;
++    };
++
++    template < typename T >
++    struct is_same<T, T>
++    {
++      static constexpr auto value = true;
++    };
++
++    int
++    test()
++    {
++      auto x = 0;
++      static_assert(is_same<int, decltype(f(x))>::value, "");
++      static_assert(is_same<int&, decltype(g(x))>::value, "");
++      return x;
++    }
++
++  }
++
++}  // namespace cxx14
++
++#endif  // __cplusplus >= 201402L
++
++]])
+diff --git a/m4/ax_cxx_compile_stdcxx_11.m4 b/m4/ax_cxx_compile_stdcxx_11.m4
+new file mode 100644
+index 0000000..0aadeaf
+--- /dev/null
++++ b/m4/ax_cxx_compile_stdcxx_11.m4
+@@ -0,0 +1,39 @@
++# ============================================================================
++#  http://www.gnu.org/software/autoconf-archive/ax_cxx_compile_stdcxx_11.html
++# ============================================================================
++#
++# SYNOPSIS
++#
++#   AX_CXX_COMPILE_STDCXX_11([ext|noext], [mandatory|optional])
++#
++# DESCRIPTION
++#
++#   Check for baseline language coverage in the compiler for the C++11
++#   standard; if necessary, add switches to CXX and CXXCPP to enable
++#   support.
++#
++#   This macro is a convenience alias for calling the AX_CXX_COMPILE_STDCXX
++#   macro with the version set to C++11.  The two optional arguments are
++#   forwarded literally as the second and third argument respectively.
++#   Please see the documentation for the AX_CXX_COMPILE_STDCXX macro for
++#   more information.  If you want to use this macro, you also need to
++#   download the ax_cxx_compile_stdcxx.m4 file.
++#
++# LICENSE
++#
++#   Copyright (c) 2008 Benjamin Kosnik <bkoz@redhat.com>
++#   Copyright (c) 2012 Zack Weinberg <zackw@panix.com>
++#   Copyright (c) 2013 Roy Stogner <roystgnr@ices.utexas.edu>
++#   Copyright (c) 2014, 2015 Google Inc.; contributed by Alexey Sokolov <sokolov@google.com>
++#   Copyright (c) 2015 Paul Norman <penorman@mac.com>
++#   Copyright (c) 2015 Moritz Klammler <moritz@klammler.eu>
++#
++#   Copying and distribution of this file, with or without modification, are
++#   permitted in any medium without royalty provided the copyright notice
++#   and this notice are preserved. This file is offered as-is, without any
++#   warranty.
++
++#serial 17
++
++AX_REQUIRE_DEFINED([AX_CXX_COMPILE_STDCXX])
++AC_DEFUN([AX_CXX_COMPILE_STDCXX_11], [AX_CXX_COMPILE_STDCXX([11], [$1], [$2])])
+diff --git a/scripts/Makefile.am b/scripts/Makefile.am
+new file mode 100755
+index 0000000..4e5914c
+--- /dev/null
++++ b/scripts/Makefile.am
+@@ -0,0 +1,29 @@
++# IBM_PROLOG_BEGIN_TAG
++# This is an automatically generated prolog.
++#
++# $Source: scripts/Makefile.am $
++#
++# OpenPOWER sb-signing-utils Project
++#
++# Contributors Listed Below - COPYRIGHT 2016
++# [+] International Business Machines Corp.
++#
++#
++# Licensed under the Apache License, Version 2.0 (the "License");
++# you may not use this file except in compliance with the License.
++# You may obtain a copy of the License at
++#
++#     http://www.apache.org/licenses/LICENSE-2.0
++#
++# Unless required by applicable law or agreed to in writing, software
++# distributed under the License is distributed on an "AS IS" BASIS,
++# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
++# implied. See the License for the specific language governing
++# permissions and limitations under the License.
++#
++# IBM_PROLOG_END_TAG
++
++dist_bin_SCRIPTS = crtSignedContainer.pl
++
++install-exec-local:
++	$(INSTALL) -dv $(bindir)
+diff --git a/scripts/SignImage b/scripts/SignImage
+new file mode 100755
+index 0000000..4ff0574
+--- /dev/null
++++ b/scripts/SignImage
+@@ -0,0 +1,114 @@
++#!/bin/bash
++
++# IBM_PROLOG_BEGIN_TAG
++# This is an automatically generated prolog.
++#
++# $Source: scripts/SignImage $
++#
++# OpenPOWER sb-signing-utils Project
++#
++# Contributors Listed Below - COPYRIGHT 2016
++# [+] International Business Machines Corp.
++#
++#
++# Licensed under the Apache License, Version 2.0 (the "License");
++# you may not use this file except in compliance with the License.
++# You may obtain a copy of the License at
++#
++#     http://www.apache.org/licenses/LICENSE-2.0
++#
++# Unless required by applicable law or agreed to in writing, software
++# distributed under the License is distributed on an "AS IS" BASIS,
++# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
++# implied. See the License for the specific language governing
++# permissions and limitations under the License.
++#
++# IBM_PROLOG_END_TAG
++
++# the container consists of 3 Hardware Keys 
++#      * HW-KeyA - Hardware Public Key A
++#      * HW-KeyB - Hardware Public Key B
++#      * HW-KeyC - Hardware Public Key C
++# and 3 corresponding Hardware Signatures 
++#      * HW-SigA - Hardware Signature A
++#      * HW-SigB - Hardware Signature B
++#      * HW-SigC - Hardware Signature C
++# It also consists of upto 3 Software Keys (depends on project settings)
++#      * SW-KeyP - Software Public Key P
++#      * SW-KeyQ - Software Public Key Q
++#      * SW-KeyR - Software Public Key R
++# and upto 3 corresponding Software Signatures 
++#      * SW-SigP - Software Signature P
++#      * SW-SigQ - Software Signature Q
++#      * SW-SigR - Software Signature R
++ 
++SIGNTOOL=./signtool
++
++IMG_FILE=./images/skiboot.bin
++CONT_FILE=./images/skiboot.container
++CONT_IMG_FILE=./images/skiboot_container.bin
++
++SW_PRIVKEY_P=./keys/private/swpriv-p.key
++SW_PRIVKEY_Q=./keys/private/swpriv-q.key
++SW_PRIVKEY_R=./keys/private/swpriv-r.key
++
++SW_PUBKEY_P=./keys/public/swpub-p.key
++SW_PUBKEY_Q=./keys/public/swpub-q.key
++SW_PUBKEY_R=./keys/public/swpub-r.key
++
++SW_SIGN_P=./sign/swsign-p.bin
++SW_SIGN_Q=./sign/swsign-q.bin
++SW_SIGN_R=./sign/swsign-r.bin
++
++
++# firstly sign the component (signing server will sign for production builds,
++# openssl will be used for development builds).
++#   eg for skiboot.bin
++tmpVal=`stat -c %s ${IMG_FILE}`
++
++payloadSize=`printf "%x" ${tmpVal}`
++payloadHash=`sha512sum ${IMG_FILE} | awk '{print $1}'`
++
++
++# Now create a empty container (some headers will be set to default value)
++# and store in file skiboot_container.bin, by default the tool uses development mode
++${SIGNTOOL} --create-container --image-name ${CONT_FILE}
++
++# Update flags field of software header to 0x10203040
++${SIGNTOOL} --image-name ${CONT_FILE} --fld-name sw-flags --fld-value 0x10203040
++
++# Update payload size and payload hash field of software header
++${SIGNTOOL} --image-name ${CONT_FILE} --fld-name sw-payload-size --fld-value ${payloadSize}
++${SIGNTOOL} --image-name ${CONT_FILE} --fld-name sw-payload-hash --fld-value ${payloadHash}
++
++# Update code start offset field of software header to 0x84
++${SIGNTOOL} --image-name ${CONT_FILE} --fld-name sw-code-start-offset --fld-value 0x84
++
++# calculate Hash of Software header field
++swHdrHash=`${SIGNTOOL} --image-name ${CONT_FILE} --calchash --fldtype software_hdr --hashalgo sha512
++
++# now generate signatures of the software header using private keys (P, Q and R)
++${SIGNTOOL} --sign --privkeyfile ${SW_PRIVKEY_P} --digest ${swHdrHash} --sigfile ${SW_SIGN_P}
++${SIGNTOOL} --sign --privkeyfile ${SW_PRIVKEY_Q} --digest ${swHdrHash} --sigfile ${SW_SIGN_Q}
++${SIGNTOOL} --sign --privkeyfile ${SW_PRIVKEY_R} --digest ${swHdrHash} --sigfile ${SW_SIGN_R}
++
++# Now update the SW Public Key P, Q and R field in the container
++${SIGNTOOL} --image-name ${CONT_FILE} --fld-name sw-keyp --fld-value ${SW_PUBKEY_P}
++${SIGNTOOL} --image-name ${CONT_FILE} --fld-name sw-keyq --fld-value ${SW_PUBKEY_Q}
++${SIGNTOOL} --image-name ${CONT_FILE} --fld-name sw-keyr --fld-value ${SW_PUBKEY_R}
++ 
++
++# Now update the SW Signature P, Q and R Field in the container
++${SIGNTOOL} --image-name ${CONT_FILE} --fld-name sw-signp --fld-value ${SW_SIGN_P}
++${SIGNTOOL} --image-name ${CONT_FILE} --fld-name sw-signq --fld-value ${SW_SIGN_Q}
++${SIGNTOOL} --image-name ${CONT_FILE} --fld-name sw-signr --fld-value ${SW_SIGN_R}
++
++
++# You can verify the signature using the public keys
++${SIGNTOOL} --verify --pubkeyfile ${SW_PUBKEY_P} --digest ${swHdrHash} --sigfile ${SW_SIGN_P}
++${SIGNTOOL} --verify --pubkeyfile ${SW_PUBKEY_Q} --digest ${swHdrHash} --sigfile ${SW_SIGN_Q}
++${SIGNTOOL} --verify --pubkeyfile ${SW_PUBKEY_R} --digest ${swHdrHash} --sigfile ${SW_SIGN_R}
++
++
++# finally stitch the container header to the image 
++cat ${CONT_FILE} ${IMG_FILE} > ${CONT_IMG_FILE}
+diff --git a/scripts/crtSignedContainer.pl b/scripts/crtSignedContainer.pl
+new file mode 100755
+index 0000000..ffd28e4
+--- /dev/null
++++ b/scripts/crtSignedContainer.pl
+@@ -0,0 +1,1622 @@
++#!/usr/bin/perl
++# IBM_PROLOG_BEGIN_TAG
++# This is an automatically generated prolog.
++#
++# $Source: scripts/crtSignedContainer.pl $
++#
++# OpenPOWER sb-signing-utils Project
++#
++# Contributors Listed Below - COPYRIGHT 2016
++# [+] International Business Machines Corp.
++#
++# Licensed under the Apache License, Version 2.0 (the "License");
++# you may not use this file except in compliance with the License.
++# You may obtain a copy of the License at
++#
++#     http://www.apache.org/licenses/LICENSE-2.0
++#
++# Unless required by applicable law or agreed to in writing, software
++# distributed under the License is distributed on an "AS IS" BASIS,
++# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
++# implied. See the License for the specific language governing
++# permissions and limitations under the License.
++#
++# IBM_PROLOG_END_TAG
++#
++#
++#############################################################
++#
++# This script supports development mode only at this point.
++#
++# It will allow the caller to either
++# - create a valid FW key pair via openssl (in
++#    development mode)
++#
++# OR
++#  - create a signed container
++#
++# TODO (for production mode):
++# - update to tie into SignAgent interface since HW & FW
++#   private keys will reside in HSM
++#
++#############################################################
++
++use strict;
++use Carp;
++use Cwd;
++use Pod::Usage;
++use IO::File;
++use POSIX qw(strftime);
++use File::Basename;
++use File::Temp;
++use Getopt::Long qw(GetOptions);
++
++### TODO - make sure lines are <= 80 chars
++
++############
++#
++# Constants
++#
++############
++# Algorithm to use when calculating the digest value for the
++# binary to be signed
++#
++my $HASH_ALG = "sha512sum";
++
++use constant hexBytesPerHash      => 64;
++use constant asciiCharPerHexByte  => 2;
++use constant expectedHexPubKeyLen => 132;
++use constant hexBytesPerSignature => 132;
++
++
++############
++#
++# Variables
++#
++############
++
++# This temporary directory is used to store the
++# signatures that are generated,etc during this
++# processing. It should be cleaned up at the end.
++my $g_tmpdir = "";
++
++# global vars
++my @g_tmpFiles              = ();
++
++my %g_var; ### = {};
++$g_var{signing_mode}      = "development"; # or 'production'
++
++# being called only to create a key pair
++$g_var{createAkeyPair}    = 0;
++$g_var{createContainer}   = 1;   # create the container on each call
++$g_var{verbose}           = 0;
++
++my $g_pathPrefix          = "";
++my $g_ldLibPathPrefix     = "";
++
++# By default, the protected payload (and unprotected
++# payload, if specified) is attached to the end of
++# container object.
++$g_var{attachPayloads} = 1;
++
++# path to the sign tool/utility to call
++# (used to validate that the Linux
++# OS-supplied binary in /usr/bin is not
++# at the top of the caller's $PATH)
++$g_var{signutility} = `which signtool`;
++chomp($g_var{signutility});
++
++# The hardware keys are used to sign a digest of a
++# structure containing the digest of the FW public keys.
++# The signatures are stored in these binaries.
++my ($g_hwsignA, $g_hwsignB, $g_hwsignC) = "";
++
++my ($g_HWpubKeyA, $g_HWpubKeyB, $g_HWpubKeyC) = "";
++
++# These are the FW public keys that are stored
++# as a protected payload in the prefix key header.
++my ($g_SWpubKeyP, $g_SWpubKeyQ, $g_SWpubKeyR) = "";
++
++# Signatures that were generated associated with the FW
++# public keys
++my ($g_SWsignP, $g_SWsignQ, $g_SWsignR) = "";
++
++my $g_cfgHelp = 0;
++my $g_cfgMan  = 0;
++
++# global temp vars
++my $g_CMD      = "";
++my $g_cmdParms = "";
++my $g_rc       = 0;
++my @g_cmdOut   = ();
++
++####
++
++GetOptions (
++  'createKey:s'    => \$g_var{createKeyPair},
++  'privKeyPath:s'  => \$g_var{newPrivKeyPath},
++  'pubKeyPath:s'   => \$g_var{newPubKeyPath},
++
++
++  'protectedPayload:s'   => \$g_var{protected_payload},
++  'unprotectedPayload:s' => \$g_var{unprotected_payload},
++  'out:s'                => \$g_var{signed_container_name},
++
++  'hwPrivKeyA:s'         => \$g_var{HWprivKeyA},
++  'hwPrivKeyB:s'         => \$g_var{HWprivKeyB},
++  'hwPrivKeyC:s'         => \$g_var{HWprivKeyC},
++
++  'swPrivKeyP:s'         => \$g_var{SWprivKeyP},
++  'swPrivKeyQ:s'         => \$g_var{SWprivKeyQ},
++  'swPrivKeyR:s'         => \$g_var{SWprivKeyR},
++
++  'mode:s'               => \$g_var{signing_mode},
++
++  'flags-fw-key-ind:s'  => \$g_var{flags_fw_key_ind},
++  'code-start-offset:s' => \$g_var{code_start_offset},
++  'cont-size:s'         => \$g_var{input_final_cont_size},
++  'target-HRMOR:s'      => \$g_var{target_HRMOR},
++  'inst-start:s'        => \$g_var{inst_start},
++
++  'tempdir:s'           => \$g_var{inputTempDir},
++
++  'update'              => sub { $g_var{createContainer} = 0},
++  'noattach'            => sub { $g_var{attachPayloads} = 0},
++
++  'paramFile:s'         => \$g_var{paramFile},
++
++  'help'                => \$g_cfgHelp,
++  'man'                 => \$g_cfgMan,
++  'verbose'             => \$g_var{verbose} ) || pod2usage(-verbose => 0);
++
++pod2usage(-verbose => 1) if $g_cfgHelp;
++pod2usage(-verbose => 2) if $g_cfgMan;
++
++# pull out the parent dir for use in processing later
++if ($g_var{signed_container_name} =~ /\//) {
++   $g_var{signed_container_dir} = File::Basename::dirname($g_var{signed_container_name});
++} else {
++    $g_var{signed_container_dir} = cwd();
++}
++# for our intermediate files, put them in a space
++# the caller defines
++if ($g_var{inputTempDir}) {
++    $g_tmpdir = $g_var{inputTempDir};
++} else {
++   # get a temp dir, mark it for clean up upon exit
++   $g_tmpdir = File::Temp::tempdir(CLEANUP => 1);
++}
++
++# be nice and create the 'to' dir for the caller if it
++# doesn't exist
++if (!(-e "$g_var{signed_container_dir}")) {
++   print "$g_var{signed_container_dir} does not exist - creating it for you\n" if $g_var{verbose};
++   system("mkdir -p $g_var{signed_container_dir}");
++   if ($?) {
++      die "Unable to create $g_var{signed_container_dir}\n";
++   }
++}
++
++############################################################
++
++
++########################
++#
++#  (Optionally) load parameters from the input
++#    parameter file.
++#
++#  Verify all the parameters.
++#
++########################
++
++if ($g_var{paramFile}) {
++    # if parameter file specified, load its parameters first
++    parseParmFile(parmfile   => $g_var{paramFile},
++                  splitchars => "~~");
++
++    if ($g_pathPrefix) {
++        print "Updating the PATH to contain: $g_pathPrefix\n" if $g_var{verbose};
++        $ENV{PATH} = $g_pathPrefix . ":" . $ENV{PATH};
++        $g_var{signutility}              = `which signtool`;
++        chomp($g_var{signutility});
++    }
++    if ($g_ldLibPathPrefix) {
++        print "Updating the LD_LIBRARY_PATH to contain: $g_ldLibPathPrefix\n" if $g_var{verbose};
++        $ENV{LD_LIBRARY_PATH} = $g_ldLibPathPrefix . ":" . $ENV{LD_LIBRARY_PATH};
++    }
++}
++
++verifyParms();
++
++
++#######################
++#
++#  Environment set up
++#
++#######################
++
++# debug info - make sure we are running the right signing utility
++print "signtool = $g_var{signutility}\n" if $g_var{verbose};
++if ($g_var{signutility} =~ /^\/usr\/bin\/signtool/) {
++    print "Current path = $ENV{PATH}\n";
++    die "You are not set up to run the proper signtool binary - $g_var{signutility}\n";
++}
++
++
++#######################
++#
++#    Mainline
++#
++#######################
++
++# Called to create a private/public key pair using the
++# ECDSA 512 algorithm
++if ($g_var{createAkeyPair}) {
++
++    if ($g_var{verbose}) {
++      print "\n#############################################\n";
++      print "### --------  Key Pair Creation  -------- ###\n";
++    }
++    if ($g_var{newPrivKeyPath}) {
++    # caller requested a specific path to contain the new key pair
++        my ($rc, $msg) = createKeyPair(
++                       privKeyPath => $g_var{newPrivKeyPath},
++                       pubKeyPath  => $g_var{newPubKeyPath},
++                       verbose     => 1);
++        if ($g_rc> 0) {
++            die "$msg";
++        } elsif ($g_var{verbose}) {
++            print "New key pairs have been created as:\n $g_var{newPrivKeyPath} \n$g_var{newPubKeyPath}\n";
++        }
++        exit 0;
++    }
++}
++
++# The public keys all are added to the signed container
++# header(s), so do this one call to extract them from
++# the private key files that the caller passed in
++# (this step applicable to development mode only)
++extractPubKeysFromPriv(
++            mode   => $g_var{signing_mode},
++            hwkeya => $g_var{HWprivKeyA},
++            hwkeyb => $g_var{HWprivKeyB},
++            hwkeyc => $g_var{HWprivKeyC},
++            swkeyp => $g_var{SWprivKeyP},
++            swkeyq => $g_var{SWprivKeyQ},
++            swkeyr => $g_var{SWprivKeyR}
++            );
++
++# Concatenate the FW keys into one blob so their size
++# and hash can be calculated
++if ($g_var{verbose}) {
++    print "\n##########################################################################\n";
++    print "### --------  Concat FW keys, get size and hash of that blob  -------- ###\n";
++}
++my ($psrc, $hdrPayloadSize, $hdrPayloadHash, $hdrHashLen) = prepFWkeyBlob();
++if ($psrc > 0) {
++    die "prepFWkeyBlob failed.  FW keys were not processed successfully.";
++}
++if ($g_var{verbose}) {
++    print "*************************** Calculated FW key info:\n";
++    print "FW key hash size  : $hdrPayloadSize\n";
++    print "FW key hash       : $hdrPayloadHash\n";
++    print "FW key(s) hash len: $hdrHashLen\n";
++}
++
++#########
++#
++# Create an EC 521 Curve Keypair :
++#   <sign utility> --mode development --create_key --privkeyfile ecpriv.pem --pubkeyfile ecpub.pem
++#
++# Sign a sha-512 digest using openssl keys created above
++# echo "this is a test message" > /tmp/message.txt
++# SHA512_SUM=`sha512sum /tmp/message.txt | awk '{print $1}'`
++# <sign utility> --mode development --sign --projname ecpriv.pem --sigfile message.sig --digest $SHA512_SUM
++#
++# Verify a sha-512 digest signed by openssl keys
++# echo "this is a test message" > /tmp/message.txt
++# SHA512_SUM=`sha512sum /tmp/message.txt | awk '{print $1}'`
++# <sign utility> --mode development --verify --pubkeyfile ecpub.pem --sigfile message.sig --digest $SHA512_SUM
++#
++##########
++
++if ($g_var{createContainer}) {
++    if ($g_var{verbose}) {
++        print "\n###############################################\n";
++        print "### ---- Create the basic container header ----- ####\n";
++
++        print "\n\nCall the tool to create the prefix header structure for a signed container (which includes some defaults and signature placeholders)\n";
++    }
++    $g_cmdParms = "--create-container";
++    updCont($g_cmdParms);
++
++    if ($g_var{verbose}) {
++        print "\nNewly-created (mostly-empty signed container, with just a few default values set in it) can be found in:\n";
++        print "$g_var{signed_container_name}\n";
++    }
++} else {
++    if ($g_var{verbose}) {
++        print "Skip creation of the container.\n";
++    }
++}
++
++if ($g_var{verbose}) {
++    print "\n###########################################################\n";
++    print "### ----  Start updating fields in the container ----- ####\n";
++
++    print "\nNow updating some of the base fields in the container\n";
++}
++
++######################
++#
++# Fields at the top of the hardware header
++
++if ($g_var{target_HRMOR}) {
++  if ($g_var{verbose}) {
++      print "Now update the target HRMOR in the container\n";
++  }
++  $g_cmdParms = "--fldname target-hrmor --fldvalue $g_var{target_HRMOR}";
++  updCont($g_cmdParms);
++}
++
++if ($g_var{inst_start}) {
++  if ($g_var{verbose}) {
++      print "Now update the instruction start stack pointer address in the container\n";
++  }
++  $g_cmdParms = "--fldname stack-pointer --fldvalue $g_var{inst_start}";
++  updCont($g_cmdParms);
++}
++
++#########################
++#
++# Make sure the hardware prefix header fields are filled in
++
++if ($g_var{flags_fw_key_ind}) {
++  if ($g_var{verbose}) {
++      print "Now update the firmware key indicator flags in the container\n";
++  }
++  $g_cmdParms = "--fldname hdr-flags --fldvalue $g_var{flags_fw_key_ind} ";
++  updCont($g_cmdParms);
++}
++
++if ($g_var{verbose}) {
++    print "Now update the prefix key header's protected payload size in the container\n";
++}
++# header's protected payload size must be the hex represenation of:
++#  # bytes * number of FW public keys
++my $verifySize = expectedHexPubKeyLen * $g_var{in_swKeyCount};
++my $hexSize = convertValueToHexStr($verifySize);
++if ($hexSize != $hdrPayloadSize) {
++    die "ERROR: Expected size for the 'header payload size'is $hexSize (decimal size, $verifySize). Actual size is $hdrPayloadSize. ";
++}
++$g_cmdParms = "--fldname hdr-payload-size --fldvalue $hdrPayloadSize";
++updCont($g_cmdParms);
++
++my $verifyHashLen   = length($hdrPayloadHash);
++my $hashShouldBeLen = hexBytesPerHash * asciiCharPerHexByte;
++if ($verifyHashLen != $hashShouldBeLen) {
++    die "ERROR: The length of the header payload hash' should be $hashShouldBeLen. Actual value is $verifyHashLen";
++}
++
++print "\n*****  Update the 'hash of protected payload' value in the prefix key header\n" if $g_var{verbose};
++$g_cmdParms = "--fldname hdr-payload-hash --fldvalue $hdrPayloadHash ";
++updCont($g_cmdParms);
++
++# Update the FW public keys into the container
++#   (Need to do this here so the FW public key count is valid in the
++#  hardware header before the payload is hashed and signed)
++my ($swrc, $swdet) = SWkeys();
++if ($swrc > 0) {
++    die "ERROR: Failed to update the FW public keys into the container: $swdet\n";
++}
++
++###############
++#
++# call <sign utility> to compute a signature over the digest
++# of the hardware prefix header (digest excludes HW signatures
++# and FW public keys)
++#
++# Get the digest of the hardware prefix header (digest excludes
++# HW signatures and FW public keys)
++$g_CMD = "$g_var{signutility} --imagefile $g_var{signed_container_name} --calchash --fldtype prefix_hdr";
++my $hwPrefixHdrDigest = `$g_CMD`;
++if ($? > 0) {
++    die "ERROR: Failed to get the digest of the hardware prefix header.\n";
++}
++chomp($hwPrefixHdrDigest);
++print "Hardware prefix header digest: $hwPrefixHdrDigest\n" if $g_var{verbose};
++
++#
++# Sign that digest using each of the hardware private keys to
++# get the hdw signatures
++my $skrc = signPrefixKeyHeaderDigest(digestToSign => $hwPrefixHdrDigest);
++if ($skrc > 0) {
++    die "ERROR: Failed to calculate the signature of the hardware prefix key header digest";
++}
++
++# Update the hardware keys and signatures into the
++# container
++HWkeyInfo();
++
++
++###############
++#
++#   Software header
++#
++
++# Calculate the size of the binary that we are to sign and
++# get the associated hash value.
++if ($g_var{verbose}) {
++  print "\n#################################################################\n";
++  print "### ------  Calc size and hash of protected payload ------ ###\n";
++}
++my ($pshrc, $sfwPayloadSize, $sfwPayloadHash, $sfwHashLen) = getSizeAndHash($g_var{protected_payload});
++if ($pshrc > 0) {
++    die "ERROR: getSizeAndHash failed while processing $g_var{protected_payload}";
++}
++if ($g_var{verbose}) {
++    print "Binary size : $sfwPayloadSize\n";
++    print "Binary hash : $sfwPayloadHash\n";
++    print "hash len    : $sfwHashLen\n";
++}
++
++# code start offset is specified as "x(hex value)"
++if ($g_var{code_start_offset}) {
++   # normalize values back to decimal (since the
++   # caller can pass in '0xZZZ' or 'ZZZ') to allow
++   # for an easier comparison
++   my $dec_code_start = hex($g_var{code_start_offset});
++   my $dec_payloadlen = hex($sfwPayloadSize);
++   if ($dec_code_start >= $dec_payloadlen) {
++     die "ERROR: code-start-offset, $g_var{code_start_offset}, appears to be outside the bounds of the protected payload, $g_var{protected_payload}; size of which (in hex) is $sfwPayloadSize\n";
++   }
++  if ($g_var{verbose}) {
++      print "Now update the code start offset in the container\n";
++  }
++  $g_cmdParms = "--fldname sw-code-start-offset --fldvalue $g_var{code_start_offset}";
++  updCont($g_cmdParms);
++}
++
++# Update the size of the software payload (the size of the
++# binary the caller asked us to sign)
++$g_cmdParms = "--fldname sw-payload-size --fldvalue $sfwPayloadSize";
++updCont($g_cmdParms);
++
++# Add the protected payload hash to the container
++print  "\nAdd the protected payload hash to the container\n" if $g_var{verbose};
++$g_cmdParms = "--fldname sw-payload-hash --fldvalue $sfwPayloadHash";
++updCont($g_cmdParms);
++
++###############
++#
++# call <sign utility> to get a signature over the digest
++#  of the software header (excluding software signatures
++#  and padding)
++#
++
++$g_CMD = "$g_var{signutility} --imagefile $g_var{signed_container_name} --calchash --fldtype software_hdr";
++my $sfwHeaderDigest = `$g_CMD`;
++if ($? > 0) {
++   die "ERROR: Failure encountered creating the software header digest";
++}
++chomp($sfwHeaderDigest);
++print "Software header digest:  $sfwHeaderDigest\n" if $g_var{verbose};
++
++# Sign the software header digest
++my $snrc = signSoftwareHeaderDigest(hashToSign => $sfwHeaderDigest);
++if ($snrc > 0) {
++    die "ERROR: signSoftwareHeaderDigest failed";
++}
++
++
++#########
++#
++# Finish up by updating the FW signatures, and
++# (optionally) attaching the protected and
++# unprotected payloads.
++
++# Update the software signatures into the container
++SWsigns();
++
++# Attach the binary that we just created a signature for
++# to make a temporary object so we can get what will be
++# the size of the final container object.
++my $tmpFinalContainer = "";
++my $prc = 0;
++my $containerSize = 0;
++my $containerHash = "";
++my $contHashLen   = 0;
++if ($g_var{attachPayloads}) {
++    $tmpFinalContainer = $g_var{signed_container_name} . "_temp";
++    attachBinaryToContainer(finalContainer => $g_var{signed_container_name},
++                            protected      => $g_var{protected_payload},
++                            unprotected    => $g_var{unprotected_payload},
++                            outfile        => $tmpFinalContainer,
++                            createFinal    => 0);
++
++    print "\nCalculate the size of the interim final container\n" if $g_var{verbose};
++    ($prc, $containerSize, $containerHash, $contHashLen) = getSizeAndHash($tmpFinalContainer);
++    if ($prc > 0) {
++       die "ERROR: getSizeAndHash failed while processing $tmpFinalContainer";
++    }
++} else {
++    # get the size of the container (the header) alone
++    ($prc, $containerSize, $containerHash, $contHashLen) = getSizeAndHash($g_var{signed_container_name});
++    if ($prc > 0) {
++       die "ERROR: getSizeAndHash failed while processing $g_var{signed_container_name}";
++    }
++}
++
++# Have to calculate what the final size WOULD BE once the payload
++# (the binary to be signed) is attached, then update the header
++# with that size.
++#    THEN, attach the binary to the signed container later. Trying
++# to update the size in the container after that payload binary
++# is attached will remove the attached binary.
++if ($g_var{input_final_cont_size}) {
++  if ($g_var{verbose}) {
++      print "Total container size, $g_var{input_final_cont_size} was passed in. It will be updated into the header\n";
++  }
++  $g_cmdParms = "--fldname container-size --fldvalue $g_var{input_final_cont_size}";
++} else {
++  # go with the size that we calculated
++  $g_cmdParms = "--fldname container-size --fldvalue $containerSize";
++}
++updCont($g_cmdParms);
++
++if ($g_var{attachPayloads}) {
++    # NOW really attach the binary to the final header
++    attachBinaryToContainer(finalContainer => $g_var{signed_container_name},
++                            protected      => $g_var{protected_payload},
++                            unprotected    => $g_var{unprotected_payload},
++                            outfile        => $tmpFinalContainer,
++                            createFinal    => 1);
++}
++
++print "\n$g_var{signed_container_name} created/updated\n";
++my $timest = `stat -c %z $g_var{signed_container_name}`;
++print "Create time: $timest\n" if $g_var{verbose};
++
++
++exit 0;
++
++#############################################################
++#
++#  Subroutines
++#
++############################################################
++
++#
++# Verify the existence and relationships of the input parameters.
++#  This should do verification of only the things that the
++# signtool doesn't (and likely, shouldn't do), such as making
++# sure we have the right number of keys.
++#
++sub verifyParms {
++
++    if ($g_var{signing_mode} and
++        ( ($g_var{signing_mode} eq "development") or
++          ($g_var{signing_mode} eq "production")) ) {
++       # then ok
++    } else {
++        die "-mode must be 'production' or 'development'\n";
++    }
++
++    if (!(exists($g_var{createAkeyPair})) and
++        !(exists($g_var{protected_payload}))) {
++        die "You must specify either --protectedPayload OR the --createKey option to create a key pair";
++    } elsif ($g_var{createAkeyPair} and $g_var{protected_payload}) {
++        die "You may not specify both --protectedPayload and --createKey";
++    }
++    # Called only to create a key pair
++    if ($g_var{createAkeyPair}) {
++        if (!$g_var{newPrivKeyPath}) {
++            die "Path to private key file to be generated is required";
++        }
++        if (!$g_var{newPubKeyPath}) {
++            die "Path to public key file to be generated is required";
++        }
++    } else {
++        if (!(-e "$g_var{protected_payload}")) {
++            die "Protected payload, $g_var{protected_payload}, is not found";
++        }
++    }
++
++    if ($g_var{createContainer}) {
++    # 3 hardware private keys are required
++    if (!$g_var{HWprivKeyA}) {
++        die "Hardware private key A required\n";
++    } elsif  (!(-e $g_var{HWprivKeyA})) {
++        die "Hardware signing key A, $g_var{HWprivKeyA}, not found\n";
++    }
++    if (!$g_var{HWprivKeyB}) {
++        die "Hardware private key B required\n";
++    } elsif  (!(-e $g_var{HWprivKeyB})) {
++        die "Hardware signing key B, $g_var{HWprivKeyB}, not found\n";
++    }
++    if (!$g_var{HWprivKeyC}) {
++        die "Hardware private key C required\n";
++    } elsif  (!(-e $g_var{HWprivKeyC})) {
++        die "Hardware signing key C, $g_var{HWprivKeyC}, not found\n";
++    }
++    # 1 software private key is required
++    if (!$g_var{SWprivKeyP}) {
++        die "Software private key P required\n";
++    } elsif  (!(-e $g_var{SWprivKeyP})) {
++        die "Software signing key P,$g_var{SWprivKeyP}, not found\n";
++    } else {
++        $g_var{in_swKeyCount}++;
++    }
++
++    # Validate the existence of the optional keys, Q and R, if
++        # specified
++        if ($g_var{SWprivKeyQ}) {
++            $g_var{in_swKeyCount}++;
++        if (!(-e $g_var{SWprivKeyQ})) {
++          die "FW signing key Q,$g_var{SWprivKeyQ}, not found\n";
++        }
++    }
++
++    if ($g_var{SWprivKeyR}) {
++        $g_var{in_swKeyCount}++;
++        if (!(-e $g_var{SWprivKeyR})) {
++          die "FW signing key R,$g_var{SWprivKeyR}, not found\n";
++        }
++    }
++    }
++    if ($g_var{unprotected_payload}) {
++        if (!(-e "$g_var{unprotected_payload}")) {
++            die "$g_var{unprotected_payload} not found\n";
++        }
++    }
++
++    # outfile is required
++    if (!$g_var{signed_container_name}) {
++        die "Output file (-out) is required\n";
++    } elsif (!$g_var{createContainer}) {
++        if (!(-e "$g_var{signed_container_name}")) {
++            die "$g_var{signed_container_name} not found";
++        }
++    }
++}
++
++
++
++#
++# Call the sign utility to create a key pair
++sub createKeyPair {
++    my %data        = @_;
++    my $privKeyPath = $data{privKeyPath} || "";
++    my $pubKeyPath  = $data{pubKeyPath}  || "";
++
++    my $keyDir      = $data{keyDir}      || "";
++    my $newPrivKey  = $data{privKeyName} || "";
++    my $newPubKey   = $data{pubKeyName}  || "";
++    my $verbose     = $data{verbose}     || 0;
++
++    if (!$privKeyPath and !$keyDir) {
++        confess "createKeyPair: privKeyPath (full path) or keyDir,privKeyName (dir, file) are required";
++    }
++    if ($privKeyPath) {
++        $keyDir = dirname($privKeyPath);
++    } else {
++        $privKeyPath = $keyDir . "/$newPrivKey";
++        $pubKeyPath  = $keyDir . "/$newPubKey";
++    }
++
++    print "\n\nCalling $g_var{signutility} to create an EC 521 Curve Keypair.\n" if $verbose;
++    if (!(-e "$keyDir")) {
++        system("mkdir -p $keyDir");
++        if ($?) {
++            die "ERROR: createKeyPair unable to create directory, $keyDir";
++        }
++    }
++    $g_CMD = "$g_var{signutility} --mode $g_var{signing_mode} --create_key --privkeyfile $privKeyPath --pubkeyfile $pubKeyPath";
++    ($g_rc, @g_cmdOut) = runCmd($g_CMD);
++    if ($g_rc> 0) {
++        print "Returned: $g_rc, @g_cmdOut\n";
++        return 1, "ERROR: Unable to create a key pair\n";
++    }
++    if (!(-e "$privKeyPath")) {
++        return 1, "ERROR:$privKeyPath was not created";
++    }
++    if (!(-e "$pubKeyPath")) {
++        return 1, "ERROR:$privKeyPath was not created";
++    }
++    print "New private and public keys have been created now in $keyDir\n" if $verbose;
++    return 0, "";
++}
++#
++# Convert value to hexstring
++sub convertValueToHexStr {
++   my $invalue = shift;
++   return `printf "%x" $invalue`;
++}
++#
++# Validate that all chars in the string are
++# valid hex chars
++sub validHexCharStr {
++    my $inhexstr = shift;
++    if ($inhexstr =~ /^[\da-f]+\z/i) {
++        return 1;
++    } else {
++        return 0;
++    }
++}
++#
++# Calculate the size of the input binary, convert
++# value to hex.
++# Calculate sum value of the binary
++#
++sub getSizeAndHash {
++    my $binaryPathOrStr = shift;
++
++    # Get the size of the binary that was passed in (one of the
++    # values in the header is the 'payload' size)
++    #if (!(-e "$binaryPathOrStr")) {
++    #    die "getSizeAndHash:ERROR:$binaryPathOrStr not found\n";
++    #}
++    my $hexSize = 0;
++    my $tmpSize  = 0;
++
++    if (-e "$binaryPathOrStr") {
++      # if the value passed in is a file, then get the size
++      $tmpSize  = `stat -c %s $binaryPathOrStr`;
++      if ($? > 0) {
++        die "ERROR: getSizeAndHash failed on 'stat' of $binaryPathOrStr";
++      }
++    } else {
++       # it must be just a string
++       $tmpSize = length($binaryPathOrStr);
++    }
++    $hexSize = convertValueToHexStr($tmpSize);
++    # Get a hash of the binary
++    my $binHash = "";
++    if (-e "$binaryPathOrStr") {
++      $binHash = `$HASH_ALG $binaryPathOrStr | awk '{print $1}'`;
++      if ($? > 0) {
++        die "ERROR: getSizeAndHash failed attempting to run $HASH_ALG on $binaryPathOrStr";
++      }
++    } else {
++      # die until it is fixed - for next delivery
++      die "getSizeAndHash subr does not work for strings yet\n";
++
++      #print " if a string and not a file ($binaryPathOrStr not found)\n";
++      # my $str = "some string";
++      # -n = do not add newline to end of supplied string
++      my $binHash = `echo -n '$binaryPathOrStr' | $HASH_ALG -`;
++      chomp($binHash);
++      $binHash =~ s%  -%%;
++    }
++    my @tmpvals   = split(' ', $binHash);
++    my $hashValue = $tmpvals[0];
++    my $hashLen   = length($hashValue);
++    if ($g_var{verbose}) {
++      print "getSizeAndHash returning:\n Size:$hexSize\n Hash:'$hashValue'\nHash value length:$hashLen\n";
++    }
++    return 0, $hexSize, $hashValue, $hashLen;
++}
++
++#
++# Input to this is a hash of the binary to be signed, the key to
++# use to do the signing and an outfile that is to receive the
++# signature.
++sub generateSignature {
++    my %data           = @_;
++    my $digestToBeSigned = $data{digestToSign} || confess "digest required";
++    my $keyToUse         = $data{keyToUse}     || confess "key for signing the digest is required";
++    my $tmp_sig_file     = $data{sigfile}      || confess "sigfile required";
++    my $verbose          = $data{verbose}      || 0;
++
++    ### TODO (production mode): ... the name of the key to use ... how does this get handled dev vs prod. Prod needs name of a project with associated key, dev could point to any key and dev users would not have a notion of a project.
++    $g_var{projname_or_key} = "--projname $keyToUse";
++
++    # basic validation - valid hex chars in the string?
++    if (!(validHexCharStr($digestToBeSigned))) {
++        die "ERROR: generateSignature received a digest containing non-hex characters (digest: '$digestToBeSigned')";
++    }
++    # length what we expect?
++    my $actualLen = length($digestToBeSigned);
++    my $expectedDigestLength = hexBytesPerHash * asciiCharPerHexByte;
++    if ($actualLen != $expectedDigestLength) {
++        die "ERROR: generateSignature expected a digest length of $expectedDigestLength, actual length is $actualLen for $digestToBeSigned";
++    }
++    # Sign the hash (digest) passed in and save the signature
++    # value into the sigfile
++    print  "generateSignature: Signing the digest \n" if $verbose;
++    $g_CMD = "$g_var{signutility} --mode $g_var{signing_mode} --sign $g_var{projname_or_key} --sigfile $tmp_sig_file --digest $digestToBeSigned";
++    ($g_rc, @g_cmdOut) = runCmd($g_CMD);
++    if ($g_rc> 0) {
++        print "Returned: $g_rc, @g_cmdOut\n";
++        return $g_rc, "ERROR:Signing operation failed";
++    }
++    return $g_rc, "";
++}
++
++#
++# Accepts just the parms to build up and run the sign utility
++sub updCont {
++  my $parms   = shift;
++
++  my $utilCmd = "$g_var{signutility} --mode $g_var{signing_mode} --imagefile $g_var{signed_container_name} ";
++  $utilCmd .= $parms;
++  if ($g_var{verbose}) { print "$utilCmd\n"; }
++  system($utilCmd);
++  if ($?)  {
++    die ( "'$utilCmd' failed to execute: $!\n" );
++  } else {
++      print "\nCommand:\n$utilCmd\nCompletion : OK\n" if ($g_var{verbose});
++  }
++}
++
++# Runs a given command, capturing the output in an array as well
++# as displaying output of the command to stdout in real time
++# (as opposed to waiting until the program is finished running
++# and then dumping the output all at once).
++#
++sub runCmd
++{
++  my $l_cmd   = shift;
++  my $logfile = shift || "";
++
++  my $l_rc= 0;
++  my @output = ();
++
++  logit ( "Issuing - $l_cmd\n", 0, $logfile, 0, 1 ) if $g_var{verbose};
++  open ( CMD, "$l_cmd 2>&1 |" ) or die "$l_cmd failed to execute";
++  while ( <CMD> )  {
++    logit ( $_, 0, $logfile, 0, 0 );
++    push ( @output, $_ );
++  }
++  close ( CMD ) or CMD->autoflush() and die "$l_cmd failed";
++
++  if ( $? != 0 )  {
++    $l_rc = 1;
++    logit ( "'$l_cmd' failed to execute: $!\n" );
++  }
++  return $l_rc, @output;
++}
++
++# Prints the given message string, prepended with a date stamp,
++# to stdout and, if specified, to the given logfile. If in
++# testing mode, will only print to stdout, not to the logfile.
++sub logit
++{
++  my $message = shift;
++  my $noprint = shift || 0;
++  my $logfile = shift || "";
++  my $testing = shift || 0;
++  my $addtime = shift || 0;
++
++  # Apparently having a ' in the string to output will cause
++  # some errors to pop up so we need to convert the string to
++  # be shell literal
++  $message =~ s/'/'\\''/g;
++
++  my $curtime = getNowTime();
++  if ($addtime){
++    $message = "$curtime    $message";
++  }
++  print "$message\n"     if !$noprint;
++  if ($logfile && !$testing) {
++    `echo '$message' >> $logfile`;
++  }
++}
++
++#
++# Get the current date in a couple of specific formats
++sub getNowTime {
++   my $format = shift || "Ymd_HMS";
++
++   my $now = "";
++   if ($format eq "Ymd_HMS") {
++     $now = strftime "%Y%m%d_%H%M%S", localtime;
++   } elsif ($format eq "Y-m-d H:M:S") {
++     $now = strftime "%Y-%m-%d %H:%M:%S", localtime;
++   }
++   return $now;
++}
++
++#
++# The hash value here is calculated over the prefix key
++# header (excluding HW signatures and SW public keys) and
++# signed by the hardware private keys.
++sub signPrefixKeyHeaderDigest  {
++    my %data = @_;
++    my $digestToSign = $data{digestToSign} || confess "digest required";
++
++    my $rtrc = 0;
++    if ($g_var{verbose}) {
++      print "\n#######################################################\n";
++      print "### -------  Sign prefix key header   -------- ###\n\n";
++    }
++
++    print "digest to sign passed in: $digestToSign\n" if $g_var{verbose};
++
++    # Sign the digest over the prefix key header (excluding HW
++    # signatures and FW public keys) with the three hardware keys.
++    my $hwsignA_tmp = "$g_tmpdir/hwsignA.bin";
++    push(@g_tmpFiles, $hwsignA_tmp);
++
++    my $genRc = generateSignature(digestToSign => $digestToSign,
++                  keyToUse     => $g_var{HWprivKeyA},
++                  sigfile      => $hwsignA_tmp,
++                  verbose      => $g_var{verbose});
++    $rtrc += $genRc;
++    $g_hwsignA = $hwsignA_tmp;
++
++    my $hwsignB_tmp = "$g_tmpdir/hwsignB.bin";
++    $genRc = generateSignature(digestToSign => $digestToSign,
++                   keyToUse     => $g_var{HWprivKeyB},
++                   sigfile      => $hwsignB_tmp,
++                   verbose      => $g_var{verbose});
++    $rtrc += $genRc;
++    $g_hwsignB = $hwsignB_tmp;
++    push(@g_tmpFiles, $hwsignB_tmp);
++
++    my $hwsignC_tmp = "$g_tmpdir/hwsignC.bin";
++    $genRc = generateSignature(digestToSign => $digestToSign,
++                   keyToUse     => $g_var{HWprivKeyC},
++                   sigfile      => $hwsignC_tmp,
++                   verbose      => $g_var{verbose});
++    $rtrc += $genRc;
++    $g_hwsignC = $hwsignC_tmp;
++    push(@g_tmpFiles, $hwsignC_tmp);
++
++    return $rtrc;
++}
++
++
++#
++# The hash value for this routine is calculated over the
++# software header (excluding SW signatures).
++sub signSoftwareHeaderDigest {
++    my %data = @_;
++    my $binaryHash = $data{hashToSign} || confess "hash required";
++
++    if ($g_var{verbose}) {
++      print "\n#############################################\n";
++      print "### --- Sign the software header digest ---- ###\n\n";
++    }
++    # Sign the digest using each of the FW private
++    # keys (up to 3 keys may be specified)
++    my $SWsignP_tmp = "$g_tmpdir/swsignP.bin";
++
++    my $retrc = 0;
++    my $genRc = generateSignature(digestToSign => $binaryHash,
++                  keyToUse     => $g_var{SWprivKeyP},
++                  sigfile      => $SWsignP_tmp,
++                  verbose      => $g_var{verbose});
++    $retrc += $genRc;
++    $g_SWsignP = $SWsignP_tmp;
++    push(@g_tmpFiles, $SWsignP_tmp);
++
++    if ($g_var{SWprivKeyQ}) {
++        my $SWsignQ_tmp = "$g_tmpdir/swsignQ.bin";
++        $genRc = generateSignature(digestToSign => $binaryHash,
++                   keyToUse     => $g_var{SWprivKeyQ},
++                   sigfile      => $SWsignQ_tmp,
++                   verbose      => $g_var{verbose});
++        $retrc += $genRc;
++        $g_SWsignQ = $SWsignQ_tmp;
++        push(@g_tmpFiles, $SWsignQ_tmp);
++    }
++
++    if ($g_var{SWprivKeyR}) {
++        my $SWsignR_tmp = "$g_tmpdir/swsignR.bin";
++        $genRc = generateSignature(digestToSign => $binaryHash,
++                   keyToUse     => $g_var{SWprivKeyR},
++                   sigfile      => $SWsignR_tmp,
++                   verbose      => $g_var{verbose});
++        $retrc += $genRc;
++        $g_SWsignR = $SWsignR_tmp;
++        push(@g_tmpFiles, $SWsignR_tmp);
++    }
++    return $retrc;
++}
++
++
++# Update the hardware public keys and signatures into the
++# hardware header.
++sub HWkeyInfo {
++    if ($g_var{verbose}) {
++      print "\n#########################################################\n";
++      print "### --  Add hardware public key data to container  -- ###\n\n";
++    }
++
++    # Set up the hardware key and signature fields
++    print "Updating the hdw key A \n" if $g_var{verbose};
++    updCont("--fldname hw-keya --fldvalue $g_HWpubKeyA");
++
++    print "Updating the hdw key A signature\n" if $g_var{verbose};
++    updCont("--fldname hw-signa --fldvalue $g_hwsignA");
++
++    print "Updating the hdw key B \n" if $g_var{verbose};
++    updCont("--fldname hw-keyb --fldvalue $g_var{HWpubKeyB}");
++
++    print "Updating the hdw key B signature\n" if $g_var{verbose};
++    updCont("--fldname hw-signb --fldvalue $g_hwsignB");
++
++    print "Updating the hdw key C \n" if $g_var{verbose};
++    updCont("--fldname hw-keyc --fldvalue $g_var{HWpubKeyC}");
++
++    print "Updating the hdw key C signature\n" if $g_var{verbose};
++    updCont("--fldname hw-signc --fldvalue $g_hwsignC");
++
++    return;
++}
++#
++# Update the FW public keys in the container
++sub SWkeys {
++    if ($g_var{verbose}) {
++      print "\n#############################################################\n";
++      print "### -------  Add FW public key data to container  -------- ###\n\n";
++    }
++    my$sw_key_count = 0;
++
++    ## There should always be at least one FW public key - key P
++    print "Updating the FW key P \n" if $g_var{verbose};
++    updCont("--fldname sw-keyp --fldvalue $g_SWpubKeyP");
++    $sw_key_count = 1;
++
++    print "\n$g_var{signed_container_name} first set of fields updated\n" if $g_var{verbose};
++
++    # Now set up the optional fields (the 2nd and 3rd FW public keys)
++    print "\nUpdating the secondary FW public keys and signatures in the container\n" if $g_var{verbose};
++
++    if ($g_var{SWprivKeyQ}) {
++        print "Updating the FW key Q \n" if $g_var{verbose};
++        updCont("--fldname sw-keyq --fldvalue $g_SWpubKeyQ");
++        $sw_key_count++;
++    }
++    if ($g_var{SWprivKeyR}) {
++        print "Updating the FW key R \n" if $g_var{verbose};
++        updCont("--fldname sw-keyr --fldvalue $g_SWpubKeyR");
++        $sw_key_count++;
++    }
++    if ( ($sw_key_count < 1) or ($sw_key_count > 3) ) {
++        return 1, "ERROR: Count of FW public keys must be between 1-3\n";
++    }
++    return 0, "";
++}
++
++#
++# Update the FW signatures in the container
++sub SWsigns {
++    if ($g_var{verbose}) {
++      print "\n#############################################################\n";
++      print "### -------  Update FW signatures into container  -------- ###\n\n";
++    }
++    print "Updating the FW signature P signature\n" if $g_var{verbose};
++    updCont("--fldname sw-signp --fldvalue $g_SWsignP");
++
++    print "\n$g_var{signed_container_name} first set of fields updated\n" if $g_var{verbose};
++
++    # Now set up the optional fields (the 2nd and 3rd FW keys)
++    print "\nUpdating the secondary FW keys and signatures in the container\n" if $g_var{verbose};
++    if ($g_var{SWprivKeyQ}) {
++        print "Updating the FW signature Q data\n" if $g_var{verbose};
++        updCont("--fldname sw-signq --fldvalue $g_SWsignQ");
++    }
++    if ($g_var{SWprivKeyR}) {
++        print "Updating the FW signature R signature\n" if $g_var{verbose};
++        updCont("--fldname sw-signr --fldvalue $g_SWsignR");
++    }
++    return ;
++}
++
++#
++# Concatenate the SFW public keys into one binary blob,
++# get the hash and size and return to caller
++#
++sub prepFWkeyBlob {
++    #
++    #  In the prefix key header, there is a field for hash
++    # of protected payload - that is the digest
++    # generated over the concatenation of the sfw public
++    # keys.
++    my ($plrc, $sfwPubKeysSize, $sfwKeysHash, $sfwHashLen);
++
++    #### In development mode, manually pull out the
++    #### pub: key string from the public key extracted
++    #### from the private key, chop off the first byte,
++    #### dump the rest of the bits back to a file and
++    #### hash that file to get the hash of the sfw keys.
++    my $sprc     = 0;
++    my $tmpPkey = "";
++    # Start with P first, since there should always be
++    # the one key sfw key P
++    $tmpPkey = parseCharPubKeyToGetBinaryFileToHash(
++                 sfwPrivKey  => $g_var{SWprivKeyP} );
++
++    my $concatedKeyStr = $tmpPkey;
++
++    # else we are ok, set up a temp file name, just in case
++    # we have 2 more keys to process
++    my $concatedPubKeyFilesToHash = "$g_tmpdir/concatedSfwKeysToHash";
++    push(@g_tmpFiles, $concatedPubKeyFilesToHash);
++
++    my $tmpQkey = "";
++    if ($g_var{SWprivKeyQ}) {
++        $tmpQkey = parseCharPubKeyToGetBinaryFileToHash(
++                                sfwPrivKey  => $g_var{SWprivKeyQ} );
++        $concatedKeyStr .= $tmpQkey;
++    }
++    my $tmpRkey = "";
++    if ($g_var{SWprivKeyR}) {
++        $tmpRkey = parseCharPubKeyToGetBinaryFileToHash(
++                                sfwPrivKey  => $g_var{SWprivKeyR} );
++
++        $concatedKeyStr .= $tmpRkey;
++    }
++    open(TEMPFILE, ">$concatedPubKeyFilesToHash") or die "Could not open temp file to hold concatenated FW public keys";
++    print TEMPFILE "$concatedKeyStr";
++    close(TEMPFILE) || die "close failed for : $!";;
++    my $concatCmd = "echo $concatedKeyStr > $concatedPubKeyFilesToHash";
++    if ($g_var{verbose}) {
++       print "SFW keys concatenated into: $concatedPubKeyFilesToHash\n";
++    }
++
++    print "Getting hash of file, $concatedPubKeyFilesToHash\n" if $g_var{verbose};
++    ($plrc, $sfwPubKeysSize, $sfwKeysHash, $sfwHashLen) = getSizeAndHash($concatedPubKeyFilesToHash);
++
++    # this call fails - need to use the prior one until the subr
++    # can properly deal with a string vs file
++    # - leaving here for debug for next delivery
++    #print "Getting hash of string, '$concatedKeyStr'\n" if $g_var{verbose};
++    #($plrc, $sfwPubKeysSize, $sfwKeysHash, $sfwHashLen) = getSizeAndHash($concatedKeyStr);
++
++    print "prepFWkeyBlob: Returning sfw public key(s) size: $sfwPubKeysSize\n  hash: $sfwKeysHash\nhash len: $sfwHashLen\n" if $g_var{verbose};
++    return $plrc, $sfwPubKeysSize, $sfwKeysHash, $sfwHashLen;
++}
++
++# Given a FW private key:
++#   dump it as text to a file
++#   parse that text file, looking for the character representation
++#     of the public key (the strings x:y:z... follow 'pub:')
++#   lump all those xyz... values into one char string
++#   strip off the '04' at the start (to get 132 bytes)
++#   convert the resulting string to binary
++#   write it to a file
++#
++# There SHOULD be a better way to do this - via some
++# magic openssl command...but we need to make progress...
++# so need to revisit this once things are working...
++sub parseCharPubKeyToGetBinaryFileToHash {
++    my %data = @_;
++    my $sfwPrivKey = $data{sfwPrivKey}  || confess "FW private key file required";
++
++    my $l_cmd = "openssl ec -in $sfwPrivKey -text";
++    print "\n*** Dump the software private key $sfwPrivKey as text: $l_cmd\n" if $g_var{verbose};
++    my $keyText = `$l_cmd`;
++    if ($?) {
++        die "ERROR: parseCharPubKeyToGetBinaryFileToHash failed on the call to openssl";
++    }
++
++    # Define a second file where we can output the 'hashable'
++    #  public key.
++
++    # parse out the char key string that follows 'pub:' and
++    # dump it to the hashablepubkey var (this will be the
++    # format of the software public key that we need to
++    # hash (or concat and hash) and sign to come up with
++    # the magic signature that matches what the ROM code
++    # will validate against.
++    my $hashAblePubKey = parsePubKeyTextOut($keyText);
++    my $pubKeyLen = length($hashAblePubKey);
++    if ($pubKeyLen > expectedHexPubKeyLen) {
++       die "parseCharPubKeyToGetBinaryFileToHash: ERROR: public key length, $pubKeyLen, is longer than expected";
++    }
++
++    return $hashAblePubKey;
++}
++
++# The container header contains the hardware public keys
++# and software public keys. We need to get these public
++# keys from the private keys that were passed in (in
++# development mode, at least..)
++sub extractPubKey {
++   my %data = @_;
++   my $mode          = $data{mode}    || confess "production or development mode required";
++   my $privKeyFile   = $data{keyfile} || confess "key file required";
++   my $tmpPubKeyFile = $data{outfile} || confess "output file required";
++
++   my $cm = "";
++   if ($mode eq "development") {
++       #####$cm = "openssl rsa -in $privKeyFile -pubout > $tmpPubKeyFile";
++       # this returns something that can be sent to signtool to put into
++       # the container...but the output file is huge
++       $cm = "openssl ec -in $privKeyFile -pubout -out $tmpPubKeyFile";
++
++       my $openssl = `which openssl`;
++       chomp($openssl);
++       print "extractPubKey using $openssl\n" if $g_var{verbose};
++       system($cm);
++       if ($?) {
++         die "$openssl failed \n";
++       } elsif ($g_var{verbose}) {
++        print "public key extracted to $tmpPubKeyFile\n" if $g_var{verbose};
++       }
++   } else {
++       # we need to call the signtool to extract the public
++       # key
++   }
++   return ;
++}
++
++# One subroutine to do all the public key extraction
++# calls in one place
++sub extractPubKeysFromPriv {
++    my %data = @_;
++    my $mode = $data{mode}  || confess "mode is required";
++    my $hwA = $data{hwkeya} || confess "Hardware private key A required";
++    my $hwB = $data{hwkeyb} || confess "Hardware private key B required";
++    my $hwC = $data{hwkeyc} || confess "Hardware private key C required";
++
++    my $swP = $data{swkeyp} || confess "Software private key P required";
++    my $swQ = $data{swkeyq} || "";
++    my $swR = $data{swkeyr} || "";
++
++    # add all possible temp files created in this subr to our
++    # array to clean up
++    push(@g_tmpFiles, "$g_tmpdir/hwpubkeya");
++    push(@g_tmpFiles, "$g_tmpdir/hwpubkeyb");
++    push(@g_tmpFiles, "$g_tmpdir/hwpubkeyc");
++    push(@g_tmpFiles, "$g_tmpdir/swpubkeyp");
++    push(@g_tmpFiles, "$g_tmpdir/swpubkeyq");
++    push(@g_tmpFiles, "$g_tmpdir/swpubkeyr");
++
++    # In development mode, we can use openssl to extract the
++    # public key from the private.
++    extractPubKey(  mode    => $mode,
++                    keyfile => $hwA,
++                    outfile => "$g_tmpdir/hwpubkeya");
++    $g_HWpubKeyA = "$g_tmpdir/hwpubkeya";
++
++    extractPubKey(  mode    => $mode,
++                    keyfile => $hwB,
++                    outfile => "$g_tmpdir/hwpubkeyb");
++    $g_var{HWpubKeyB} = "$g_tmpdir/hwpubkeyb";
++
++    extractPubKey(  mode    => $mode,
++                    keyfile => $hwC,
++                    outfile => "$g_tmpdir/hwpubkeyc");
++    $g_var{HWpubKeyC} = "$g_tmpdir/hwpubkeyc";
++
++    extractPubKey(  mode    => $mode,
++                    keyfile => $swP,
++                    outfile => "$g_tmpdir/swpubkeyp");
++    $g_SWpubKeyP = "$g_tmpdir/swpubkeyp";
++
++    if ($g_var{SWprivKeyQ}) {
++        extractPubKey(  mode    => $mode,
++                        keyfile => $swQ,
++                        outfile => "$g_tmpdir/swpubkeyq");
++        $g_SWpubKeyQ = "$g_tmpdir/swpubkeyq";
++    }
++    if ($g_var{SWprivKeyR}) {
++        extractPubKey(  mode    => $mode,
++                        keyfile => $swR,
++                        outfile => "$g_tmpdir/swpubkeyr");
++                        $g_SWpubKeyR = "$g_tmpdir/swpubkeyr";
++    }
++    return ;
++}
++
++# To create a full signed container, the binary that we
++# just signed should be appended to the end of the headers.
++sub attachBinaryToContainer {
++    my %data = @_;
++    my $tmpFinalContainer = $data{outfile}        || confess "output file required";
++    my $protected_bin     = $data{protected}      || confess "protected binary required";
++    my $finalCont         = $data{finalContainer} || confess "final signed container path required";
++    my $unprotected       = $data{unprotected}    || "";
++    my $createFinal       = $data{createFinal}    || 0;
++
++    my ($prc, $containerSize, $containerHash) = getSizeAndHash($finalCont);
++    print "before attaching binary to the end of the container, the container size of $finalCont was $containerSize\n" if $g_var{verbose};
++
++    print "\nAttaching the protected payload, $protected_bin, (and if specified, the unprotected binary, $unprotected) to the end of the container to create a temp file, $tmpFinalContainer\n" if $g_var{verbose};
++    $g_CMD = "cat $finalCont $protected_bin > $tmpFinalContainer";
++    if ($unprotected) {
++       $g_CMD = "cat $finalCont $protected_bin $unprotected > $tmpFinalContainer";
++    }
++    system($g_CMD);
++    if ($?) {
++       die "$g_CMD failed";
++    }
++    if ($createFinal) {
++        print "\nNow copy the temp file ($tmpFinalContainer) to the final signed container name ($finalCont)\n" if $g_var{verbose};
++        $g_CMD = "cp $tmpFinalContainer $finalCont";
++        system($g_CMD);
++	if ($?) {
++          die "$g_CMD failed. Unable to construct the final container\n";
++        }
++    }
++}
++
++#
++# Pass in a parameter file, formatted as:
++#   varname(splitchars)value
++# as in:
++# HWprivKeyA~~<file path>
++#
++sub parseParmFile {
++  my %data = @_;
++  my $parmfile   = $data{parmfile}   || confess "parmfile required";
++  my $splitchars = $data{splitchars} || "~~";
++  my $verbose    = $data{verbose}    || 0;
++
++  open(PARMFILE, "$parmfile") || die "Unable to open parameter file,  $parmfile";
++  my @parmlines = <PARMFILE>;
++  close(PARMFILE) || die "close failed for : $!";
++  print "Found $#parmlines in $parmfile\n" if $verbose;
++
++  foreach my $line (@parmlines) {
++    if (($line !~ /$splitchars/) || ($line =~ /^#/)) { next; }
++    chomp($line);
++    my ($key, $value) = split($splitchars, $line);
++    if (!$value) { next; }
++    if (!$g_var{$key}) {
++       $g_var{$key} = $value;
++    }
++  }
++  return ;
++}
++
++sub parsePubKeyTextOut {
++   my $keyTextVar = shift;
++
++   my $foundPubLine = 0;
++   my @lines = split('\n', $keyTextVar);
++   my $fullstring = "";
++   print "parsePubKeyTextOut: parse the public key from the dump of the private, concat the strings we find to make one big string\n" if $g_var{verbose};
++   foreach my $l (@lines) {
++       chomp($l);
++       if (!$l) { next; }
++       if ($l =~ /pub:/) {
++            $foundPubLine = 1;
++            next;
++       } elsif ($l =~ /Field Type:/) {
++            last;
++       } elsif ($l =~ /ASN1/) {
++            last;
++
++       } elsif ($foundPubLine) {
++           # else we are reading the output of the key dump
++           # need to get the binary forms of each
++            $l =~ s%:%%g;
++            $l =~ s% %%g;
++            $fullstring .= $l;
++       }
++   }
++   # strip off the first 2 chars ('04')
++   my $len = length($fullstring) - 1;
++   $fullstring = substr($fullstring, 2, $len);
++   print "parsePubKeyTextOut: converting my new string with the first 04 string stripped off ($fullstring) to binary\n" if $g_var{verbose};
++   my $binaryPublicKey = pack ("H*",$fullstring);
++
++   return $binaryPublicKey;
++
++}
++
++sub valPubKeyLen {
++    my $inkeyfile = shift;
++    my $instring = `cat $inkeyfile`;
++    if ($?) {
++       die "Unable to read/process $inkeyfile";
++    }
++    $instring =~ s%-----BEGIN PUBLIC KEY-----%%;
++    $instring =~ s%-----END PUBLIC KEY-----%%;
++
++    my $expectedLen = asciiCharPerHexByte * expectedHexPubKeyLen;
++    my $actualLen = length($instring);
++    if ($actualLen != $expectedLen) {
++        die "ERROR: valPubKeyLen expected a key length of $expectedLen. Actual length is $actualLen";
++    }
++
++}
++
++
++__END__
++
++=head1 NAME
++
++crtSignedContainer.pl
++
++=head1 SYNOPSIS
++
++crtSignedContainer.pl [options]
++
++=head1 OPTIONS
++
++=over 8
++
++=item B<--help>
++
++Print a brief help message and exits.
++
++=item B<--man>
++
++Prints the manual page and exits.
++
++
++
++
++=item B<--createKey>
++
++Create a FW key pair (using openssl)
++
++=item B<--privKeyPath>
++
++Fully-qualified path to file to contain private key
++
++=item B<--pubKeyPath>
++
++Fully-qualified path to file to contain public key
++
++
++
++=item B<--protectedPayload>
++
++Binary blob to be signed
++
++
++=item B<--out>
++
++Path to signed container to be created
++
++=item B<--hwPrivKeyA>
++
++Hardware private key A (required)
++
++=item B<--hwPrivKeyB>
++
++Hardware private key B (required)
++
++=item B<--hwPrivKeyC>
++
++Hardware private key C (required)
++
++=item B<--swPrivKeyP>
++
++FW private key P (required)
++
++
++=item B<--update>
++
++Update the existing container
++
++=item B<--mode>
++
++development or production
++   (Only development mode supported initially)
++
++=item B<--paramFile>=FILE
++
++File containing a list of parameter values
++
++=item B<--swPrivKeyQ>
++
++Software private key Q
++
++=item B<--swPrivKeyR>
++
++Software private key R
++
++=item B<--flags_fw_key_ind>
++
++Flags (firmware key indicator - prefix key header)
++  hex, formatted like 0x00000000
++
++
++=item B<--code-start-offset>
++
++Code start offset (software header)
++  hex, formatted like 0x0000000000000000
++
++=item B<--cont-size>
++
++Total size of the container
++  hex, formatted like 0x0000000000000000
++
++=item B<--target-HRMOR>
++
++Target HRMOR
++  hex, formatted like 0x0000000000000000
++
++=item B<--inst-start>
++
++Instruction start stack pointer address
++  hex, formatted like 0x0000000000000000
++
++=item B<--unprotectedPayload>
++
++File containing the unprotected payload
++
++=item B<--noattach>
++
++Do NOT attach the -protectedPayload <binary>
++  (and optional -unprotectedPayload <binary>)
++  to the end of the signed container
++
++
++=item B<--tempdir>=DIRECTORY
++
++Temporary workspace used only when signing a
++  binary (files in this directory will not
++  be removed upon exit).
++
++
++=item B<--verbose>
++
++Prints out details of internal workings
++
++=back
++
++=head1 DESCRIPTION
++
++B<crtSignedContainer.pl> will allow the caller to do all
++of the following in just one call:
++
++- create a valid FW key pair via openssl
++
++ OR
++- create an empty container prefix header with defaults
++  filled in
++- get a hash of the binary to be signed for inclusion
++  in the appropriate prefix key or firmware header
++- concatenate the FW public key(s) and get a hash of
++  the resulting file
++- sign the hash of the prefix key header (which includes
++  the hash of the firmware (FW) public keys) using
++  each of the hardware private keys (to generate the
++  3 hardware signatures)
++- sign the hash of the protected payload (such as
++  hostboot.bin) using each of the 1-3 FW
++  private keys (to generate the 1-3 FW signatures)
++- update the hardware header with the hardware
++  public keys
++- update the prefix key header with the FW keys
++  and hardware signatures
++- update the software header with the FW signature(s)
++- attach the protected payload (if desired), producing
++  a signed container object
++- update other fields in the headers, such as final
++  container size, target HRMOR, code start offset,
++  etc
++- attach the unprotected payload (if provided)
++
++The sign 'utility' has parms for the field 'name' and
++the associated value to be inserted into the binary. So,
++for the multiple field/value combinations that must be
++updated into the final signed container, it must be
++called multiple times (once for each of the HW keys
++and associated signatures, once for each of the SFW
++keys and associated signatures, etc).
++
++As part of the container, there are headers that consist
++of 3 Hardware public Keys
++      * HW-KeyA - Hardware Public Key A
++      * HW-KeyB - Hardware Public Key B
++      * HW-KeyC - Hardware Public Key C
++3 corresponding Hardware Signatures
++      * HW-SigA - Hardware Signature A
++      * HW-SigB - Hardware Signature B
++      * HW-SigC - Hardware Signature C
++
++and 1 to 3 FW Keys (the number of keys used/required
++depends on the settings for each 'project')
++      * SW-KeyP - FW Public Key P
++      * SW-KeyQ - FW Public Key Q
++      * SW-KeyR - FW Public Key R
++and the associated Software Signatures
++      * SW-SigP - FW Signature P
++      * SW-SigQ - FW Signature Q
++      * SW-SigR - FW Signature R
++
++The protected payload (the actual signed binary
++'blob') is (optionally) appended to the container.
++Same is true for the unprotected payload.
++
++=cut
+diff --git a/src/Makefile.am b/src/Makefile.am
+new file mode 100755
+index 0000000..eed13da
+--- /dev/null
++++ b/src/Makefile.am
+@@ -0,0 +1,26 @@
++# IBM_PROLOG_BEGIN_TAG
++# This is an automatically generated prolog.
++#
++# $Source: src/Makefile.am $
++#
++# OpenPOWER sb-signing-utils Project
++#
++# Contributors Listed Below - COPYRIGHT 2016
++# [+] International Business Machines Corp.
++#
++#
++# Licensed under the Apache License, Version 2.0 (the "License");
++# you may not use this file except in compliance with the License.
++# You may obtain a copy of the License at
++#
++#     http://www.apache.org/licenses/LICENSE-2.0
++#
++# Unless required by applicable law or agreed to in writing, software
++# distributed under the License is distributed on an "AS IS" BASIS,
++# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
++# implied. See the License for the specific language governing
++# permissions and limitations under the License.
++#
++# IBM_PROLOG_END_TAG
++
++SUBDIRS = signtool
+diff --git a/src/signtool/IBM_Container.cpp b/src/signtool/IBM_Container.cpp
+new file mode 100644
+index 0000000..efa1c45
+--- /dev/null
++++ b/src/signtool/IBM_Container.cpp
+@@ -0,0 +1,1767 @@
++/* IBM_PROLOG_BEGIN_TAG                                                   */
++/* This is an automatically generated prolog.                             */
++/*                                                                        */
++/* $Source: src/signtool/IBM_Container.cpp $                              */
++/*                                                                        */
++/* OpenPOWER sb-signing-utils Project                                     */
++/*                                                                        */
++/* Contributors Listed Below - COPYRIGHT 2016                             */
++/* [+] International Business Machines Corp.                              */
++/*                                                                        */
++/*                                                                        */
++/* Licensed under the Apache License, Version 2.0 (the "License");        */
++/* you may not use this file except in compliance with the License.       */
++/* You may obtain a copy of the License at                                */
++/*                                                                        */
++/*     http://www.apache.org/licenses/LICENSE-2.0                         */
++/*                                                                        */
++/* Unless required by applicable law or agreed to in writing, software    */
++/* distributed under the License is distributed on an "AS IS" BASIS,      */
++/* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or        */
++/* implied. See the License for the specific language governing           */
++/* permissions and limitations under the License.                         */
++/*                                                                        */
++/* IBM_PROLOG_END_TAG                                                     */
++
++#include <string.h>
++#include <stddef.h>
++
++#include <endian.h>
++
++#include <sstream>
++#include <fstream>
++#include <iostream>
++#include <algorithm>
++
++#include "IBM_Crypto.h"
++#include "IBM_Exception.h"
++#include "IBM_HexString.h"
++#include "IBM_Container.h"
++#include "IBM_Utils.h"
++
++namespace
++{
++    const static uint32_t g_COL_WIDTH = 24;
++
++    const static uint32_t g_UNCOMPRESSED_PUBKEY_FORMAT = 0x04;
++
++    const static std::string g_HASH_ALGO_SHA512_NAME   = "SHA-512";
++    const static std::string g_SIGN_ALGO_ECDSA521_NAME = "ECDSA521";
++
++    template<typename T_PAIR>
++    struct GetKey: public std::unary_function<T_PAIR, typename T_PAIR::first_type>
++    {
++        const typename T_PAIR::first_type& operator()(const T_PAIR& item) const
++        {
++            return item.first;
++        }
++    };
++
++    uint16_t getUint16( const uint8_t *data )
++    {
++        uint16_t value = 0;
++
++        value = data[1] | (data[0] << 8);
++
++        return value;
++    }
++
++    uint32_t getUint32( const uint8_t *data )
++    {
++        uint32_t value = 0;
++
++        value = (data[3] | (data[2] << 8) | (data[1] << 16) | (data[0] << 24));
++
++        return value;
++    }
++
++    uint64_t getUint64( const uint8_t *data )
++    {
++        uint64_t value = 0;
++
++        value = (            data[7]        | ((uint16_t)data[6] << 8)  | 
++                  ((uint32_t)data[5] << 16) | ((uint32_t)data[4] << 24) |
++                  ((uint64_t)data[3] << 32) | ((uint64_t)data[2] << 40) |
++                  ((uint64_t)data[1] << 48) | ((uint64_t)data[0] << 56) );
++
++        return value;
++    }
++
++    void printHexBytes( const uint8_t* bytes, size_t size, size_t leadSpace )
++    {
++        std::vector<uint8_t> byteArray;
++
++        byteArray.assign(bytes, bytes+size);
++
++        IBM_HexString hStr( byteArray );
++
++        hStr.setWidth(36);
++        hStr.setLeadSpace(leadSpace);
++
++        std::cout << hStr;
++    }
++
++  
++    const char* GetHashAlgoName( int p_hashAlgoNum )
++    {
++        static std::map<int, std::string> s_hashAlgoNames;
++
++        if (s_hashAlgoNames.empty() == 0)
++        {
++            s_hashAlgoNames[HASH_ALG_SHA512] = g_HASH_ALGO_SHA512_NAME;
++        }
++
++        std::string hashAlgoName = "Unknown";
++
++        std::map<int, std::string>::const_iterator itr = s_hashAlgoNames.find(p_hashAlgoNum);
++        if (itr != s_hashAlgoNames.end())
++        {
++            hashAlgoName = itr->second.c_str();
++        }
++
++        return hashAlgoName.c_str();
++    };
++
++  
++    const char* GetSignAlgoName( int p_signAlgoNum )
++    {
++        static std::map<int, std::string> s_signAlgoNames;
++
++        if (s_signAlgoNames.empty() == 0)
++        {
++            s_signAlgoNames[SIG_ALG_ECDSA521] = g_SIGN_ALGO_ECDSA521_NAME;
++        }
++
++        std::string signAlgoName = "Unknown";
++
++        std::map<int, std::string>::const_iterator itr = s_signAlgoNames.find((int) p_signAlgoNum);
++        if (itr != s_signAlgoNames.end())
++        {
++            signAlgoName = itr->second.c_str();
++        }
++
++        return signAlgoName.c_str();
++    };
++
++    
++    void ReadPublicKeyFromFile( const std::string&    p_mode,
++                                const std::string&    p_keyFileName,
++                                std::vector<uint8_t>& p_buffer )
++    {
++        IBM_Utils* pUtils = IBM_Utils::get();
++        THROW_EXCEPTION(pUtils == NULL);
++
++        if (p_mode == IBM_Utils::g_MODE_PRODUCTION)
++        {
++            pUtils->ReadFromFile( p_keyFileName,
++                                  p_buffer,
++                                  ECDSA521_KEY_SIZE + 1 ); // since keyfile is 133 bytes with 0x04
++                                                           // at the begining
++
++            if (p_buffer[0] != g_UNCOMPRESSED_PUBKEY_FORMAT)
++            {
++                std::stringstream ss;
++                ss << "File <" 
++                   << p_keyFileName 
++                   << "> is not a vaid p521 public key file"
++                   << std::endl;
++
++                THROW_EXCEPTION_STR(ss.str().c_str());
++            }
++            
++            // public key file OK, delete the first byte
++            p_buffer.erase( p_buffer.begin() );
++        }
++        else if (p_mode == IBM_Utils::g_MODE_DEVELOPMENT)
++        {
++            pUtils->GetPublicKeyBytes( p_keyFileName.c_str(), p_buffer );
++        }
++        else
++        {
++            // should never get here
++            std::stringstream ss;
++            ss << "mode <" << p_mode << "> is not supported, must be one of "
++               << IBM_Utils::g_MODE_PRODUCTION << " or " << IBM_Utils::g_MODE_DEVELOPMENT;
++
++            THROW_EXCEPTION_STR(ss.str().c_str());
++        }
++
++        THROW_EXCEPTION(p_buffer.size() != ECDSA521_KEY_SIZE);
++    }
++
++
++    void ReadSignatureFromFile( const std::string&    p_mode,
++                                const std::string&    p_sigFileName,
++                                std::vector<uint8_t>& p_buffer )
++    {
++        IBM_Utils* pUtils = IBM_Utils::get();
++        THROW_EXCEPTION(pUtils == NULL);
++
++        if (p_mode == IBM_Utils::g_MODE_PRODUCTION)
++        {
++            pUtils->ReadFromFile( p_sigFileName, p_buffer, ECDSA521_SIG_SIZE );
++        }
++        else if (p_mode == IBM_Utils::g_MODE_DEVELOPMENT)
++        {
++            pUtils->GetSignatureBytes( p_sigFileName.c_str(), p_buffer );
++        }
++        else
++        {
++            // should never get here
++            std::stringstream ss;
++            ss << "mode <" << p_mode << "> is not supported, must be one of "
++               << IBM_Utils::g_MODE_PRODUCTION << " or " << IBM_Utils::g_MODE_DEVELOPMENT;
++
++            THROW_EXCEPTION_STR(ss.str().c_str());
++        } 
++
++        THROW_EXCEPTION(p_buffer.size() != ECDSA521_SIG_SIZE);
++    } 
++}
++
++
++
++// ContainerHdr C'tor
++ContainerHdr::ContainerHdr()
++   : m_magicNumber( ROM_MAGIC_NUMBER ),
++     m_version( CONTAINER_VERSION ),
++     m_containerSize(0),
++     m_targetHrmor(0),
++     m_stackPointer(0),
++     m_hwPkeyA(),
++     m_hwPkeyB(),
++     m_hwPkeyC()
++{
++}
++
++
++/**
++ * @brief   Get the Container Header message as a byte stream
++ *
++ * @param[out]  packet  -  A reference to a vector of type uint8_t
++ */
++void ContainerHdr::GetHeaderBytes( std::vector<uint8_t>& packet ) const
++{
++    packet.clear();
++
++    // insert the magic nummber field
++    packet.push_back((m_magicNumber >> 24) & 0xFF);
++    packet.push_back((m_magicNumber >> 16) & 0xFF);
++    packet.push_back((m_magicNumber >> 8) & 0xFF);
++    packet.push_back(m_magicNumber & 0xFF);
++
++    // insert the version field
++    packet.push_back((m_version >> 8) & 0xFF);
++    packet.push_back(m_version & 0xFF);
++
++    // insert the container size field
++    packet.push_back((m_containerSize >> 56) & 0xFF);
++    packet.push_back((m_containerSize >> 48) & 0xFF);
++    packet.push_back((m_containerSize >> 40) & 0xFF);
++    packet.push_back((m_containerSize >> 32) & 0xFF);
++    packet.push_back((m_containerSize >> 24) & 0xFF);
++    packet.push_back((m_containerSize >> 16) & 0xFF);
++    packet.push_back((m_containerSize >> 8) & 0xFF);
++    packet.push_back(m_containerSize & 0xFF);
++
++    // insert the target Hrmor field
++    packet.push_back((m_targetHrmor >> 56) & 0xFF);
++    packet.push_back((m_targetHrmor >> 48) & 0xFF);
++    packet.push_back((m_targetHrmor >> 40) & 0xFF);
++    packet.push_back((m_targetHrmor >> 32) & 0xFF);
++    packet.push_back((m_targetHrmor >> 24) & 0xFF);
++    packet.push_back((m_targetHrmor >> 16) & 0xFF);
++    packet.push_back((m_targetHrmor >> 8) & 0xFF);
++    packet.push_back(m_targetHrmor & 0xFF);
++    
++    // insert the stack Pointer field
++    packet.push_back((m_stackPointer >> 56) & 0xFF);
++    packet.push_back((m_stackPointer >> 48) & 0xFF);
++    packet.push_back((m_stackPointer >> 40) & 0xFF);
++    packet.push_back((m_stackPointer >> 32) & 0xFF);
++    packet.push_back((m_stackPointer >> 24) & 0xFF);
++    packet.push_back((m_stackPointer >> 16) & 0xFF);
++    packet.push_back((m_stackPointer >> 8) & 0xFF);
++    packet.push_back(m_stackPointer & 0xFF);
++    
++    // insert the HW Public Key-A field
++    packet.insert( packet.end(),
++                   m_hwPkeyA,
++                   (m_hwPkeyA + sizeof(m_hwPkeyA)) );
++    
++    // insert the HW Public Key-B field
++    packet.insert( packet.end(),
++                   m_hwPkeyB,
++                   (m_hwPkeyB + sizeof(m_hwPkeyB)) );
++    
++    // insert the HW Public Key-C field
++    packet.insert( packet.end(),
++                   m_hwPkeyC,
++                   (m_hwPkeyC + sizeof(m_hwPkeyC)) );
++}
++
++
++/**
++ *  @brief   print the Container Header
++ */
++void ContainerHdr::PrintHeader() const
++{
++    std::cout << "-----------------------------------------------------------------"
++              << std::endl
++              << " Container Header"
++              << std::endl
++              << "-----------------------------------------------------------------"
++              << std::endl
++              << "   m_magicNumber      = " << std::hex << std::setfill('0') << std::setw(8) << m_magicNumber
++              << std::endl
++              << "   m_version          = " << std::hex << std::setfill('0') << std::setw(4) << m_version
++              << std::endl;
++
++    std::cout << "   m_containerSize    = " << std::hex << std::setfill('0') << std::setw(16) << m_containerSize
++              << std::endl;
++
++    std::cout << "   m_targetHrmor      = " << std::hex << std::setfill('0') << std::setw(16) << m_targetHrmor
++              << std::endl;
++
++    std::cout << "   m_stackPointer     = " << std::hex << std::setfill('0') << std::setw(16) << m_stackPointer
++              << std::endl;
++
++    std::cout << "   m_hwPkeyA          = ";
++    printHexBytes( m_hwPkeyA, ECDSA521_KEY_SIZE, g_COL_WIDTH );
++
++    std::cout << "   m_hwPkeyB          = ";
++    printHexBytes( m_hwPkeyB, ECDSA521_KEY_SIZE, g_COL_WIDTH );
++
++    std::cout << "   m_hwPkeyC          = ";
++    printHexBytes( m_hwPkeyC, ECDSA521_KEY_SIZE, g_COL_WIDTH );
++    std::cout << std::endl;
++}
++
++
++// PrefixHdr C'tor
++PrefixHdr::PrefixHdr()
++   : m_version( HEADER_VERSION ),
++     m_hashAlg( HASH_ALG_SHA512 ),
++     m_sigAlg( SIG_ALG_ECDSA521 ),
++     m_codeStartOffset(0),
++     m_reserved(),
++     m_flags( 0 ),
++     m_swKeyCount( 0 ),
++     m_payloadSize(0),
++     m_payloadHash(),
++     m_ecidCount( 0 ),
++     m_ecid()
++{
++}
++
++
++/**
++ * @brief   Get the Prefix Header message as a byte stream
++ *
++ * @param[out]  packet  -  A reference to a vector of type uint8_t
++ */
++void PrefixHdr::GetHeaderBytes( std::vector<uint8_t>& packet ) const
++{
++    packet.clear();
++
++    // insert the version field
++    packet.push_back( (m_version >> 8) & 0xFF );
++    packet.push_back( m_version & 0xFF );
++
++    // insert the hash algorithm field
++    packet.push_back( m_hashAlg );
++
++    // insert the signature algorithm field
++    packet.push_back( m_sigAlg );
++
++    // insert the code start offset field
++    packet.push_back((m_codeStartOffset >> 56) & 0xFF);
++    packet.push_back((m_codeStartOffset >> 48) & 0xFF);
++    packet.push_back((m_codeStartOffset >> 40) & 0xFF);
++    packet.push_back((m_codeStartOffset >> 32) & 0xFF);
++    packet.push_back((m_codeStartOffset >> 24) & 0xFF);
++    packet.push_back((m_codeStartOffset >> 16) & 0xFF);
++    packet.push_back((m_codeStartOffset >> 8) & 0xFF);
++    packet.push_back(m_codeStartOffset & 0xFF);
++    
++    // insert the reserved bytes field
++    packet.insert( packet.end(), 
++                   m_reserved,
++                   (m_reserved + sizeof(m_reserved)) );
++    
++    // insert the flags field
++    packet.push_back((m_flags >> 24) & 0xFF );
++    packet.push_back((m_flags >> 16) & 0xFF );
++    packet.push_back((m_flags >> 8) & 0xFF );
++    packet.push_back(m_flags & 0xFF );
++
++    // insert the sw key count field
++    packet.push_back(m_swKeyCount);
++
++    // insert the payload size field
++    packet.push_back((m_payloadSize >> 56) & 0xFF);
++    packet.push_back((m_payloadSize >> 48) & 0xFF);
++    packet.push_back((m_payloadSize >> 40) & 0xFF);
++    packet.push_back((m_payloadSize >> 32) & 0xFF);
++    packet.push_back((m_payloadSize >> 24) & 0xFF);
++    packet.push_back((m_payloadSize >> 16) & 0xFF);
++    packet.push_back((m_payloadSize >> 8) & 0xFF);
++    packet.push_back(m_payloadSize & 0xFF);
++    
++    // insert the payload hash field
++    packet.insert( packet.end(),
++                   m_payloadHash,
++                   (m_payloadHash + sizeof(m_payloadHash)) );
++    
++    // insert the ECID count field
++    packet.push_back( m_ecidCount );
++
++    // insert ECID data if exists
++    if (m_ecidCount > 0)
++    {
++        packet.insert( packet.end(),
++                       m_ecid,
++                       (m_ecid + sizeof(m_ecid)) );
++    }
++}
++
++
++
++/**
++ *  @brief   print the Prefix Header
++ */
++void PrefixHdr::PrintHeader() const
++{
++    std::cout << "-----------------------------------------------------------------"
++              << std::endl
++              << " Prefix Header"
++              << std::endl
++              << "-----------------------------------------------------------------"
++              << std::endl
++              << "   m_version          = " << std::hex << std::setfill('0') << std::setw(4) << m_version
++              << std::endl
++              << "   m_hashAlg          = " << GetHashAlgoName( (int) m_hashAlg )
++              << std::endl
++              << "   m_sigAlg           = " << GetSignAlgoName( (int) m_sigAlg )
++              << std::endl;
++
++    std::cout << "   m_codeStartOffset  = " << std::hex << std::setfill('0') << std::setw(16) << m_codeStartOffset
++              << std::endl;
++
++    std::cout << "   m_reserved         = ";
++    printHexBytes( m_reserved, 8, g_COL_WIDTH );
++
++    std::cout << "   m_flags            = " << std::hex << std::setfill('0') << std::setw(8) << m_flags
++              << std::endl
++              << "   m_swKeyCount       = " << (int) m_swKeyCount
++              << std::endl;
++
++    std::cout << "   m_payloadSize      = " << std::hex << std::setfill('0') << std::setw(16) << m_payloadSize
++              << std::endl;
++
++    std::cout << "   m_payloadHash      = ";
++    printHexBytes( m_payloadHash, SHA512_DIGEST_SIZE, g_COL_WIDTH );
++
++    std::cout << "   m_ecidCount        = " <<  (int) m_ecidCount
++              << std::endl;
++
++    for (int j = 0; j < m_ecidCount; j++)
++    {
++        std::cout << "   m_ecid[" << j << "]         = ";
++        printHexBytes( (const uint8_t *) &m_ecid[(j*ECID_SIZE)], ECID_SIZE, 24 );
++    }
++    std::cout << std::endl;
++}
++
++
++// PrefixData C'tor
++PrefixData::PrefixData()
++   : m_hwSigA(),
++     m_hwSigB(),
++     m_hwSigC(),
++     m_swPkeyP(),
++     m_swPkeyQ(),
++     m_swPkeyR()
++{
++}
++
++
++/**
++ * @brief   Get the Prefix Data Header message as a byte stream
++ *
++ * @param[out]  packet  -  A reference to a vector of type uint8_t
++ */
++void PrefixData::GetHeaderBytes( std::vector<uint8_t>& packet ) const
++{
++    packet.clear();
++
++    // insert the HW Signature-A field
++    packet.insert( packet.end(),
++                   m_hwSigA,
++                   (m_hwSigA + sizeof(m_hwSigA)) );
++    
++    // insert the HW Signature-B field
++    packet.insert( packet.end(),
++                   m_hwSigB,
++                   (m_hwSigB + sizeof(m_hwSigB)) );
++    
++    // insert the HW Signature-C field
++    packet.insert( packet.end(),
++                   m_hwSigC,
++                   (m_hwSigC + sizeof(m_hwSigC)) );
++
++    uint8_t zeroKey[ECDSA521_KEY_SIZE];
++    memset( zeroKey, 0, ECDSA521_KEY_SIZE );
++
++    // insert the SW Public Key-P field only if its valid
++    if (memcmp( m_swPkeyP, zeroKey, ECDSA521_KEY_SIZE) != 0)
++    {
++        packet.insert( packet.end(),
++                       m_swPkeyP,
++                       (m_swPkeyP + sizeof(m_swPkeyP)) );
++    }
++    
++    // insert the SW Public Key-Q field only if its valid
++    if (memcmp( m_swPkeyQ, zeroKey, ECDSA521_KEY_SIZE) != 0)
++    {
++        packet.insert( packet.end(),
++                       m_swPkeyQ,
++                       (m_swPkeyQ + sizeof(m_swPkeyQ)) );
++    }
++    
++    // insert the SW Public Key-R field only if its valid
++    if (memcmp( m_swPkeyR, zeroKey, ECDSA521_KEY_SIZE) != 0)
++    {
++        packet.insert( packet.end(),
++                       m_swPkeyR,
++                       (m_swPkeyR + sizeof(m_swPkeyR)) );
++    }
++}
++
++
++
++/**
++ *  @brief   print the Prefix Data
++ */
++void PrefixData::PrintHeader() const
++{
++    std::cout << "-----------------------------------------------------------------"
++              << std::endl
++              << " Prefix Data"
++              << std::endl
++              << "-----------------------------------------------------------------"
++              << std::endl;
++
++    std::cout << "   m_hwSigA           = ";
++    printHexBytes( m_hwSigA, ECDSA521_SIG_SIZE, g_COL_WIDTH );
++
++    std::cout << "   m_hwSigB           = ";
++    printHexBytes( m_hwSigB, ECDSA521_SIG_SIZE, g_COL_WIDTH );
++
++    std::cout << "   m_hwSigC           = ";
++    printHexBytes( m_hwSigC, ECDSA521_SIG_SIZE, g_COL_WIDTH );
++
++    std::cout << "   m_swPkeyP          = ";
++    printHexBytes( m_swPkeyP, ECDSA521_KEY_SIZE, g_COL_WIDTH );
++
++    std::cout << "   m_swPkeyQ          = ";
++    printHexBytes( m_swPkeyQ, ECDSA521_KEY_SIZE, g_COL_WIDTH );
++
++    std::cout << "   m_swPkeyR          = ";
++    printHexBytes( m_swPkeyR, ECDSA521_KEY_SIZE, g_COL_WIDTH );
++    std::cout << std::endl;
++}
++
++
++/**
++ *  @brief   Get Number of valid Software keys
++ */
++int PrefixData::GetSwKeyCount() const
++{
++    int swKeyCount = 0; 
++
++    uint8_t zeroKey[ECDSA521_KEY_SIZE];
++    memset( zeroKey, 0, ECDSA521_KEY_SIZE );
++
++    if (memcmp( m_swPkeyP, zeroKey, ECDSA521_KEY_SIZE) != 0)
++    {
++        ++swKeyCount;
++    }
++
++    if (memcmp( m_swPkeyQ, zeroKey, ECDSA521_KEY_SIZE) != 0)
++    {
++        ++swKeyCount;
++    }
++
++    if (memcmp( m_swPkeyR, zeroKey, ECDSA521_KEY_SIZE) != 0)
++    {
++        ++swKeyCount;
++    }
++
++    return swKeyCount;
++}
++
++
++
++// SoftwareHdr C'tor
++SoftwareHdr::SoftwareHdr()
++   : m_version( HEADER_VERSION ),
++     m_hashAlg( HASH_ALG_SHA512 ),
++     m_unused( 0 ),
++     m_codeStartOffset(),
++     m_reserved(),
++     m_flags( 0 ),
++     m_reserved0( 0 ),
++     m_payloadSize(),
++     m_payloadHash(),
++     m_ecidCount( 0 ),
++     m_ecid()
++{
++}
++
++
++/**
++ * @brief   Get the Software Header message as a byte stream
++ *
++ * @param[out]  packet  -  A reference to a vector of type uint8_t
++ */
++void SoftwareHdr::GetHeaderBytes( std::vector<uint8_t>& packet ) const
++{
++    packet.clear();
++
++    // insert the version field
++    packet.push_back((m_version >> 8) & 0xFF );
++    packet.push_back(m_version & 0xFF );
++
++    // insert the hash algorithm field
++    packet.push_back( m_hashAlg );
++
++    // insert the unused field
++    packet.push_back( m_unused );
++
++    // insert the code start offset field
++    packet.push_back((m_codeStartOffset >> 56) & 0xFF);
++    packet.push_back((m_codeStartOffset >> 48) & 0xFF);
++    packet.push_back((m_codeStartOffset >> 40) & 0xFF);
++    packet.push_back((m_codeStartOffset >> 32) & 0xFF);
++    packet.push_back((m_codeStartOffset >> 24) & 0xFF);
++    packet.push_back((m_codeStartOffset >> 16) & 0xFF);
++    packet.push_back((m_codeStartOffset >> 8) & 0xFF);
++    packet.push_back(m_codeStartOffset & 0xFF);
++    
++    // insert the reserved bytes field
++    packet.insert( packet.end(), 
++                   m_reserved,
++                   (m_reserved + sizeof(m_reserved)) );
++    
++    // insert the flags field
++    packet.push_back((m_flags >> 24) & 0xFF );
++    packet.push_back((m_flags >> 16) & 0xFF );
++    packet.push_back((m_flags >> 8) & 0xFF );
++    packet.push_back(m_flags & 0xFF );
++
++    // insert the reserved0 field
++    packet.push_back(m_reserved0);
++
++    // insert the payload size field
++    packet.push_back((m_payloadSize >> 56) & 0xFF);
++    packet.push_back((m_payloadSize >> 48) & 0xFF);
++    packet.push_back((m_payloadSize >> 40) & 0xFF);
++    packet.push_back((m_payloadSize >> 32) & 0xFF);
++    packet.push_back((m_payloadSize >> 24) & 0xFF);
++    packet.push_back((m_payloadSize >> 16) & 0xFF);
++    packet.push_back((m_payloadSize >> 8) & 0xFF);
++    packet.push_back(m_payloadSize & 0xFF);
++    
++    // insert the payload hash field
++    packet.insert( packet.end(),
++                   m_payloadHash,
++                   (m_payloadHash + sizeof(m_payloadHash)) );
++    
++    // insert the ECID count field
++    packet.push_back( m_ecidCount );
++
++    // insert ECID data if exists
++    if (m_ecidCount > 0)
++    {
++        packet.insert( packet.end(),
++                       m_ecid,
++                       (m_ecid + sizeof(m_ecid)) );
++    }
++}
++
++
++
++/**
++ *  @brief   print the Software Header
++ */
++void SoftwareHdr::PrintHeader() const
++{
++    std::cout << "-----------------------------------------------------------------"
++              << std::endl
++              << " Software Header"
++              << std::endl
++              << "-----------------------------------------------------------------"
++              << std::endl
++              << "   m_version          = " << std::hex << std::setfill('0') << std::setw(4) << m_version
++              << std::endl
++              << "   m_hashAlg          = " << GetHashAlgoName( (int) m_hashAlg )
++              << std::endl
++              << "   m_unused           = "  << (int) m_unused
++              << std::endl;
++
++    std::cout << "   m_codeStartOffset  = " << std::hex << std::setfill('0') << std::setw(16) << m_codeStartOffset
++              << std::endl;
++
++    std::cout << "   m_reserved         = ";
++    printHexBytes( m_reserved, 8, g_COL_WIDTH );
++
++    std::cout << "   m_flags            = " << std::hex << std::setfill('0') << std::setw(8) << std::hex << m_flags
++              << std::endl
++              << "   m_reserved0        = " << (int) m_reserved0
++              << std::endl;
++
++    std::cout << "   m_payloadSize      = " << std::hex << std::setfill('0') << std::setw(16) << m_payloadSize
++              << std::endl;
++
++    std::cout << "   m_payloadHash      = ";
++    printHexBytes( m_payloadHash, SHA512_DIGEST_SIZE, g_COL_WIDTH );
++
++    std::cout << "   m_ecidCount        = " <<  (int) m_ecidCount
++              << std::endl;
++
++    for (int j = 0; j < m_ecidCount; j++)
++    {
++        std::cout << "   m_ecid[" << j << "]         = ";
++        printHexBytes( (const uint8_t *) &m_ecid[(j*ECID_SIZE)], ECID_SIZE, g_COL_WIDTH );
++    }
++    std::cout << std::endl;
++}
++
++
++
++
++// SoftwareSig C'tor
++SoftwareSig::SoftwareSig()
++   : m_swSigP(),
++     m_swSigQ(),
++     m_swSigR()
++{
++}
++
++
++/**
++ * @brief   Get the Prefix Data Header message as a byte stream
++ *
++ * @param[out]  packet  -  A reference to a vector of type uint8_t
++ */
++void SoftwareSig::GetHeaderBytes( std::vector<uint8_t>& packet ) const
++{
++    packet.clear();
++
++    uint8_t zeroKey[ECDSA521_KEY_SIZE];
++    memset( zeroKey, 0, ECDSA521_KEY_SIZE );
++
++    // insert the SW Signature-P field only if its valid
++    if (memcmp( m_swSigP, zeroKey, ECDSA521_KEY_SIZE) != 0)
++    {
++        packet.insert( packet.end(),
++                       m_swSigP,
++                       (m_swSigP + sizeof(m_swSigP)) );
++    }
++
++    // insert the SW Signature-Q field only if its valid
++    if (memcmp( m_swSigQ, zeroKey, ECDSA521_KEY_SIZE) != 0)
++    {
++        packet.insert( packet.end(),
++                       m_swSigQ,
++                       (m_swSigQ + sizeof(m_swSigQ)) );
++    }
++
++    // insert the SW Signature-R field only if its valid
++    if (memcmp( m_swSigR, zeroKey, ECDSA521_KEY_SIZE) != 0)
++    {
++        packet.insert( packet.end(),
++                       m_swSigR,
++                       (m_swSigR + sizeof(m_swSigR)) );
++    }
++}
++
++    
++
++/**
++ *  @brief   print the Software Signature
++ */
++void SoftwareSig::PrintHeader() const
++{
++    std::cout << "-----------------------------------------------------------------"
++              << std::endl
++              << " Software Signature"
++              << std::endl
++              << "-----------------------------------------------------------------"
++              << std::endl;
++
++    std::cout <<  "   m_swSigP           = ";
++    printHexBytes( m_swSigP, ECDSA521_SIG_SIZE, g_COL_WIDTH );
++
++    std::cout <<  "   m_swSigQ           = ";
++    printHexBytes( m_swSigQ, ECDSA521_SIG_SIZE, g_COL_WIDTH );
++
++    std::cout <<  "   m_swSigR           = ";
++    printHexBytes( m_swSigR, ECDSA521_SIG_SIZE, g_COL_WIDTH );
++    std::cout << std::endl;
++}
++
++
++// default C'tor
++IBM_Container::IBM_Container( std::string p_mode )
++   : m_containerHdr(),
++     m_prefixHdr(),
++     m_prefixData(),
++     m_softwareHdr(),
++     m_softwareSig(),
++     m_mode( p_mode )
++{
++    if ( !((m_mode == IBM_Utils::g_MODE_PRODUCTION) || 
++           (m_mode == IBM_Utils::g_MODE_DEVELOPMENT))  )
++    {
++        std::stringstream ss;
++        ss << "*** Invalid value for mode" << std::endl
++           << "--- Expecting <" << IBM_Utils::g_MODE_PRODUCTION 
++           << "> or <" << IBM_Utils::g_MODE_DEVELOPMENT << ">, got <"
++           << p_mode << ">" << std::endl;
++
++        THROW_EXCEPTION_STR(ss.str().c_str());
++    }
++
++    initializeMap();
++}
++
++
++
++// Given a filename, read its contents, parse the data and constuct the container
++IBM_Container::IBM_Container( std::string p_mode,
++                              std::string p_containerFileName )
++   : m_containerHdr(),
++     m_prefixHdr(),
++     m_prefixData(),
++     m_softwareHdr(),
++     m_softwareSig(),
++     m_mode( p_mode )
++{
++    if ( !((m_mode == IBM_Utils::g_MODE_PRODUCTION) || 
++           (m_mode == IBM_Utils::g_MODE_DEVELOPMENT))  )
++    {
++        std::stringstream ss;
++        ss << "*** Invalid value for mode" << std::endl
++           << "--- Expecting <" << IBM_Utils::g_MODE_PRODUCTION 
++           << "> or <" << IBM_Utils::g_MODE_DEVELOPMENT << ">, got <"
++           << p_mode << ">" << std::endl;
++
++        THROW_EXCEPTION_STR(ss.str().c_str());
++    }
++
++    initializeMap();
++
++    std::vector<uint8_t> buffer;
++
++    IBM_Utils* pUtils = IBM_Utils::get();
++
++    pUtils->ReadFromFile( p_containerFileName, buffer, 2048 );
++                               
++    ParseContainer( buffer );
++}
++
++
++// default D'tor
++IBM_Container::~IBM_Container()
++{
++}
++
++
++int IBM_Container::Validate()
++{
++}
++
++
++void IBM_Container::Print() const
++{
++    m_containerHdr.PrintHeader();
++    m_prefixHdr.PrintHeader();
++    m_prefixData.PrintHeader();
++    m_softwareHdr.PrintHeader();
++    m_softwareSig.PrintHeader();
++}
++
++
++bool IBM_Container::Save( const std::string p_fileName )
++{
++    // update the software key count
++    m_prefixHdr.m_swKeyCount = m_prefixData.GetSwKeyCount();
++
++    std::ofstream outfile( p_fileName.c_str(), std::ofstream::binary );
++    if (outfile.fail() )
++    {
++        std::stringstream ss;
++        ss << "!-> Failed to open file: " << p_fileName << std::endl;
++
++        THROW_EXCEPTION_STR(ss.str().c_str());
++    }
++
++    int padLen = 4096;
++
++    std::vector<uint8_t> hdrBytes;
++
++    // write the Container Header bytes
++    m_containerHdr.GetHeaderBytes( hdrBytes );
++    outfile.write( (char *) &hdrBytes[0], hdrBytes.size() );
++
++    padLen -= hdrBytes.size();
++
++    // write the Prefix Header bytes
++    m_prefixHdr.GetHeaderBytes( hdrBytes );
++    outfile.write( (char *) &hdrBytes[0], hdrBytes.size() );
++
++    padLen -= hdrBytes.size();
++
++    // write the Prefix Data bytes
++    m_prefixData.GetHeaderBytes( hdrBytes );
++    outfile.write( (char *) &hdrBytes[0], hdrBytes.size() );
++
++    padLen -= hdrBytes.size();
++
++    // write the Software Header Data bytes
++    m_softwareHdr.GetHeaderBytes( hdrBytes );
++    outfile.write( (char *) &hdrBytes[0], hdrBytes.size() );
++
++    padLen -= hdrBytes.size();
++
++    // write the Software Signature bytes
++    m_softwareSig.GetHeaderBytes( hdrBytes );
++    outfile.write( (char *) &hdrBytes[0], hdrBytes.size() );
++
++    padLen -= hdrBytes.size();
++
++    // see if we need to add padding bytes
++    if (padLen < 0)
++    {
++        std::stringstream ss;
++        ss << "!-> Wrong container length, must be <= 4096 bytes, it is <" 
++           << (4096 - padLen) << "> bytes" << std::endl;
++
++        THROW_EXCEPTION_STR(ss.str().c_str());
++    }
++
++    std::vector<char> padBytes(padLen, 0);
++
++    outfile.write( &padBytes[0], padBytes.size() );
++
++    outfile.close();
++
++    return true;
++}
++
++
++bool IBM_Container::UpdateField( const std::string p_fldName, const std::string p_value )
++{
++    ContainerFldMap::iterator itr = m_contFldMap.find(p_fldName);
++    if (itr == m_contFldMap.end())
++    {
++        std::stringstream ss;
++        ss << "Invalid field name <" << p_fldName << "> specified, issue \"help\" command"
++           << std::endl 
++           << "to get the list of supported fields."
++           << std::endl << std::endl;
++
++        THROW_EXCEPTION_STR(ss.str().c_str());
++    }
++
++    bool retVal = true;
++
++    IBM_ContainerFld eFldType = itr->second;
++    switch (eFldType)
++    {
++        case e_CONTAINER_VERSION:
++        {
++            uint16_t version;
++
++            std::stringstream ss(p_value);
++            if (!(ss >> version))
++            {
++                std::cout << "Option  <" << p_fldName << "> requires decimal integers only"
++                          << std::endl;
++
++                retVal = false;
++            }
++            else
++            {
++                m_containerHdr.m_version = version;
++            }
++
++            break;
++        }
++
++        case e_CONTAINER_SIZE:
++        {
++            uint64_t containerSize;
++
++            std::stringstream ss(p_value);
++            if (!(ss >> std::hex >> containerSize))
++            {
++                std::cout << "Option  <" << p_fldName << "> requires decimal integers only"
++                          << std::endl;
++
++                retVal = false;
++            }
++            else
++            {
++                m_containerHdr.m_containerSize = containerSize;
++            }
++
++            break;
++        }
++
++        case e_TARGET_HRMOR:
++        {
++            uint64_t targetHrmor;
++
++            std::stringstream ss(p_value);
++            if (!(ss >> std::hex >> targetHrmor))
++            {
++                std::cout << "Option  <" << p_fldName << "> requires decimal integers only"
++                          << std::endl;
++
++                retVal = false;
++            }
++            else
++            {
++                m_containerHdr.m_targetHrmor = targetHrmor;
++            }
++
++            break;
++        }
++
++        case e_STACK_POINTER:
++        {
++            uint64_t stackPointer;
++
++            std::stringstream ss(p_value);
++            if (!(ss >> std::hex >> stackPointer))
++            {
++                std::cout << "Option  <" << p_fldName << "> requires decimal integers only"
++                          << std::endl;
++
++                retVal = false;
++            }
++            else
++            {
++                m_containerHdr.m_stackPointer = stackPointer;
++            }
++
++            break;
++        }
++
++        case e_HW_PUBLIC_KEY_A:
++        {
++            std::vector<uint8_t> buffer;
++
++            ReadPublicKeyFromFile( m_mode,
++                                   p_value,
++                                   buffer );
++
++            memcpy( m_containerHdr.m_hwPkeyA, &buffer[0], buffer.size() );
++
++            break;
++        }
++
++        case e_HW_PUBLIC_KEY_B:
++        {
++            std::vector<uint8_t> buffer;
++
++            ReadPublicKeyFromFile( m_mode,
++                                   p_value,
++                                   buffer );
++
++            memcpy( m_containerHdr.m_hwPkeyB, &buffer[0], buffer.size() );
++
++            break;
++        }
++
++        case e_HW_PUBLIC_KEY_C:
++        {
++            std::vector<uint8_t> buffer;
++
++            ReadPublicKeyFromFile( m_mode,
++                                   p_value,
++                                   buffer );
++
++            memcpy( m_containerHdr.m_hwPkeyC, &buffer[0], buffer.size() );
++
++            break;
++        }
++
++        case e_PRE_HDR_VERSION:
++        {
++            uint16_t version;
++
++            std::stringstream ss(p_value);
++            if (!(ss >> version))
++            {
++                std::cout << "Option  <" << p_fldName << "> requires decimal integers only"
++                          << std::endl;
++
++                retVal = false;
++            }
++            else
++            {
++                m_prefixHdr.m_version = version;
++            }
++
++            break;
++        }
++
++        case e_PRE_HDR_HASH_ALGORITHM:
++        {
++            uint16_t hashAlg;
++
++            std::stringstream ss(p_value);
++            if (!(ss >> hashAlg))
++            {
++                std::cout << "Option  <" << p_fldName << "> requires decimal integers only"
++                          << std::endl;
++
++                retVal = false;
++            }
++            else
++            {
++                m_prefixHdr.m_hashAlg = (uint8_t) hashAlg;
++            }
++            break;
++        }
++
++        case e_PRE_HDR_SIGNING_ALGORITHM:
++        {
++            uint16_t sigAlg;
++
++            std::stringstream ss(p_value);
++            if (!(ss >> sigAlg))
++            {
++                std::cout << "Option  <" << p_fldName << "> requires decimal integers only"
++                          << std::endl;
++
++                retVal = false;
++            }
++            else
++            {
++                m_prefixHdr.m_sigAlg = (uint8_t) sigAlg;
++            }
++
++            break;
++        }
++
++        case e_PRE_HDR_CODE_START_OFFSET:
++        {
++            uint64_t codeStartOffset;
++
++            std::stringstream ss(p_value);
++            if (!(ss >> std::hex >> codeStartOffset))
++            {
++                std::cout << "Option  <" << p_fldName << "> requires decimal integers only"
++                          << std::endl;
++
++                retVal = false;
++            }
++            else
++            {
++                m_prefixHdr.m_codeStartOffset = codeStartOffset;
++            }
++
++            break;
++        }
++
++        case e_PRE_HDR_FLAGS:
++        {
++            uint32_t flags;
++
++            std::stringstream ss(p_value);
++            if (!(ss >> std::hex >> flags))
++            {
++                std::cout << "Option  <" << p_fldName << "> requires decimal integers only"
++                          << std::endl;
++
++                retVal = false;
++            }
++            else
++            {
++                m_prefixHdr.m_flags = flags;
++            }
++
++            break;
++        }
++
++        case e_PRE_HDR_PAYLOAD_SIZE:
++        {
++            uint64_t payloadSize;
++
++            std::stringstream ss(p_value);
++            if (!(ss >> std::hex >> payloadSize))
++            {
++                std::cout << "Option  <" << p_fldName << "> requires decimal integers only"
++                          << std::endl;
++
++                retVal = false;
++            }
++            else
++            {
++                m_prefixHdr.m_payloadSize = payloadSize;
++            }
++
++            break;
++        }
++
++        case e_PRE_HDR_PAYLOAD_HASH:
++        {
++            IBM_HexString hexString(p_value);
++
++            IBM_HexBytes hexBytes = hexString.getBinary();
++
++            memcpy( m_prefixHdr.m_payloadHash,
++                    (void *) &hexBytes[0],
++                    hexBytes.size() );
++
++            break;
++        }
++
++        case e_HW_SIGNATURE_A:
++        {
++            std::vector<uint8_t> buffer;
++
++            ReadSignatureFromFile( m_mode,
++                                   p_value,
++                                   buffer );
++
++            memcpy( m_prefixData.m_hwSigA, &buffer[0], buffer.size() );
++
++            break;
++        }
++
++        case e_HW_SIGNATURE_B:
++        {
++            std::vector<uint8_t> buffer;
++
++            ReadSignatureFromFile( m_mode,
++                                   p_value,
++                                   buffer );
++
++            memcpy( m_prefixData.m_hwSigB, &buffer[0], buffer.size() );
++
++            break;
++        }
++
++        case e_HW_SIGNATURE_C:
++        {
++            std::vector<uint8_t> buffer;
++
++            ReadSignatureFromFile( m_mode,
++                                   p_value,
++                                   buffer );
++
++            memcpy( m_prefixData.m_hwSigC, &buffer[0], buffer.size() );
++
++            break;
++        }
++
++        case e_SW_PUBLIC_KEY_P:
++        {
++            std::vector<uint8_t> buffer;
++
++            ReadPublicKeyFromFile( m_mode,
++                                   p_value,
++                                   buffer );
++
++            memcpy( m_prefixData.m_swPkeyP, &buffer[0], buffer.size() );
++
++            break;
++        }
++
++        case e_SW_PUBLIC_KEY_Q:
++        {
++            std::vector<uint8_t> buffer;
++
++            ReadPublicKeyFromFile( m_mode,
++                                   p_value,
++                                   buffer );
++
++            memcpy( m_prefixData.m_swPkeyQ, &buffer[0], buffer.size() );
++
++            break;
++        }
++
++        case e_SW_PUBLIC_KEY_R:
++        {
++            std::vector<uint8_t> buffer;
++
++            ReadPublicKeyFromFile( m_mode,
++                                   p_value,
++                                   buffer );
++
++            memcpy( m_prefixData.m_swPkeyR, &buffer[0], buffer.size() );
++
++            break;
++        }
++
++        case e_SW_HDR_VERSION:
++        {
++            uint16_t version;
++
++            std::stringstream ss(p_value);
++            if (!(ss >> version))
++            {
++                std::cout << "Option  <" << p_fldName << "> requires decimal integers only"
++                          << std::endl;
++
++                retVal = false;
++            }
++            else
++            {
++                m_softwareHdr.m_version = version;
++            }
++
++            break;
++        }
++
++        case e_SW_HDR_HASH_ALGORITHM:
++        {
++            uint16_t hashAlg;
++
++            std::stringstream ss(p_value);
++            if (!(ss >> hashAlg))
++            {
++                std::cout << "Option  <" << p_fldName << "> requires decimal integers only"
++                          << std::endl;
++
++                retVal = false;
++            }
++            else
++            {
++                m_softwareHdr.m_hashAlg = (uint8_t) hashAlg;
++            }
++
++            break;
++        }
++
++        case e_SW_HDR_CODE_START_OFFSET:
++        {
++            uint64_t codeStartOffset;
++
++            std::stringstream ss(p_value);
++            if (!(ss >> std::hex >> codeStartOffset))
++            {
++                std::cout << "Option  <" << p_fldName << "> requires decimal integers only"
++                          << std::endl;
++
++                retVal = false;
++            }
++            else
++            {
++                m_softwareHdr.m_codeStartOffset = codeStartOffset;
++            }
++
++            break;
++        }
++
++        case e_SW_HDR_FLAGS:
++        {
++            uint32_t flags;
++
++            std::stringstream ss(p_value);
++            if (!(ss >> std::hex >> flags))
++            {
++                std::cout << "Option  <" << p_fldName << "> requires decimal integers only"
++                          << std::endl;
++
++                retVal = false;
++            }
++            else
++            {
++                m_softwareHdr.m_flags = flags;
++            }
++
++            break;
++        }
++
++        case e_SW_HDR_PAYLOAD_SIZE:
++        {
++            uint64_t payloadSize;
++
++            std::stringstream ss(p_value);
++            if (!(ss >> std::hex >> payloadSize))
++            {
++                std::cout << "Option  <" << p_fldName << "> requires decimal integers only"
++                          << std::endl;
++
++                retVal = false;
++            }
++            else
++            {
++                m_softwareHdr.m_payloadSize = payloadSize;
++            }
++
++            break;
++        }
++
++        case e_SW_HDR_PAYLOAD_HASH:
++        {
++            IBM_HexString hexString(p_value);
++
++            IBM_HexBytes hexBytes = hexString.getBinary();
++
++            memcpy( m_softwareHdr.m_payloadHash,
++                    (void *) &hexBytes[0],
++                    hexBytes.size() );
++
++            break;
++        }
++
++        case e_SW_SIGNATURE_P:
++        {
++            std::vector<uint8_t> buffer;
++
++            ReadSignatureFromFile( m_mode,
++                                   p_value,
++                                   buffer );
++
++            memcpy( m_softwareSig.m_swSigP, &buffer[0], buffer.size() );
++
++            break;
++        }
++
++        case e_SW_SIGNATURE_Q:
++        {
++            std::vector<uint8_t> buffer;
++
++            ReadSignatureFromFile( m_mode,
++                                   p_value,
++                                   buffer );
++
++            memcpy( m_softwareSig.m_swSigQ, &buffer[0], buffer.size() );
++
++            break;
++        }
++
++        case e_SW_SIGNATURE_R:
++        {
++            std::vector<uint8_t> buffer;
++
++            ReadSignatureFromFile( m_mode,
++                                   p_value,
++                                   buffer );
++
++            memcpy( m_softwareSig.m_swSigR, &buffer[0], buffer.size() );
++
++            break;
++        }
++    }
++
++    return retVal;
++}
++
++
++bool IBM_Container::ComputeHash( std::string  p_hdrFldType,
++                                 std::string  p_hashAlgo,
++                                 std::string& p_digestStr )
++{
++    // check input fields
++    HdrFldTypeMap::iterator itr = m_hdrFldTypeMap.find(p_hdrFldType);
++    if (itr == m_hdrFldTypeMap.end())
++    {
++        std::stringstream ss;
++        ss << "Invalid header field type <" << p_hdrFldType << "> specified, issue \"help\" command"
++           << std::endl 
++           << "to get the list of supported header fields."
++           << std::endl << std::endl;
++
++        THROW_EXCEPTION_STR(ss.str().c_str());
++    }
++
++    HashAlgoMap::iterator itr1 = m_hashAlgoMap.find(p_hashAlgo);
++    if (itr1 == m_hashAlgoMap.end())
++    {
++        std::stringstream ss;
++        ss << "Invalid hash algorithm <" << p_hashAlgo << "> specified, issue \"help\" command"
++           << std::endl 
++           << "to get the list of supported hash slgorithms."
++           << std::endl << std::endl;
++
++        THROW_EXCEPTION_STR(ss.str().c_str());
++    }
++
++    std::vector<uint8_t> data;
++
++    IBM_HdrFldType hdrFldType = itr->second;
++    switch (hdrFldType)
++    {
++        case e_FLD_PREFIX_HDR:
++        {
++            m_prefixHdr.GetHeaderBytes(data);
++            break;
++        }
++
++        case e_FLD_SOFTWARE_HDR:
++        {
++            m_softwareHdr.GetHeaderBytes(data);
++            break;
++        }
++    }
++
++    THROW_EXCEPTION( data.size() == 0 );
++
++    IBM_HashAlgo hashAlgo = itr1->second;
++
++    IBM_Crypto crypto(m_mode);
++ 
++    return crypto.ComputeHash( hashAlgo, (const unsigned char*) &data[0], data.size(), p_digestStr );
++}
++
++
++void IBM_Container::initializeMap()
++{
++    m_contFldMap["container-version"]      =  e_CONTAINER_VERSION;
++    m_contFldMap["container-size"]         =  e_CONTAINER_SIZE;
++    m_contFldMap["target-hrmor"]           =  e_TARGET_HRMOR;
++    m_contFldMap["stack-pointer"]          =  e_STACK_POINTER;
++    m_contFldMap["hw-keya"]                =  e_HW_PUBLIC_KEY_A;
++    m_contFldMap["hw-keyb"]                =  e_HW_PUBLIC_KEY_B;
++    m_contFldMap["hw-keyc"]                =  e_HW_PUBLIC_KEY_C;
++
++    m_contFldMap["hdr-version"]            =  e_PRE_HDR_VERSION;
++    m_contFldMap["hdr-hash-algo"]          =  e_PRE_HDR_HASH_ALGORITHM;
++    m_contFldMap["hdr-sign-algo"]          =  e_PRE_HDR_SIGNING_ALGORITHM;
++    m_contFldMap["hdr-code-start-offset"]  =  e_PRE_HDR_CODE_START_OFFSET;
++    m_contFldMap["hdr-flags"]              =  e_PRE_HDR_FLAGS;
++    m_contFldMap["hdr-payload-size"]       =  e_PRE_HDR_PAYLOAD_SIZE;
++    m_contFldMap["hdr-payload-hash"]       =  e_PRE_HDR_PAYLOAD_HASH;
++
++    m_contFldMap["hw-signa"]               =  e_HW_SIGNATURE_A;
++    m_contFldMap["hw-signb"]               =  e_HW_SIGNATURE_B;
++    m_contFldMap["hw-signc"]               =  e_HW_SIGNATURE_C;
++    m_contFldMap["sw-keyp"]                =  e_SW_PUBLIC_KEY_P;
++    m_contFldMap["sw-keyq"]                =  e_SW_PUBLIC_KEY_Q;
++    m_contFldMap["sw-keyr"]                =  e_SW_PUBLIC_KEY_R;
++
++    m_contFldMap["sw-version"]             =  e_SW_HDR_VERSION;
++    m_contFldMap["sw-hash-algo"]           =  e_SW_HDR_HASH_ALGORITHM;
++    m_contFldMap["sw-code-start-offset"]   =  e_SW_HDR_CODE_START_OFFSET;
++    m_contFldMap["sw-flags"]               =  e_SW_HDR_FLAGS;
++    m_contFldMap["sw-payload-size"]        =  e_SW_HDR_PAYLOAD_SIZE;
++    m_contFldMap["sw-payload-hash"]        =  e_SW_HDR_PAYLOAD_HASH;
++
++    m_contFldMap["sw-signp"]               =  e_SW_SIGNATURE_P;
++    m_contFldMap["sw-signq"]               =  e_SW_SIGNATURE_Q;
++    m_contFldMap["sw-signr"]               =  e_SW_SIGNATURE_R;
++
++    m_hdrFldTypeMap["prefix_hdr"]          =  e_FLD_PREFIX_HDR;
++    m_hdrFldTypeMap["software_hdr"]        =  e_FLD_SOFTWARE_HDR;
++
++    m_hashAlgoMap["sha1"]                  =  e_SHA1_ALGO;
++    m_hashAlgoMap["sha256"]                =  e_SHA256_ALGO;
++    m_hashAlgoMap["sha384"]                =  e_SHA384_ALGO;
++    m_hashAlgoMap["sha512"]                =  e_SHA512_ALGO;
++}
++
++
++void IBM_Container::GetFieldNameList( std::vector<std::string>& p_fldNameList )
++{
++    p_fldNameList.clear();
++
++    std::transform( m_contFldMap.begin(), 
++                    m_contFldMap.end(),
++                    std::inserter( p_fldNameList, p_fldNameList.begin() ),
++                    GetKey<ContainerFldMap::value_type>() );
++}
++
++
++// Given a stream of bytes, parse the data and to extract the container fields
++void IBM_Container::ParseContainer( const std::vector<uint8_t>& p_rawData )
++{
++    const uint8_t* pRawData = &p_rawData[0];
++
++    THROW_EXCEPTION( pRawData == NULL );
++
++    int keyCount = 0;
++
++    // Parse the ContainerHdr
++    m_containerHdr.m_magicNumber = getUint32( pRawData );
++    pRawData += 4;
++   
++    m_containerHdr.m_version = getUint16( pRawData );
++    pRawData += 2;
++
++    m_containerHdr.m_containerSize = getUint64( pRawData );
++    pRawData += 8;
++   
++    m_containerHdr.m_targetHrmor = getUint64( pRawData );
++    pRawData += 8;
++   
++    m_containerHdr.m_stackPointer = getUint64( pRawData );
++    pRawData += 8;
++   
++    memcpy( &m_containerHdr.m_hwPkeyA, pRawData, ECDSA521_KEY_SIZE );
++    pRawData += ECDSA521_KEY_SIZE;
++   
++    memcpy( &m_containerHdr.m_hwPkeyB, pRawData, ECDSA521_KEY_SIZE );
++    pRawData += ECDSA521_KEY_SIZE;
++   
++    memcpy( &m_containerHdr.m_hwPkeyC, pRawData, ECDSA521_KEY_SIZE );
++    pRawData += ECDSA521_KEY_SIZE;
++
++    // Parse the PrefixHdr
++    m_prefixHdr.m_version = getUint16( pRawData );
++    pRawData += 2;
++
++    m_prefixHdr.m_hashAlg = *pRawData++;
++    m_prefixHdr.m_sigAlg  = *pRawData++;
++
++    m_prefixHdr.m_codeStartOffset = getUint64( pRawData );
++    pRawData += 8;
++   
++    memcpy( m_prefixHdr.m_reserved, pRawData, 8 );
++    pRawData += 8;
++   
++    m_prefixHdr.m_flags = getUint32( pRawData );
++    pRawData += 4;
++   
++    m_prefixHdr.m_swKeyCount  = *pRawData++;
++    keyCount = m_prefixHdr.m_swKeyCount;
++
++    m_prefixHdr.m_payloadSize = getUint64( pRawData );
++    pRawData += 8;
++   
++    memcpy( m_prefixHdr.m_payloadHash, pRawData, SHA512_DIGEST_SIZE );
++    pRawData += SHA512_DIGEST_SIZE;
++   
++    m_prefixHdr.m_ecidCount = *pRawData++;
++
++    for (int i = 0; i < m_prefixHdr.m_ecidCount; i++)
++    {
++        memcpy( (void *) &m_prefixHdr.m_ecid[i*ECID_SIZE], pRawData, ECID_SIZE );
++        pRawData += ECID_SIZE;
++    } 
++
++    // Parse the PrefixData
++    memcpy( m_prefixData.m_hwSigA, pRawData, ECDSA521_SIG_SIZE );
++    pRawData += ECDSA521_SIG_SIZE;
++   
++    memcpy( m_prefixData.m_hwSigB, pRawData, ECDSA521_SIG_SIZE );
++    pRawData += ECDSA521_SIG_SIZE;
++
++    memcpy( m_prefixData.m_hwSigC, pRawData, ECDSA521_SIG_SIZE );
++    pRawData += ECDSA521_SIG_SIZE;
++   
++    if (keyCount > 0) 
++    {
++        memcpy( m_prefixData.m_swPkeyP, pRawData, ECDSA521_KEY_SIZE );
++        pRawData += ECDSA521_KEY_SIZE;
++
++        --keyCount;
++    }
++    else
++    {
++        memset( m_prefixData.m_swPkeyP, 0, ECDSA521_KEY_SIZE );
++    }
++
++    if (keyCount > 0) 
++    {
++        memcpy( m_prefixData.m_swPkeyQ, pRawData, ECDSA521_KEY_SIZE );
++        pRawData += ECDSA521_KEY_SIZE;
++
++        --keyCount;
++    }
++    else
++    {
++        memset( m_prefixData.m_swPkeyQ, 0, ECDSA521_KEY_SIZE );
++    }
++
++    if (keyCount > 0) 
++    {
++        memcpy( m_prefixData.m_swPkeyR, pRawData, ECDSA521_KEY_SIZE );
++        pRawData += ECDSA521_KEY_SIZE;
++
++        --keyCount;
++    }
++    else
++    {
++        memset( m_prefixData.m_swPkeyR, 0, ECDSA521_KEY_SIZE );
++    }
++
++    // Parse the SoftwareHdr
++    m_softwareHdr.m_version = getUint16( pRawData );
++    pRawData += 2;
++
++    m_softwareHdr.m_hashAlg = *pRawData++;
++    m_softwareHdr.m_unused  = *pRawData++;
++
++    m_softwareHdr.m_codeStartOffset = getUint64( pRawData );
++    pRawData += 8;
++
++    memcpy( m_softwareHdr.m_reserved, pRawData, 8 );
++    pRawData += 8;
++
++    m_softwareHdr.m_flags = getUint32( pRawData );
++    pRawData += 4;
++
++    m_softwareHdr.m_reserved0  = *pRawData++;
++
++    m_softwareHdr.m_payloadSize = getUint64( pRawData );
++    pRawData += 8;
++
++    memcpy( m_softwareHdr.m_payloadHash, pRawData, SHA512_DIGEST_SIZE );
++    pRawData += SHA512_DIGEST_SIZE;
++
++    m_softwareHdr.m_ecidCount = *pRawData++;
++
++    for (int i = 0; i < m_softwareHdr.m_ecidCount; i++)
++    {
++        memcpy( (void *) &m_softwareHdr.m_ecid[i*ECID_SIZE], pRawData, ECID_SIZE );
++        pRawData += ECID_SIZE;
++    } 
++
++    // Parse the SoftwareSig
++    keyCount = m_prefixHdr.m_swKeyCount;
++
++    if (keyCount > 0)
++    {
++        memcpy( m_softwareSig.m_swSigP, pRawData, ECDSA521_SIG_SIZE );
++        pRawData += ECDSA521_SIG_SIZE;
++
++        --keyCount;
++    }
++    else
++    {
++        memset( m_softwareSig.m_swSigP, 0, ECDSA521_SIG_SIZE );
++    }
++
++    if (keyCount > 0)
++    {
++        memcpy( m_softwareSig.m_swSigQ, pRawData, ECDSA521_SIG_SIZE );
++        pRawData += ECDSA521_SIG_SIZE;
++
++        --keyCount;
++    }
++    else
++    {
++        memset( m_softwareSig.m_swSigQ, 0, ECDSA521_SIG_SIZE );
++    }
++
++    if (keyCount > 0)
++    {
++        memcpy( m_softwareSig.m_swSigR, pRawData, ECDSA521_SIG_SIZE );
++        pRawData += ECDSA521_SIG_SIZE;
++
++        --keyCount;
++    }
++    else
++    {
++        memset( m_softwareSig.m_swSigR, 0, ECDSA521_SIG_SIZE );
++    }
++}
+diff --git a/src/signtool/IBM_Container.h b/src/signtool/IBM_Container.h
+new file mode 100644
+index 0000000..17da967
+--- /dev/null
++++ b/src/signtool/IBM_Container.h
+@@ -0,0 +1,253 @@
++/* IBM_PROLOG_BEGIN_TAG                                                   */
++/* This is an automatically generated prolog.                             */
++/*                                                                        */
++/* $Source: src/signtool/IBM_Container.h $                                */
++/*                                                                        */
++/* OpenPOWER sb-signing-utils Project                                     */
++/*                                                                        */
++/* Contributors Listed Below - COPYRIGHT 2016                             */
++/* [+] International Business Machines Corp.                              */
++/*                                                                        */
++/*                                                                        */
++/* Licensed under the Apache License, Version 2.0 (the "License");        */
++/* you may not use this file except in compliance with the License.       */
++/* You may obtain a copy of the License at                                */
++/*                                                                        */
++/*     http://www.apache.org/licenses/LICENSE-2.0                         */
++/*                                                                        */
++/* Unless required by applicable law or agreed to in writing, software    */
++/* distributed under the License is distributed on an "AS IS" BASIS,      */
++/* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or        */
++/* implied. See the License for the specific language governing           */
++/* permissions and limitations under the License.                         */
++/*                                                                        */
++/* IBM_PROLOG_END_TAG                                                     */
++
++#ifndef __IBM_CONTAINER_H_
++#define __IBM_CONTAINER_H_
++
++#include <stdint.h>
++
++#include <map>
++#include <string>
++#include <vector>
++
++#include "IBM_Utils.h"
++
++struct ContainerHdr
++{
++    uint32_t  m_magicNumber;                    // (17082011)
++    uint16_t  m_version;                        // (1: see versions above)
++    uint64_t  m_containerSize;                  // filled by caller
++    uint64_t  m_targetHrmor;                    // filled by caller
++    uint64_t  m_stackPointer;                   // filled by caller
++    uint8_t   m_hwPkeyA[ECDSA521_KEY_SIZE];
++    uint8_t   m_hwPkeyB[ECDSA521_KEY_SIZE];
++    uint8_t   m_hwPkeyC[ECDSA521_KEY_SIZE];
++
++    ContainerHdr();
++
++    void PrintHeader() const;
++    void GetHeaderBytes( std::vector<uint8_t>& packet ) const;
++
++}  __attribute__ ((packed));
++
++
++struct PrefixHdr
++{
++    uint16_t  m_version;                         // (1: see versions above)
++    uint8_t   m_hashAlg;                         // (1: SHA-512)
++    uint8_t   m_sigAlg;                          // (1: SHA-512/ECDSA-521)
++    uint64_t  m_codeStartOffset;
++    uint8_t   m_reserved[8];
++    uint32_t  m_flags;
++    uint8_t   m_swKeyCount;
++    uint64_t  m_payloadSize;
++    uint8_t   m_payloadHash[SHA512_DIGEST_SIZE];
++    uint8_t   m_ecidCount;
++    uint8_t   m_ecid[ECID_SIZE];                 // optional ecid place 
++                                                 // holder ecid_count * szeof(ecids)
++    PrefixHdr();
++                                                 
++    void PrintHeader() const;
++    void GetHeaderBytes( std::vector<uint8_t>& packet ) const;
++
++} __attribute__ ((packed));
++
++
++struct PrefixData
++{
++    uint8_t   m_hwSigA[ECDSA521_SIG_SIZE];
++    uint8_t   m_hwSigB[ECDSA521_SIG_SIZE];
++    uint8_t   m_hwSigC[ECDSA521_SIG_SIZE];
++    uint8_t   m_swPkeyP[ECDSA521_KEY_SIZE];
++    uint8_t   m_swPkeyQ[ECDSA521_KEY_SIZE];
++    uint8_t   m_swPkeyR[ECDSA521_KEY_SIZE];
++
++    PrefixData();
++
++    void PrintHeader() const;
++    int  GetSwKeyCount() const;
++    void GetHeaderBytes( std::vector<uint8_t>& packet ) const;
++
++} __attribute__ ((packed));
++
++
++struct SoftwareHdr
++{
++    uint16_t  m_version;                         // (1: see versions above)
++    uint8_t   m_hashAlg;                         // (1: SHA-512)
++    uint8_t   m_unused;
++    uint64_t  m_codeStartOffset;
++    uint8_t   m_reserved[8];
++    uint32_t  m_flags;
++    uint8_t   m_reserved0;
++    uint64_t  m_payloadSize;
++    uint8_t   m_payloadHash[SHA512_DIGEST_SIZE];
++    uint8_t   m_ecidCount;
++    uint8_t   m_ecid[ECID_SIZE];                 // optional ecid place 
++                                                 // holder ecid_count * szeof(ecids)
++    SoftwareHdr();
++                                             
++    void PrintHeader() const;
++    void GetHeaderBytes( std::vector<uint8_t>& packet ) const;
++
++} __attribute__ ((packed));
++
++
++struct SoftwareSig
++{
++    uint8_t   m_swSigP[ECDSA521_SIG_SIZE];
++    uint8_t   m_swSigQ[ECDSA521_SIG_SIZE];
++    uint8_t   m_swSigR[ECDSA521_SIG_SIZE];
++
++    SoftwareSig();
++                                             
++    void PrintHeader() const;
++    void GetHeaderBytes( std::vector<uint8_t>& packet ) const;
++
++} __attribute__ ((packed));
++
++
++
++
++/* The Container Layout consists of the following 5 blocks 
++ *   ContainerHdr
++ *   PrefixHdr
++ *   PrefixData
++ *   SoftwareHdr
++ *   SoftwareSig
++ */
++class IBM_Container
++{
++public:
++    enum IBM_HdrFldType
++    {
++        e_FLD_PREFIX_HDR,
++        e_FLD_SOFTWARE_HDR
++    };
++
++    enum IBM_ContainerFld
++    {
++        // these are the fields in Container Header
++        e_CONTAINER_VERSION,
++        e_CONTAINER_SIZE,
++        e_TARGET_HRMOR,
++        e_STACK_POINTER,
++        e_HW_PUBLIC_KEY_A,
++        e_HW_PUBLIC_KEY_B,
++        e_HW_PUBLIC_KEY_C,
++   
++        // these are the fields in Prefix Header
++        e_PRE_HDR_VERSION,
++        e_PRE_HDR_HASH_ALGORITHM,
++        e_PRE_HDR_SIGNING_ALGORITHM,
++        e_PRE_HDR_CODE_START_OFFSET,
++        e_PRE_HDR_FLAGS,
++        e_PRE_HDR_PAYLOAD_SIZE,
++        e_PRE_HDR_PAYLOAD_HASH,
++
++        // these are the fields in Prefix Data
++        e_HW_SIGNATURE_A,
++        e_HW_SIGNATURE_B,
++        e_HW_SIGNATURE_C,
++        e_SW_PUBLIC_KEY_P,
++        e_SW_PUBLIC_KEY_Q,
++        e_SW_PUBLIC_KEY_R,
++
++        // these are the fields in Software Header
++        e_SW_HDR_VERSION,
++        e_SW_HDR_HASH_ALGORITHM,
++        e_SW_HDR_CODE_START_OFFSET,
++        e_SW_HDR_FLAGS,
++        e_SW_HDR_PAYLOAD_SIZE,
++        e_SW_HDR_PAYLOAD_HASH,
++
++        // these are the fields in Software Signature
++        e_SW_SIGNATURE_P,
++        e_SW_SIGNATURE_Q,
++        e_SW_SIGNATURE_R
++    };
++
++    // default C'tor
++    IBM_Container( std::string p_mode );
++
++    // Given a filename, read its contents, parse the data and constuct the container
++    IBM_Container( std::string p_mode,
++                   std::string p_containerFileName );
++
++    // Given a stream of bytes, parse the data and constuct the container
++    IBM_Container( uint8_t *p_rawData );
++
++    ~IBM_Container();
++
++    int  Validate();
++
++    void Print() const;
++
++    bool Save( const std::string p_fileName ); 
++
++    bool UpdateField( const std::string p_fldName, const std::string p_value ); 
++
++    void GetFieldNameList( std::vector<std::string>& p_fldNameList );
++
++    bool ComputeHash( std::string  p_hashHdrType,
++                      std::string  p_hashAlgo,
++                      std::string& p_digestStr );
++
++private:
++    // Disallow Copy Constructor and Assignment Operator
++    IBM_Container( IBM_Container& ); 
++    IBM_Container operator = ( IBM_Container& );
++    
++    void initializeMap();
++
++    void ParseContainer( const std::vector<uint8_t>& p_rawData );
++
++    /* The Container Layout consists of the following 5 blocks 
++     *   ContainerHdr
++     *   PrefixHdr
++     *   PrefixData
++     *   SoftwareHdr
++     *   SoftwareSig
++     */
++    ContainerHdr m_containerHdr;
++    PrefixHdr    m_prefixHdr;
++    PrefixData   m_prefixData;
++    SoftwareHdr  m_softwareHdr;
++    SoftwareSig  m_softwareSig;
++
++    std::string  m_mode;
++
++    typedef std::map<std::string, IBM_ContainerFld> ContainerFldMap;
++
++    typedef std::map<std::string, IBM_HdrFldType> HdrFldTypeMap;
++    typedef std::map<std::string, IBM_HashAlgo>   HashAlgoMap;
++
++    HashAlgoMap      m_hashAlgoMap;
++    HdrFldTypeMap    m_hdrFldTypeMap;
++
++    ContainerFldMap  m_contFldMap;
++};
++
++#endif // __IBM_CONTAINER_H_
+diff --git a/src/signtool/IBM_Crypto.cpp b/src/signtool/IBM_Crypto.cpp
+new file mode 100644
+index 0000000..8eea2fa
+--- /dev/null
++++ b/src/signtool/IBM_Crypto.cpp
+@@ -0,0 +1,702 @@
++/* IBM_PROLOG_BEGIN_TAG                                                   */
++/* This is an automatically generated prolog.                             */
++/*                                                                        */
++/* $Source: src/signtool/IBM_Crypto.cpp $                                 */
++/*                                                                        */
++/* OpenPOWER sb-signing-utils Project                                     */
++/*                                                                        */
++/* Contributors Listed Below - COPYRIGHT 2016                             */
++/* [+] International Business Machines Corp.                              */
++/*                                                                        */
++/*                                                                        */
++/* Licensed under the Apache License, Version 2.0 (the "License");        */
++/* you may not use this file except in compliance with the License.       */
++/* You may obtain a copy of the License at                                */
++/*                                                                        */
++/*     http://www.apache.org/licenses/LICENSE-2.0                         */
++/*                                                                        */
++/* Unless required by applicable law or agreed to in writing, software    */
++/* distributed under the License is distributed on an "AS IS" BASIS,      */
++/* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or        */
++/* implied. See the License for the specific language governing           */
++/* permissions and limitations under the License.                         */
++/*                                                                        */
++/* IBM_PROLOG_END_TAG                                                     */
++
++#include <unistd.h>
++#include <stdint.h>
++#include <string.h>
++#include <arpa/inet.h>
++
++#include <algorithm>
++
++#include <openssl/ec.h>
++#include <openssl/err.h>
++#include <openssl/ecdsa.h>
++#include <openssl/obj_mac.h>
++#include <openssl/evp.h>
++#include <openssl/pem.h>
++
++#include "IBM_Utils.h"
++#include "IBM_HexString.h"
++#include "IBM_Exception.h"
++
++#include "IBM_Crypto.h"
++
++
++IBM_Crypto::IBM_Crypto( const std::string& p_mode )
++   : m_mode(p_mode)
++{
++    if ( !((m_mode == IBM_Utils::g_MODE_PRODUCTION) || 
++           (m_mode == IBM_Utils::g_MODE_DEVELOPMENT))  )
++    {
++        std::stringstream ss;
++        ss << "*** Invalid value for mode" << std::endl
++           << "--- Expecting <" << IBM_Utils::g_MODE_PRODUCTION 
++           << "> or <" << IBM_Utils::g_MODE_DEVELOPMENT << ">, got <"
++           << p_mode << ">" << std::endl;
++
++        THROW_EXCEPTION_STR(ss.str().c_str());
++    }
++
++    OpenSSL_add_all_algorithms();
++    ERR_load_BIO_strings();
++    ERR_load_crypto_strings();
++}
++
++
++IBM_Crypto::~IBM_Crypto()
++{
++    ERR_free_strings();
++    EVP_cleanup();
++}
++
++
++bool IBM_Crypto::CreateKeyPair( const std::string& p_privKeyFileName,
++                                const std::string& p_pubKeyFileName )
++{
++    int eccgrp = OBJ_txt2nid("secp521r1");
++
++    EC_KEY* key = EC_KEY_new_by_curve_name(eccgrp);
++    THROW_EXCEPTION(key == NULL);
++
++    EC_KEY_set_asn1_flag( key, OPENSSL_EC_NAMED_CURVE );
++
++    // Create the public/private EC key pair
++    if (!EC_KEY_generate_key(key))
++    {
++        THROW_EXCEPTION_STR("Error generating the ECC key.\n");
++    }
++  
++    // Converting the EC key into a PKEY structure let's
++    // us handle the key just like any other key pair.
++    EVP_PKEY* pkey = EVP_PKEY_new();
++    THROW_EXCEPTION(pkey == NULL);
++
++    if (!EVP_PKEY_assign_EC_KEY( pkey, key ))
++    {
++        THROW_EXCEPTION_STR("Error assigning ECC key to EVP_PKEY structure.\n");
++    }
++
++    // write the private key data in PEM format
++    FILE* privFp = fopen( p_privKeyFileName.c_str(), "w" );
++    if (privFp == NULL)
++    {
++        std::stringstream ss;
++        ss << "Failed to open private key file <" 
++           << p_privKeyFileName
++           << ">"
++           << std::endl;
++        
++        THROW_EXCEPTION_STR(ss.str().c_str());
++    }
++
++    BIO* privKeyOut = BIO_new(BIO_s_file());
++    THROW_EXCEPTION(privKeyOut == NULL);
++
++    BIO_set_fp( privKeyOut, privFp, BIO_NOCLOSE );
++
++    if (!PEM_write_bio_PrivateKey( privKeyOut, pkey, NULL, NULL, 0, 0, NULL ))
++    {
++        THROW_EXCEPTION_STR("Error writing private key data in PEM format.\n");
++    }
++    BIO_free(privKeyOut);
++
++    // write the public key data in PEM format
++    FILE* pubFp = fopen( p_pubKeyFileName.c_str(), "w" );
++    if (pubFp == NULL)
++    {
++        std::stringstream ss;
++        ss << "Failed to open public key file <" 
++           << p_pubKeyFileName
++           << ">"
++           << std::endl;
++        
++        THROW_EXCEPTION_STR(ss.str().c_str());
++    }
++
++    BIO* pubKeyOut = BIO_new(BIO_s_file());
++    THROW_EXCEPTION(privKeyOut == NULL);
++
++    BIO_set_fp( pubKeyOut, pubFp, BIO_NOCLOSE );
++
++    if(!PEM_write_bio_PUBKEY( pubKeyOut, pkey))
++    {
++        THROW_EXCEPTION_STR("Error writing public key data in PEM format.\n");
++    }
++    BIO_free(pubKeyOut);
++
++    EVP_PKEY_free(pkey);
++    EC_KEY_free(key);
++
++    return true;
++}
++
++
++bool IBM_Crypto::Sign( const std::string& p_pKeyName,
++                       const std::string& p_digest,
++                       const std::string& p_signFileName,
++                       const std::string& p_saHostName,
++                       int                p_saPortNum )
++{
++    //  Make sure the signature is in upper case.
++    std::string digest = p_digest;
++
++    std::transform( digest.begin(), digest.end(), digest.begin(), ::toupper );
++
++    // convert the digest string to hex byte array
++    IBM_HexString hexString(digest);
++
++    IBM_HexBytes dgstBytes = hexString.getBinary();
++
++    // supports only sha-256, sha-384 and sha-512 signatures
++    switch (dgstBytes.size())
++    {
++        case 32:     // sha-256
++        case 48:     // sha-384
++        case 64:     // sha-512
++        {
++            break;
++        }
++
++        default:
++        {
++            std::stringstream ss;
++            ss << "*** Invalid digest string size" << std::endl
++               << "--- Expected sha-256(32), sha-384(48), or sha-512(64)"
++               << " bytes, got : " << dgstBytes.size() << std::endl;
++
++            THROW_EXCEPTION_STR(ss.str().c_str());
++        }
++    }
++
++    // structure to receive signature bytes
++    IBM_HexBytes signBytes;
++
++    int rv = -1;
++
++    if (m_mode == IBM_Utils::g_MODE_DEVELOPMENT)
++    {
++        rv = doOpensslSign( p_pKeyName, dgstBytes, signBytes );
++    }
++    else if (m_mode == IBM_Utils::g_MODE_PRODUCTION)
++    {
++        // FIXME - add support to pass in sign_agent hostname and port
++        rv = doCcaSign( p_pKeyName, dgstBytes, signBytes, p_saHostName, p_saPortNum );
++    }
++
++    std::cout << "CCA sign: signature :" << IBM_HexString(signBytes) << std::endl;
++
++    IBM_Utils* pUtils = IBM_Utils::get();
++    THROW_EXCEPTION(pUtils == NULL);
++
++    pUtils->WriteToFile( p_signFileName.c_str(), signBytes );
++
++    return (rv == 0) ? true : false;
++}
++
++
++int IBM_Crypto::Verify( const std::string& p_pubKeyFileName,
++                        const std::string& p_digest,
++                        const std::string& p_signFileName )
++{
++    int rv = -1;
++
++    // convert the digest string to hex byte array
++    IBM_HexString hexString(p_digest);
++
++    IBM_HexBytes dgstBytes = hexString.getBinary();
++
++    // supports only sha-256, sha-384 and sha-512 signatures
++    switch (dgstBytes.size())
++    {
++        case 32:      // Sha-256
++        case 48:      // Sha-384
++        case 64:      // Sha-512
++        {
++            break;
++        }
++
++        default:
++        {
++            std::stringstream ss;
++            ss << "*** Invalid digest string size" << std::endl
++               << "--- Expected sha-256(32), sha-384(48), or sha-512(64)"
++               << " bytes, got : " << dgstBytes.size() << std::endl;
++
++            THROW_EXCEPTION_STR(ss.str().c_str());
++        }
++    }
++
++    if (m_mode == IBM_Utils::g_MODE_DEVELOPMENT)
++    {
++        rv = doOpensslVerify( p_pubKeyFileName, dgstBytes, p_signFileName );
++    }
++    else if (m_mode == IBM_Utils::g_MODE_PRODUCTION )
++    {
++        rv = doCcaVerify( p_pubKeyFileName, dgstBytes, p_signFileName );
++    }
++
++    return rv;
++}
++
++
++bool IBM_Crypto::ComputeHash( IBM_HashAlgo         p_hashAlgo,
++                              const unsigned char* p_data,
++                              size_t               p_dataLen,
++                              std::string&         p_digestStr )
++{
++    IBM_HexBytes dgstBytes;
++
++    switch (p_hashAlgo)
++    {
++        case e_SHA1_ALGO:
++        {
++            dgstBytes.resize(SHA_DIGEST_LENGTH);
++
++            SHA1( p_data, p_dataLen, (unsigned char *) &dgstBytes[0] );
++            break;
++        }
++
++        case e_SHA256_ALGO:
++        {
++            dgstBytes.resize(SHA256_DIGEST_LENGTH);
++
++            SHA256( p_data, p_dataLen, (unsigned char *) &dgstBytes[0] );
++            break;
++        }
++
++        case e_SHA384_ALGO:
++        {
++            dgstBytes.resize(SHA384_DIGEST_LENGTH);
++
++            SHA384( p_data, p_dataLen, (unsigned char *) &dgstBytes[0] );
++            break;
++        }
++        case e_SHA512_ALGO:
++        {
++            dgstBytes.resize(SHA512_DIGEST_LENGTH);
++
++            SHA512( p_data, p_dataLen, (unsigned char *) &dgstBytes[0] );
++            break;
++        }
++    }
++
++    p_digestStr = IBM_HexString(dgstBytes).getAscii();
++
++    return true;
++}
++
++
++bool IBM_Crypto::doCcaSign( const std::string&  p_pKeyName,
++                            const IBM_HexBytes& p_dgstBytes,
++                            IBM_HexBytes&       p_signBytes,
++                            const std::string&  p_serverHost,
++                            int                 p_serverPort )
++{
++    uint8_t buf[1024];
++
++    struct sockaddr_in server_addr;
++
++    /* fill in sign agent packet */
++    struct sign_agent_packet_s pkt;
++
++    memset( (void *) &pkt, 0, sizeof(pkt) );
++
++    if (p_pKeyName.length() >= sizeof(pkt.keyname))
++    {
++        std::stringstream ss;
++        ss << "*** Length of keyname is too long for use with CCA" << std::endl
++           << "--- Passed in keyname length is " << p_pKeyName.length() 
++           << " bytes, must be <= 32 bytes." << std::endl;
++
++        THROW_EXCEPTION_STR(ss.str().c_str());
++    }
++
++    snprintf( (char*)pkt.keyname, sizeof( pkt.keyname ) - 1, "%s", p_pKeyName.c_str() );
++
++    for (uint32_t i = 0; i < p_dgstBytes.size(); i++)
++    {
++        pkt.digest[i] = p_dgstBytes[i];
++    }
++
++    std::cout << "CCA sign: key:" << p_pKeyName << " data:" << IBM_HexString(p_dgstBytes);
++
++    /* create a Unix domain stream socket */
++    int fd = socket( AF_INET, SOCK_STREAM, 0 );
++    if (fd < 0)
++    {
++        THROW_EXCEPTION_STR("Unable to create socket.\n");
++    }
++
++    /* fill socket address structure w/server's addr */
++    server_addr.sin_family = AF_INET;
++    server_addr.sin_port = htons(p_serverPort);
++    inet_aton( p_serverHost.c_str(), &(server_addr.sin_addr) );
++
++    if (connect (fd, (struct sockaddr*)&server_addr, sizeof(struct sockaddr_in)) < 0)
++    {
++        std::stringstream ss;
++        ss << "*** Unable to connect to sign_agent" << std::endl
++           << "--- Socket connect to " << p_serverHost << "@" << p_serverPort
++           << " failed." << std::endl;
++
++        THROW_EXCEPTION_STR(ss.str().c_str());
++    }
++
++    if (write( fd, &pkt, sizeof(struct sign_agent_packet_s) )
++                                != sizeof(struct sign_agent_packet_s))
++    {
++        THROW_EXCEPTION_STR("Unable to send data to sign_agent.\n");
++    }
++
++    int len = read( fd, buf, 1024 );
++    if (len < 0)
++    {
++        THROW_EXCEPTION_STR("Failed to read from sign_agent.\n");
++    }
++
++    p_signBytes.assign( buf, buf + len );
++
++    close(fd);
++
++    return 0;
++}
++
++
++bool IBM_Crypto::doOpensslSign( const std::string&  p_privKeyFileName,
++                                const IBM_HexBytes& p_dgstBytes,
++                                IBM_HexBytes&       p_signBytes )
++{
++    FILE *fp = fopen( p_privKeyFileName.c_str(), "r" );
++    if (fp == NULL)
++    {
++        std::stringstream ss; 
++        ss << "Failed to open private key file <"
++           << p_privKeyFileName
++           << ">"
++           << std::endl;
++        
++        THROW_EXCEPTION_STR(ss.str().c_str());
++    }
++
++    int retVal = -1;
++
++    ECDSA_SIG *eccSig = NULL;
++    EVP_PKEY* pkey = PEM_read_PrivateKey( fp, NULL, NULL, NULL );
++    if (pkey == NULL)
++    {
++        std::stringstream ss; 
++        ss << "Failed to read public key from file <"
++           << p_privKeyFileName
++           << ">"
++           << std::endl;
++
++        THROW_EXCEPTION_STR(ss.str().c_str());
++    }
++
++    try
++    {
++        EC_KEY *key = EVP_PKEY_get1_EC_KEY(pkey);
++
++        const EC_GROUP *ecgrp = EC_KEY_get0_group(key);
++
++        std::cout << "ECC Key type: "
++                  << OBJ_nid2sn(EC_GROUP_get_curve_name(ecgrp)) 
++                  << std::endl;
++
++        eccSig = ECDSA_do_sign( &p_dgstBytes[0], p_dgstBytes.size(), key );
++        if (eccSig == NULL)
++        {
++            THROW_EXCEPTION_STR("Failed to generate ECC Signature.\n");
++        }
++
++        int sigSize = i2d_ECDSA_SIG( eccSig, NULL );
++   
++        p_signBytes.resize(sigSize);
++
++        byte* pSigBytes = &p_signBytes[0];
++
++        i2d_ECDSA_SIG( eccSig, &pSigBytes );
++
++        ECDSA_SIG_free(eccSig);
++        EVP_PKEY_free(pkey);
++        fclose( fp );
++    }
++    catch ( IBM_Exception& e )
++    {
++        if (eccSig)
++        {
++            ECDSA_SIG_free(eccSig);
++        }
++
++        if (pkey)
++        {
++            EVP_PKEY_free(pkey);
++        }
++
++        if (fp)
++        {
++            fclose(fp);
++        }
++
++        // rethrow the exception
++        throw;
++    }
++
++    return 0;
++}
++
++
++int IBM_Crypto::doCcaVerify( const std::string&  p_pubKeyFileName,
++                             const IBM_HexBytes& p_dgstBytes,
++                             const std::string&  p_signFileName )
++{
++    // The private key is a random integer (0 < priv_key < order, where order is
++    // the order of the EC_GROUP object). The public key is an EC_POINT on the
++    // curve calculated by multiplying the generator for the curve by the private key.
++    
++    // The public key value is an uncompressed point. It is defined
++    // by value 04, which is an identifier for an uncompressed point,
++    // followed by the X and Y coordinate, where the X and Y are encoded
++    // as unsigned big endian octet strings that have the same size as
++    // the key size (same as the size of the order of the curve in the
++    // parameters).
++    
++    // the IBM public key is not DER formated but just the X and Y 
++    // points on the named EC curve as mentioned above, so we need to
++    // convert this to a DER format that OpenSSL APIs can work with
++
++    // read the public key file
++    IBM_Utils* pUtils = IBM_Utils::get();
++    THROW_EXCEPTION(pUtils == NULL);
++
++    IBM_HexBytes pkBytes;
++    
++    pUtils->ReadFromFile( p_pubKeyFileName, pkBytes, (ECDSA521_KEY_SIZE+1) );
++    
++    // The first byte should have the value 0x04, else its an invalid public key file
++    if (pkBytes[0] != 0x04)
++    {
++        std::stringstream ss;
++        ss << "File <" 
++           << p_pubKeyFileName 
++           << "> is not a vaid p521 public key file"
++           << std::endl;
++    
++        THROW_EXCEPTION_STR(ss.str().c_str());
++    }
++    
++    // public key file OK, delete the first byte
++    pkBytes.erase( pkBytes.begin() );
++
++    BIGNUM* X = NULL;
++    BIGNUM* Y = NULL;
++    BIGNUM* r = NULL;
++    BIGNUM* s = NULL;
++
++    EC_KEY* key    = NULL;
++
++    int status = -1;
++
++    try
++    {
++        X = BN_new();
++        THROW_EXCEPTION(X == NULL);
++
++        Y = BN_new();
++        THROW_EXCEPTION(Y == NULL);
++
++        BN_bin2bn( &pkBytes[0], 66, X );
++        BN_bin2bn( &pkBytes[66], 66, Y );
++
++        int eccgrp = OBJ_txt2nid("secp521r1");
++
++        key = EC_KEY_new_by_curve_name(eccgrp);
++        THROW_EXCEPTION(key == NULL);
++
++        EC_KEY_set_asn1_flag( key, OPENSSL_EC_NAMED_CURVE );
++
++        EC_KEY_set_public_key_affine_coordinates( key, X, Y );
++
++        // the IBM signature file consists of a sequence of 2 Integers r and s 
++        // is not DER formated, so we need to convert this to a DER format that
++        // OpenSSL APIs can work with
++
++        // read the Signature file
++        IBM_HexBytes sigBytes;
++    
++        pUtils->ReadFromFile( p_signFileName, sigBytes, ECDSA521_SIG_SIZE );
++
++        r = BN_new();
++        THROW_EXCEPTION(r == NULL);
++
++        s = BN_new();
++        THROW_EXCEPTION(s == NULL);
++
++        BN_bin2bn( &sigBytes[0], 66, r );
++        BN_bin2bn( &sigBytes[66], 66, s );
++
++        ECDSA_SIG signature;
++        signature.r = r;
++        signature.s = s;
++
++        int sigSize = i2d_ECDSA_SIG( &signature, NULL );
++       
++        uint8_t derBytes[sigSize];
++
++        uint8_t* derCopy = &derBytes[0];
++
++        i2d_ECDSA_SIG( &signature, &derCopy );
++
++        status = ECDSA_do_verify( &p_dgstBytes[0],
++                                  p_dgstBytes.size(),
++                                  &signature,
++                                  key );
++
++        BN_free(r);
++        BN_free(s);
++        BN_free(X);
++        BN_free(Y);
++        EC_KEY_free(key);
++    }
++    catch ( IBM_Exception& e )
++    {
++        if (r)
++        {
++            BN_free(r);
++        }
++
++        if (s)
++        {
++            BN_free(s);
++        }
++
++        if (X)
++        {
++            BN_free(X);
++        }
++
++        if (Y)
++        {
++            BN_free(Y);
++        }
++
++        if (key)
++        {
++            EC_KEY_free(key);
++        }
++
++        // rethrow the exception
++        throw;
++    }
++
++    return status;
++}
++
++
++int IBM_Crypto::doOpensslVerify( const std::string&   p_pubKeyFileName,
++                                 const IBM_HexBytes&  p_dgstBytes,
++                                 const std::string&   p_signFileName )
++{
++    // read the public key file
++    FILE *fp = fopen( p_pubKeyFileName.c_str(), "r" );
++    if (fp == NULL)
++    {
++        std::stringstream ss;
++        ss << "Failed to open public key file <" 
++           << p_pubKeyFileName
++           << ">"
++           << std::endl;
++    
++        THROW_EXCEPTION_STR(ss.str().c_str());
++    }
++
++    EVP_PKEY* pkey = PEM_read_PUBKEY( fp, NULL, NULL, NULL );
++    if (pkey == NULL)
++    {
++        std::stringstream ss; 
++        ss << "Failed to read public key from file <"
++           << p_pubKeyFileName
++           << ">"
++           << std::endl;
++
++        THROW_EXCEPTION_STR(ss.str().c_str());
++    }
++
++    ECDSA_SIG* eccsig = NULL;
++
++    int status = -1;
++    try
++    {
++        EC_KEY* key = EVP_PKEY_get1_EC_KEY(pkey);
++        THROW_EXCEPTION(key == NULL);
++
++        const EC_GROUP* ecgrp = EC_KEY_get0_group(key);
++        THROW_EXCEPTION(ecgrp == NULL);
++
++        // read the Signature file
++        IBM_HexBytes sigBytes;
++    
++        IBM_Utils* pUtils = IBM_Utils::get();
++        THROW_EXCEPTION(pUtils == NULL);
++
++        pUtils->ReadFromFile( p_signFileName, sigBytes );
++    
++        // construct signature object from the signature bytes
++        const byte* p_sigBytes = &sigBytes[0];
++
++        ECDSA_SIG* eccsig = d2i_ECDSA_SIG( NULL, &p_sigBytes, sigBytes.size() );
++        THROW_EXCEPTION(eccsig == NULL);
++
++        status = ECDSA_do_verify( &p_dgstBytes[0],
++                                  p_dgstBytes.size(),
++                                  eccsig,
++                                  key );
++        ECDSA_SIG_free(eccsig);
++        EVP_PKEY_free(pkey);
++        fclose( fp );
++    }
++    catch ( IBM_Exception& e )
++    {
++        if (eccsig)
++        {
++            ECDSA_SIG_free(eccsig);
++        }
++
++        if (pkey)
++        {
++            EVP_PKEY_free(pkey);
++        }
++
++        if (fp)
++        {
++            fclose( fp );
++        }
++
++        // rethrow the exception
++        throw;
++    }
++
++    return status;
++}
+diff --git a/src/signtool/IBM_Crypto.h b/src/signtool/IBM_Crypto.h
+new file mode 100644
+index 0000000..a1a97bd
+--- /dev/null
++++ b/src/signtool/IBM_Crypto.h
+@@ -0,0 +1,93 @@
++/* IBM_PROLOG_BEGIN_TAG                                                   */
++/* This is an automatically generated prolog.                             */
++/*                                                                        */
++/* $Source: src/signtool/IBM_Crypto.h $                                   */
++/*                                                                        */
++/* OpenPOWER sb-signing-utils Project                                     */
++/*                                                                        */
++/* Contributors Listed Below - COPYRIGHT 2016                             */
++/* [+] International Business Machines Corp.                              */
++/*                                                                        */
++/*                                                                        */
++/* Licensed under the Apache License, Version 2.0 (the "License");        */
++/* you may not use this file except in compliance with the License.       */
++/* You may obtain a copy of the License at                                */
++/*                                                                        */
++/*     http://www.apache.org/licenses/LICENSE-2.0                         */
++/*                                                                        */
++/* Unless required by applicable law or agreed to in writing, software    */
++/* distributed under the License is distributed on an "AS IS" BASIS,      */
++/* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or        */
++/* implied. See the License for the specific language governing           */
++/* permissions and limitations under the License.                         */
++/*                                                                        */
++/* IBM_PROLOG_END_TAG                                                     */
++
++#ifndef __IBM_CRYPTO_H_
++#define __IBM_CRYPTO_H_
++
++#include <vector>
++#include <string>
++
++#include "IBM_HexString.h"
++#include "IBM_Utils.h"
++
++class IBM_Crypto
++{
++public:
++    IBM_Crypto( const std::string& p_mode );
++    virtual ~IBM_Crypto();
++
++    bool Sign( const std::string& p_pKeyName,
++               const std::string& p_digest,
++               const std::string& p_signFileName,
++               const std::string& p_saHostName,
++               int                p_saPortNum );
++
++    int Verify( const std::string& p_pubKeyFileName,
++                const std::string& p_digest,
++                const std::string& p_signFileName );
++
++    bool CreateKeyPair( const std::string& p_privKeyFileName,
++                        const std::string& p_pubKeyFileName );
++
++    bool ComputeHash( IBM_HashAlgo         p_hashAlgo,
++                      const unsigned char* p_data,
++                      size_t               p_dataLen,
++                      std::string&         p_digestStr );
++
++private:
++    // Disallow Copy Constructor and Assignment Operator
++    IBM_Crypto( IBM_Crypto& ); 
++    IBM_Crypto operator = ( IBM_Crypto& );
++    
++    virtual bool doCcaSign( const std::string&  p_pKeyName,
++                            const IBM_HexBytes& p_dgstBytes,
++                            IBM_HexBytes&       p_signBytes,
++                            const std::string&  p_serverName,
++                            int                 p_serverPort );
++
++    virtual bool doOpensslSign( const std::string&  p_privKeyFileName,
++                                const IBM_HexBytes& p_dgstBytes,
++                                IBM_HexBytes&       p_signBytes );
++
++    virtual int doCcaVerify( const std::string&  p_pubKeyFileName,
++                             const IBM_HexBytes& p_dgstBytes,
++                             const std::string&  p_signFileName );
++
++    virtual int doOpensslVerify( const std::string&  p_pubKeyFileName,
++                                 const IBM_HexBytes& p_dgstBytes,
++                                 const std::string&  p_signFileName );
++
++    std::string  m_mode;
++};
++
++
++struct sign_agent_packet_s
++{
++    uint8_t     keyname[32];
++    uint8_t     digest[32];
++} __attribute__((packed));
++
++
++#endif // __IBM_CRYPTO_H_
+diff --git a/src/signtool/IBM_Exception.cpp b/src/signtool/IBM_Exception.cpp
+new file mode 100644
+index 0000000..4eeb1e2
+--- /dev/null
++++ b/src/signtool/IBM_Exception.cpp
+@@ -0,0 +1,69 @@
++/* IBM_PROLOG_BEGIN_TAG                                                   */
++/* This is an automatically generated prolog.                             */
++/*                                                                        */
++/* $Source: src/signtool/IBM_Exception.cpp $                              */
++/*                                                                        */
++/* OpenPOWER sb-signing-utils Project                                     */
++/*                                                                        */
++/* Contributors Listed Below - COPYRIGHT 2016                             */
++/* [+] International Business Machines Corp.                              */
++/*                                                                        */
++/*                                                                        */
++/* Licensed under the Apache License, Version 2.0 (the "License");        */
++/* you may not use this file except in compliance with the License.       */
++/* You may obtain a copy of the License at                                */
++/*                                                                        */
++/*     http://www.apache.org/licenses/LICENSE-2.0                         */
++/*                                                                        */
++/* Unless required by applicable law or agreed to in writing, software    */
++/* distributed under the License is distributed on an "AS IS" BASIS,      */
++/* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or        */
++/* implied. See the License for the specific language governing           */
++/* permissions and limitations under the License.                         */
++/*                                                                        */
++/* IBM_PROLOG_END_TAG                                                     */
++
++#include <stdio.h>
++#include <cstdarg>
++#include <cstring>
++
++#include <vector>
++
++#include "IBM_Exception.h"
++
++
++IBM_Exception::~IBM_Exception() throw() 
++{
++}
++
++
++IBM_Exception::IBM_Exception( const char *format, ... ) 
++{ 
++    const int bufSize = static_cast<int>(std::max((size_t)2048, strlen(format) * 2)); 
++    
++    std::vector<char> buffer(bufSize, '\0'); 
++    
++    va_list vargs; 
++    va_start(vargs, format); 
++    int size = vsnprintf(&buffer[0], bufSize, format, vargs); 
++    va_end(vargs); 
++    
++    if ( size > (bufSize - 1) ) 
++    {
++        // replace tail of msg with "..."
++        size = bufSize - 1; 
++        for ( int i = (bufSize - 4); i < (bufSize - 1); ++i ) 
++        {
++            buffer[i] = '.';
++        }
++    }
++    buffer[size] = '\0'; 
++    
++    m_what = std::string(&buffer[0], (&buffer[0] + size));
++}
++
++
++const char* IBM_Exception::what() const throw() 
++{ 
++    return m_what.c_str();
++}
+diff --git a/src/signtool/IBM_Exception.h b/src/signtool/IBM_Exception.h
+new file mode 100644
+index 0000000..0a7e61b
+--- /dev/null
++++ b/src/signtool/IBM_Exception.h
+@@ -0,0 +1,59 @@
++/* IBM_PROLOG_BEGIN_TAG                                                   */
++/* This is an automatically generated prolog.                             */
++/*                                                                        */
++/* $Source: src/signtool/IBM_Exception.h $                                */
++/*                                                                        */
++/* OpenPOWER sb-signing-utils Project                                     */
++/*                                                                        */
++/* Contributors Listed Below - COPYRIGHT 2016                             */
++/* [+] International Business Machines Corp.                              */
++/*                                                                        */
++/*                                                                        */
++/* Licensed under the Apache License, Version 2.0 (the "License");        */
++/* you may not use this file except in compliance with the License.       */
++/* You may obtain a copy of the License at                                */
++/*                                                                        */
++/*     http://www.apache.org/licenses/LICENSE-2.0                         */
++/*                                                                        */
++/* Unless required by applicable law or agreed to in writing, software    */
++/* distributed under the License is distributed on an "AS IS" BASIS,      */
++/* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or        */
++/* implied. See the License for the specific language governing           */
++/* permissions and limitations under the License.                         */
++/*                                                                        */
++/* IBM_PROLOG_END_TAG                                                     */
++
++#ifndef __IBM_EXCEPTION_H_
++#define __IBM_EXCEPTION_H_
++
++#include <string>
++#include <stdexcept>
++
++class IBM_Exception : public std::exception
++{
++public:
++    IBM_Exception( const char *p_errorMsg, ... );
++
++    virtual ~IBM_Exception() throw();
++
++    /*
++     * Returns this object's error string.
++     */
++    virtual const char* what() const throw();
++
++private:
++    std::string m_what;
++};
++
++
++#define THROW_EXCEPTION(condition) \
++    if (condition) \
++    { \
++        throw IBM_Exception( "Exception thrown at %s [%d] %s", __FILE__, __LINE__, #condition ); \
++    }
++
++#define THROW_EXCEPTION_STR(str) \
++    throw IBM_Exception( "Exception thrown at %s [%d] %s", __FILE__, __LINE__, str );
++
++
++#endif  //  __IBM_EXCEPTION_H_
+diff --git a/src/signtool/IBM_HexString.h b/src/signtool/IBM_HexString.h
+new file mode 100644
+index 0000000..546c956
+--- /dev/null
++++ b/src/signtool/IBM_HexString.h
+@@ -0,0 +1,194 @@
++/* IBM_PROLOG_BEGIN_TAG                                                   */
++/* This is an automatically generated prolog.                             */
++/*                                                                        */
++/* $Source: src/signtool/IBM_HexString.h $                                */
++/*                                                                        */
++/* OpenPOWER sb-signing-utils Project                                     */
++/*                                                                        */
++/* Contributors Listed Below - COPYRIGHT 2016                             */
++/* [+] International Business Machines Corp.                              */
++/*                                                                        */
++/*                                                                        */
++/* Licensed under the Apache License, Version 2.0 (the "License");        */
++/* you may not use this file except in compliance with the License.       */
++/* You may obtain a copy of the License at                                */
++/*                                                                        */
++/*     http://www.apache.org/licenses/LICENSE-2.0                         */
++/*                                                                        */
++/* Unless required by applicable law or agreed to in writing, software    */
++/* distributed under the License is distributed on an "AS IS" BASIS,      */
++/* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or        */
++/* implied. See the License for the specific language governing           */
++/* permissions and limitations under the License.                         */
++/*                                                                        */
++/* IBM_PROLOG_END_TAG                                                     */
++
++#ifndef __IBM_HEXSTRING_H_
++#define __IBM_HEXSTRING_H_
++
++#include <stdint.h>
++
++#include <string>
++#include <vector>
++#include <istream>
++#include <ostream>
++#include <sstream>
++#include <fstream>
++#include <iomanip>
++#include <iostream>
++
++
++//  A hex string object.
++
++typedef unsigned char byte;
++
++typedef std::vector<byte> IBM_HexBytes;
++
++class IBM_HexString
++{
++    friend std::ostream& operator<< ( std::ostream& strm,
++                                      const IBM_HexString& hs );
++
++public:
++    inline void setWidth( uint8_t width )
++    { 
++        m_width = width;
++    }
++
++    inline void setLeadSpace( uint8_t leadSpace )
++    { 
++        m_leadSpace = leadSpace;
++    }
++
++    inline bool isValid() const
++    {
++        return m_valid;
++    }
++
++    inline std::string getAscii() const
++    {
++        return m_ascii;
++    }
++
++    inline std::vector<uint8_t> getBinary () const
++    {
++        return m_bytes;
++    }
++
++    //  Constructors
++    inline IBM_HexString (std::string       hexInAscii );
++    inline IBM_HexString (std::vector<byte> byteArray  );
++
++private:
++    uint8_t         m_width;
++    uint8_t         m_leadSpace;
++    bool            m_valid;
++    std::string     m_ascii;
++    IBM_HexBytes    m_bytes;
++};
++
++
++inline IBM_HexString::IBM_HexString ( std::string hexInAscii )
++   : m_width(0),
++     m_leadSpace(0),
++     m_valid(true)
++{
++    //  Size must be divisible by 2.
++    if (hexInAscii.size() % 2)
++    {
++        return;
++    }
++
++    //  Must be the right kind of char.
++    size_t found = hexInAscii.find_first_not_of("0123456789abcdefABCDEF ");
++
++    if (found != std::string::npos)
++    {
++        return;
++    }
++    
++    // Prepare for conversion.
++    m_ascii = hexInAscii;
++
++    // Convert each pair of digits into a byte.
++    for( std::string::const_iterator i =  m_ascii.begin();
++                                     i != m_ascii.end();
++                                     i += 2 )
++    {
++        unsigned b;
++
++        std::string temp( i, i + 2 );
++
++        std::stringstream conv( temp, std::istringstream::in );
++
++        conv >> std::hex >> b;
++
++        m_bytes.push_back((uint8_t)b);
++    }
++
++    m_valid = true;
++}
++
++
++
++inline IBM_HexString::IBM_HexString( std::vector<byte> byteArray )
++   : m_width(0),
++     m_leadSpace(0),
++     m_valid(true),
++     m_bytes(byteArray)
++{
++    std::stringstream conv(std::istringstream::out);
++
++    conv << std::hex << std::setfill('0') << std::uppercase;
++
++    // Convert each byte into a pair of hexadecimal characters.
++    for( std::vector<uint8_t>::const_iterator i = m_bytes.begin();
++         i != m_bytes.end();
++         ++i )
++    {
++        conv << std::setw(2) << (unsigned) * i;
++    }
++
++    // Store the converted value.
++    m_ascii = conv.str();
++}
++
++
++inline std::ostream& operator<< ( std::ostream& strm, const IBM_HexString& hc )
++{
++    unsigned int count = 0;
++
++    int width = hc.m_width;
++
++    if (width == 0)
++    {
++        width = 128;
++    }
++
++    for( std::string::const_iterator it =  hc.m_ascii.begin();
++                                     it != hc.m_ascii.end();
++                                     it++ )
++    {
++        ++count;
++
++        strm << *it;
++
++        if ((count % width) == 0)
++        {
++            strm << std::endl;
++            if (hc.m_leadSpace)
++            {
++                strm << std::string( hc.m_leadSpace, ' ' );
++            }
++        }
++    }
++
++    if ((count % width) != 0)
++    {
++        strm << std::endl;
++    }
++
++    return strm;
++}
++
++#endif // __IBM_HEXSTRING_H_
+diff --git a/src/signtool/IBM_Utils.cpp b/src/signtool/IBM_Utils.cpp
+new file mode 100755
+index 0000000..aa53469
+--- /dev/null
++++ b/src/signtool/IBM_Utils.cpp
+@@ -0,0 +1,262 @@
++/* IBM_PROLOG_BEGIN_TAG                                                   */
++/* This is an automatically generated prolog.                             */
++/*                                                                        */
++/* $Source: src/signtool/IBM_Utils.cpp $                                  */
++/*                                                                        */
++/* OpenPOWER sb-signing-utils Project                                     */
++/*                                                                        */
++/* Contributors Listed Below - COPYRIGHT 2016                             */
++/* [+] International Business Machines Corp.                              */
++/*                                                                        */
++/*                                                                        */
++/* Licensed under the Apache License, Version 2.0 (the "License");        */
++/* you may not use this file except in compliance with the License.       */
++/* You may obtain a copy of the License at                                */
++/*                                                                        */
++/*     http://www.apache.org/licenses/LICENSE-2.0                         */
++/*                                                                        */
++/* Unless required by applicable law or agreed to in writing, software    */
++/* distributed under the License is distributed on an "AS IS" BASIS,      */
++/* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or        */
++/* implied. See the License for the specific language governing           */
++/* permissions and limitations under the License.                         */
++/*                                                                        */
++/* IBM_PROLOG_END_TAG                                                     */
++
++#include <string.h>
++
++#include <fstream>
++#include <iostream>
++#include <vector>
++#include <string>
++#include <sstream>
++
++#include <openssl/ec.h>
++#include <openssl/bn.h>
++#include <openssl/err.h>
++#include <openssl/ecdsa.h>
++#include <openssl/obj_mac.h>
++#include <openssl/evp.h>
++#include <openssl/pem.h>
++
++#include "IBM_Exception.h"
++#include "IBM_Utils.h"
++
++
++const std::string IBM_Utils::g_MODE_PRODUCTION  = "production";
++const std::string IBM_Utils::g_MODE_DEVELOPMENT = "development";
++
++IBM_Utils::IBM_Utils()
++{
++}
++
++
++IBM_Utils::~IBM_Utils()
++{
++}
++
++    
++IBM_Utils* IBM_Utils::get()
++{
++    static IBM_Utils utils;
++    return &utils;
++}
++    
++
++void IBM_Utils::ReadFromFile( const std::string& p_fileName,
++                              std::vector<byte>& p_buffer )
++{
++    std::ifstream ifs( p_fileName, std::ifstream::binary );
++    if (!ifs.is_open() )
++    {
++        std::stringstream ss;
++        ss << "!-> Failed to open file: " << p_fileName << std::endl;
++
++        THROW_EXCEPTION_STR(ss.str().c_str());
++    }
++
++    // get length of file
++    ifs.seekg( 0, std::ios_base::end );
++    std::streampos fileSize = ifs.tellg();
++
++    p_buffer.clear();
++    p_buffer.resize(fileSize);
++
++    ifs.seekg( 0, std::ios_base::beg );
++    ifs.read( (char *) &p_buffer[0], fileSize );
++
++    ifs.close();
++}
++
++
++void IBM_Utils::ReadFromFile( const std::string& p_fileName,
++                              std::vector<byte>& p_buffer,
++                              int                p_readSize )
++{
++    std::ifstream ifs( p_fileName, std::ifstream::binary );
++    if (!ifs.is_open() )
++    {
++        std::stringstream ss;
++        ss << "!-> Failed to open file: " << p_fileName << std::endl;
++
++        THROW_EXCEPTION_STR(ss.str().c_str());
++    }
++
++    // get length of file
++    ifs.seekg( 0, std::ios_base::end );
++    std::streampos fileSize = ifs.tellg();
++    
++    if (fileSize < p_readSize)
++    {
++        std::stringstream ss;
++        ss << "!-> Specified container file <"
++           << p_fileName
++           << "> has invalid size of <"
++           << fileSize
++           << "> bytes, must be atleast "
++           << p_readSize 
++           << " bytes"
++           << std::endl;
++    
++        THROW_EXCEPTION_STR(ss.str().c_str());
++    }
++    
++    p_buffer.clear();
++    p_buffer.resize(p_readSize);
++    
++    ifs.seekg( 0, std::ios_base::beg );
++    ifs.read( (char *) &p_buffer[0], p_readSize );
++    
++    ifs.close();
++}
++
++
++bool IBM_Utils::WriteToFile( const std::string& p_fileName,
++                             std::vector<byte>& p_buffer )
++{
++    std::ofstream outfile( p_fileName, std::ios_base::binary );
++
++    if (outfile.fail())
++    {
++        return false;
++    }
++
++    //  Write the data to disk.
++    outfile.write( (const char *) p_buffer.data(), p_buffer.size() );
++
++    outfile.close();
++
++    return true;
++}
++
++
++void IBM_Utils::GetPublicKeyBytes( const std::string& p_fileName,
++                                   std::vector<byte>& p_buffer )
++{
++    FILE *fp = fopen( p_fileName.c_str(), "r" );
++    if (fp == NULL)
++    {
++        std::stringstream ss;
++        ss << "Failed to open private key file <"
++           << p_fileName
++           << ">"
++           << std::endl;
++
++        THROW_EXCEPTION_STR(ss.str().c_str());
++    }
++
++    EVP_PKEY*  pkey    = NULL;
++
++    try
++    {
++        pkey = PEM_read_PUBKEY( fp, NULL, NULL, NULL );
++        if (pkey == NULL)
++        {
++            std::stringstream ss;
++            ss << "Failed to read public key from file <"
++               << p_fileName
++               << ">"
++               << std::endl;
++
++            THROW_EXCEPTION_STR(ss.str().c_str());
++        }
++
++        EC_KEY *key = EVP_PKEY_get1_EC_KEY(pkey);
++        THROW_EXCEPTION(key == NULL);
++
++        const EC_GROUP *ecgrp = EC_KEY_get0_group(key);
++        THROW_EXCEPTION(ecgrp == NULL);
++
++        const EC_POINT *ecpoint = EC_KEY_get0_public_key(key);
++        THROW_EXCEPTION(ecpoint == NULL);
++
++        char* pubkey = EC_POINT_point2hex( ecgrp,
++                                           ecpoint,
++                                           POINT_CONVERSION_UNCOMPRESSED,
++                                           NULL );
++
++        IBM_HexString pubKeyHexString(pubkey);
++
++        IBM_HexBytes dgstBytes = pubKeyHexString.getBinary();
++
++        // remove the first byte
++        dgstBytes.erase( dgstBytes.begin() );
++
++        p_buffer.clear();
++        std::copy( dgstBytes.begin(), dgstBytes.end(), std::back_inserter(p_buffer) );
++    
++        EVP_PKEY_free(pkey);
++        OPENSSL_free(pubkey);
++        fclose(fp);
++    }
++    catch ( IBM_Exception& e )
++    {
++        if (pkey)
++        {
++            EVP_PKEY_free(pkey);
++        }
++
++        if (fp)
++        {
++            fclose( fp );
++        }
++
++        // rethrow exception
++        throw;
++    }
++
++    return;
++}
++
++
++void IBM_Utils::GetSignatureBytes( const std::string& p_fileName,
++                                   std::vector<byte>& p_buffer )
++{
++    std::vector<uint8_t> sigBytes;
++
++    this->ReadFromFile( p_fileName.c_str(), sigBytes );
++
++    const uint8_t* p_sigBytes = &sigBytes[0];
++
++    // convert the read data to a signature object
++    ECDSA_SIG* signature = d2i_ECDSA_SIG( NULL, &p_sigBytes, sigBytes.size() );
++
++    byte sBuf[ECDSA521_SIG_SIZE];
++    memset( &sBuf, 0, sizeof(sBuf) );
++
++    int rLen = BN_num_bytes(signature->r);
++    int rOff = (rLen == 66) ? 0 : 1;
++
++    BN_bn2bin(signature->r, &sBuf[rOff]);
++
++    int sLen = BN_num_bytes(signature->s);
++    int sOff = (sLen == 66) ? 66 : 67;
++
++    BN_bn2bin(signature->s, &sBuf[sOff]);
++
++    p_buffer.clear();
++    p_buffer.resize(ECDSA521_SIG_SIZE);
++    memcpy( &p_buffer[0], sBuf, ECDSA521_SIG_SIZE );
++
++    return;
++}
+diff --git a/src/signtool/IBM_Utils.h b/src/signtool/IBM_Utils.h
+new file mode 100755
+index 0000000..cbbf339
+--- /dev/null
++++ b/src/signtool/IBM_Utils.h
+@@ -0,0 +1,92 @@
++/* IBM_PROLOG_BEGIN_TAG                                                   */
++/* This is an automatically generated prolog.                             */
++/*                                                                        */
++/* $Source: src/signtool/IBM_Utils.h $                                    */
++/*                                                                        */
++/* OpenPOWER sb-signing-utils Project                                     */
++/*                                                                        */
++/* Contributors Listed Below - COPYRIGHT 2016                             */
++/* [+] International Business Machines Corp.                              */
++/*                                                                        */
++/*                                                                        */
++/* Licensed under the Apache License, Version 2.0 (the "License");        */
++/* you may not use this file except in compliance with the License.       */
++/* You may obtain a copy of the License at                                */
++/*                                                                        */
++/*     http://www.apache.org/licenses/LICENSE-2.0                         */
++/*                                                                        */
++/* Unless required by applicable law or agreed to in writing, software    */
++/* distributed under the License is distributed on an "AS IS" BASIS,      */
++/* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or        */
++/* implied. See the License for the specific language governing           */
++/* permissions and limitations under the License.                         */
++/*                                                                        */
++/* IBM_PROLOG_END_TAG                                                     */
++
++#ifndef __IBM_UTILS_H_
++#define __IBM_UTILS_H_
++
++#include <stdint.h>
++
++#include <string>
++#include <vector>
++
++#include "IBM_HexString.h"
++
++#define CONTAINER_VERSION   1
++#define HEADER_VERSION      1
++#define HASH_ALG_SHA512     1
++#define SIG_ALG_ECDSA521    1
++
++#define HBI_BASE_SIGNING_KEY 0x80000000
++
++#define ROM_MAGIC_NUMBER     0x17082011
++
++#define SHA512_DIGEST_SIZE   64
++#define ECDSA521_KEY_SIZE   132
++#define ECDSA521_SIG_SIZE   132
++#define ECID_SIZE            16
++
++ 
++enum IBM_HashAlgo
++{
++    e_SHA1_ALGO,
++    e_SHA256_ALGO,
++    e_SHA384_ALGO,
++    e_SHA512_ALGO
++};
++
++
++class IBM_Utils
++{
++public:
++    static const std::string g_MODE_PRODUCTION;
++    static const std::string g_MODE_DEVELOPMENT;
++ 
++    ~IBM_Utils(); 
++    
++    static IBM_Utils* get(); 
++    
++    void ReadFromFile( const std::string& p_fileName,
++                       std::vector<byte>& p_buffer );
++
++    void ReadFromFile( const std::string& p_fileName,
++                       std::vector<byte>& p_buffer,
++                       int                p_readSize );
++
++    bool WriteToFile( const std::string& p_fileName,
++                      std::vector<byte>& p_buffer );
++
++    void GetPublicKeyBytes( const std::string& p_fileName,
++                            std::vector<byte>& p_buffer );
++
++    void GetSignatureBytes( const std::string& p_fileName,
++                            std::vector<byte>& p_buffer );
++
++private:
++    IBM_Utils();                                //!< disallow 
++    IBM_Utils( IBM_Utils& );                    //!< disallow
++    IBM_Utils& operator = ( const IBM_Utils& ); //!< disallow
++}; 
++
++#endif //  __IBM_UTILS_H_
+diff --git a/src/signtool/Makefile.am b/src/signtool/Makefile.am
+new file mode 100755
+index 0000000..e440e5e
+--- /dev/null
++++ b/src/signtool/Makefile.am
+@@ -0,0 +1,48 @@
++# IBM_PROLOG_BEGIN_TAG
++# This is an automatically generated prolog.
++#
++# $Source: src/signtool/Makefile.am $
++#
++# OpenPOWER sb-signing-utils Project
++#
++# Contributors Listed Below - COPYRIGHT 2016
++# [+] International Business Machines Corp.
++#
++#
++# Licensed under the Apache License, Version 2.0 (the "License");
++# you may not use this file except in compliance with the License.
++# You may obtain a copy of the License at
++#
++#     http://www.apache.org/licenses/LICENSE-2.0
++#
++# Unless required by applicable law or agreed to in writing, software
++# distributed under the License is distributed on an "AS IS" BASIS,
++# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
++# implied. See the License for the specific language governing
++# permissions and limitations under the License.
++#
++# IBM_PROLOG_END_TAG
++
++bin_PROGRAMS = signtool
++
++signtool_SOURCES = \
++        IBM_Container.cpp \
++        IBM_Exception.cpp \
++        IBM_Utils.cpp  \
++        IBM_Crypto.cpp  \
++        signtool.cpp
++
++# If c++11 support exists, the appropriate compile flag will end up in CXXCPP.
++# If we couldn't find c++11 support, make a last ditch effort and try to use
++# c++0x (will fail compile if even this is not available)
++CXXCPP0X=$(if ifeq @HAVE_CXX11@ "0",-std=c++0x,)
++
++signtool_CPPFLAGS = $(CXXCPP) $(CXXCPP0X) -I. -I -g3
++signtool_LDFLAGS =
++signtool_LDADD = -lcrypto
++
++install-data-local:
++	$(INSTALL) -dv   $(localstatedir)/rca
++
++install-exec-local:
++	$(INSTALL) -dv $(bindir)
+diff --git a/src/signtool/signtool.cpp b/src/signtool/signtool.cpp
+new file mode 100755
+index 0000000..dc52f55
+--- /dev/null
++++ b/src/signtool/signtool.cpp
+@@ -0,0 +1,593 @@
++/* IBM_PROLOG_BEGIN_TAG                                                   */
++/* This is an automatically generated prolog.                             */
++/*                                                                        */
++/* $Source: src/signtool/signtool.cpp $                                   */
++/*                                                                        */
++/* OpenPOWER sb-signing-utils Project                                     */
++/*                                                                        */
++/* Contributors Listed Below - COPYRIGHT 2016                             */
++/* [+] International Business Machines Corp.                              */
++/*                                                                        */
++/*                                                                        */
++/* Licensed under the Apache License, Version 2.0 (the "License");        */
++/* you may not use this file except in compliance with the License.       */
++/* You may obtain a copy of the License at                                */
++/*                                                                        */
++/*     http://www.apache.org/licenses/LICENSE-2.0                         */
++/*                                                                        */
++/* Unless required by applicable law or agreed to in writing, software    */
++/* distributed under the License is distributed on an "AS IS" BASIS,      */
++/* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or        */
++/* implied. See the License for the specific language governing           */
++/* permissions and limitations under the License.                         */
++/*                                                                        */
++/* IBM_PROLOG_END_TAG                                                     */
++
++#include <stdint.h>
++#include <string.h>
++#include <stdio.h>
++#include <stdlib.h>
++#include <getopt.h>
++
++#include <sstream>
++#include <iostream>
++#include <string>
++#include <algorithm>
++
++#include "IBM_Crypto.h"
++#include "IBM_Exception.h"
++#include "IBM_Container.h"
++#include "IBM_HexString.h"
++#include "IBM_Utils.h"
++
++namespace
++{
++    const static uint32_t s_SIGN_VERIFY_FAILURE = 0;
++    const static uint32_t s_SIGN_VERIFY_SUCCESS = 1;
++
++    static bool s_verbose = false;
++
++    // assume "development" build by default
++    static std::string s_mode = IBM_Utils::g_MODE_DEVELOPMENT;
++
++    static std::string s_output;
++
++    static std::string s_shaDigest;
++    static std::string s_signFileName;
++    static std::string s_pubkeyFileName;
++    static std::string s_privkeyOrProjName;
++
++    static std::string s_hashHdrType;
++    static std::string s_hashAlgo = "sha512";
++
++    // assume sign_agent running locally by default
++    static std::string s_saHostName = "127.0.0.1";
++
++    // sign_agent listens on port 8001 by default
++    static int s_saPortNum = 8001;
++
++    static std::string s_fldName;
++    static std::string s_fldValue;
++    static std::string s_imgFileName;
++
++    static std::string  s_PROGRAM_NAME;
++
++    const char* getProgramName()
++    {
++        return s_PROGRAM_NAME.c_str();
++    }
++
++    static std::string  s_VERSION = "1.0.0";
++
++    std::string getAppVersion(bool version)
++    {
++        std::string s_version;
++        if (version)
++        {
++            const char *pgmName = basename(s_PROGRAM_NAME.c_str()); 
++
++            s_version = std::string( pgmName ) + 
++                        " app Version " + s_VERSION + "\n" +
++                        "(C) Copyright IBM Corporation 2016" + "\n" +
++                        "built on " + __DATE__ + " " +  __TIME__ + "\n";
++        }
++        else
++        {   
++            s_version = s_VERSION;
++        }
++
++        return s_version;
++    }
++
++
++    //
++    //  Display the application usage.
++    //
++    void ShowUsage()
++    {
++        std::cout << std::endl;
++        std::cout << getAppVersion(true) << std::endl;
++        std::cout << "Options:" << std::endl;
++        std::cout << "   --help                    Signtool help."
++                  << std::endl;
++        std::cout << "   --version                 Signtool version."
++                  << std::endl;
++        std::cout << "   --verbose                 Print verbose messages."
++                  << std::endl << std::endl;
++        std::cout << "   --mode                    Signing mode 'production' or 'development'"
++                  << std::endl;
++        std::cout << "   --little-endian           Assume data storage is Little Endian."
++                  << std::endl << std::endl;
++        std::cout << "   --sign                    Sign the input data."
++                  << std::endl;
++        std::cout << "   --verify                  Verify the signature."
++                  << std::endl;
++        std::cout << "   --create_key              Create ECDSA 521 Key (PEM format)."
++                  << std::endl;
++        std::cout << "   --sigfile                 Output path for saving signature."
++                  << std::endl;
++        std::cout << "   --privkeyfile             Path name containing ECDSA private key."
++                  << std::endl;
++        std::cout << "   --pubkeyfile              Path name containing ECDSA public key."
++                  << std::endl;
++        std::cout << "   --digest                  digest string to be signed."
++                  << std::endl;
++        std::cout << "   --projname                Name of Signing project (production mode)."
++                  << std::endl;
++        std::cout << "   --sa_hostname             Hostname or IP Address of sign_agent."
++                  << std::endl;
++        std::cout << "   --sa_portnum              Port number of sign_agent."
++                  << std::endl << std::endl;
++        std::cout << "   --calchash                Calculate hash for the specified field type."
++                  << std::endl;
++        std::cout << "   --fldtype                 Field type, must be one of prefix_hdr or software_hdr."
++                  << std::endl;
++        std::cout << "   --hashalgo                hash algortihm to use sha1, sha256, sha384 or sha512, default is sha512."
++                  << std::endl << std::endl;
++        std::cout << "   --create-container        Create a default container."
++                  << std::endl;
++        std::cout << "   --imagefile               Path name for container operation."
++                  << std::endl;
++        std::cout << "   --print-container         Print the contents of container."
++                  << std::endl;
++        std::cout << "   --fldname                 Container field to change."
++                  << std::endl;
++        std::cout << "   --fldvalue                Value for specified container field."
++                  << std::endl << std::endl << std::endl;
++        std::cout << "   The following values are accepted for option <--fldname>" << std::endl;
++
++        IBM_Container junk(s_mode);
++
++        std::vector<std::string> fldNamesList;
++        junk.GetFieldNameList( fldNamesList );
++
++        for (uint32_t i = 0; i < fldNamesList.size(); i++)
++        {
++             std::cout << "          " << fldNamesList[i] << std::endl;
++        }
++        std::cout << std::endl << std::endl;
++    }
++
++    
++    static const int s_CMD_NONE(0x00);
++    static const int s_CMD_HELP(0x01);
++    static const int s_CMD_VERSION(0x02);
++    static const int s_CMD_SIGN(0x04);
++    static const int s_CMD_VERIFY(0x08);
++    static const int s_CMD_CREATE_KEY(0x10);
++    static const int s_CMD_PRINT_CONTAINER(0x20);
++    static const int s_CMD_CREATE_CONTAINER(0x40);
++    static const int s_CMD_UPD_CONTAINER_FLD(0x80);
++    static const int s_CMD_CALCULATE_HASH(0x100);
++
++    int ParseArguments( int argc, char* argv[] )
++    {
++        static const struct option longopts[] =
++        {
++            { "mode",                     required_argument, NULL, 'm' },
++
++            { "sign",                     no_argument,       NULL, 's' },
++            { "verify",                   no_argument,       NULL, 't' },
++            { "create_key",               no_argument,       NULL, 'u' },
++            { "projname",                 required_argument, NULL, 'N' },
++            { "sigfile",                  required_argument, NULL, 'S' },
++            { "pubkeyfile",               required_argument, NULL, 'K' },
++            { "privkeyfile",              required_argument, NULL, 'L' },
++            { "digest",                   required_argument, NULL, 'D' },
++            { "sa_hostname",              required_argument, NULL, 'H' },
++            { "sa_portnum",               required_argument, NULL, 'P' },
++
++            { "create-container",         no_argument,       NULL, 'c' },
++            { "print-container",          no_argument,       NULL, 'p' },
++            { "imagefile",                required_argument, NULL, 'I' },
++            { "fldname",                  required_argument, NULL, 'F' },
++            { "fldvalue",                 required_argument, NULL, 'V' },
++
++            { "calchash",                 no_argument,       NULL, 'd' },
++            { "fldtype",                  required_argument, NULL, 'T' },
++            { "hashalgo",                 required_argument, NULL, 'A' },
++
++            { "help",                     no_argument,       NULL, 'h' },
++            { "version",                  no_argument,       NULL, 'v' },
++            { "verbose",                  no_argument,       NULL, 'x' },
++
++            { NULL,                       0,                 NULL,  0  }
++        };
++
++
++        int startFlags = s_CMD_NONE;
++
++        int opt = 0;
++        int long_index=0;
++
++        while ((opt = getopt_long_only (argc, argv, "", longopts, &long_index)) != -1)
++        {
++            switch (opt)
++            {
++                case 'm':   // Production or Development Mode
++                {
++                    s_mode = std::string ( optarg );
++                    break;
++                }
++
++                case 's':   // Sign given digest
++                {
++                    startFlags = s_CMD_SIGN;
++                    break;
++                }
++
++                case 't':   // Verify signature, given digest, public key and signature
++                {
++                    startFlags = s_CMD_VERIFY;
++                    break;
++                }
++
++                case 'u':   // Create ec curve 521 Key
++                {
++                    startFlags = s_CMD_CREATE_KEY;
++                    break;
++                }
++
++                case 'N':   // Signing Project Name
++                case 'L':   // key filename for signing/verifying/create key operations
++                {
++                    s_privkeyOrProjName = std::string ( optarg );
++                    break;
++                }
++
++                case 'K':   // key filename for signing/verifying/create key operations
++                {
++                    s_pubkeyFileName = std::string ( optarg );
++                    break;
++                }
++
++                case 'S':   // signature filename for signing/verifying operations
++                {
++                    s_signFileName = std::string ( optarg );
++                    break;
++                }
++
++                case 'D':   // sha-256, sha-384 or sha-512 digest that needs to be signed
++                {
++                    s_shaDigest = std::string ( optarg );
++                    break;
++                }
++
++                case 'H':   // Hostname or IP Address of sign_agent
++                {
++                    s_saHostName = std::string ( optarg );
++                    break;
++                }
++
++                case 'P':   // Portnum of sign_agent
++                {
++                    s_saPortNum = atoi( optarg );
++                    break;
++                }
++
++                case 'c':
++                {
++                    startFlags = s_CMD_CREATE_CONTAINER;
++                    break;
++                }
++
++                case 'p':
++                {
++                    startFlags = s_CMD_PRINT_CONTAINER;
++                    break;
++                }
++
++                case 'I':
++                {
++                    s_imgFileName = std::string( optarg );
++                    break;
++                }
++
++                case 'F':
++                {
++                    startFlags = s_CMD_UPD_CONTAINER_FLD;
++
++                    s_fldName = std::string( optarg );
++                    break;
++                }
++
++                case 'V':
++                {
++                    s_fldValue = std::string( optarg );
++                    break;
++                }
++
++                case 'd':
++                {
++                    startFlags = s_CMD_CALCULATE_HASH;
++                    break;
++                }
++
++                case 'T':
++                {
++                    s_hashHdrType = std::string( optarg );
++                    break;
++                }
++
++                case 'A':
++                {
++                    s_hashAlgo = std::string( optarg );
++                    break;
++                }
++
++                case 'h':
++                {
++                    startFlags = s_CMD_HELP;
++                    break;
++                }
++
++                case 'v':
++                {
++                    startFlags = s_CMD_VERSION;
++                    break;
++                }
++
++                case 'x':   // --verbose
++                {
++                    s_verbose = true;
++                    break;
++                }
++
++                default:
++                {
++                    startFlags = -1;
++                    break;
++                }
++            }
++        }
++
++        return startFlags;
++    }
++}
++
++
++
++//
++//  Signtool.  Multi-purpose signature generation / validation utility.
++//
++
++int main ( int argc, char** argv )
++{
++    int rc = 0;
++
++    s_PROGRAM_NAME=argv[0];
++
++    int flags = ParseArguments( argc, argv );
++
++    if (flags < 0)
++    {
++        ShowUsage();
++        return 1;
++    }
++
++    if (flags == s_CMD_NONE)
++    {
++         std::cout << std::endl
++                   << "No operation specified, issue \""
++                   << basename(s_PROGRAM_NAME.c_str()) 
++                   << " --help\" for more info on usage." 
++                   << std::endl << std::endl;
++
++         return 2;
++    }
++    
++    if (flags & s_CMD_VERSION)
++    {
++        std::cout << getAppVersion( s_verbose ) << std::endl;
++        return 0;
++    }
++    else if (flags & s_CMD_HELP)
++    {
++        ShowUsage();
++        return 0;
++    }
++
++    try
++    {
++        if (flags & s_CMD_CREATE_CONTAINER)
++        {
++            if (s_imgFileName.size() == 0)
++            {
++                THROW_EXCEPTION_STR( "misssing --imagefile parameter." );
++            }
++
++            //  create a default container and save it in the specfied filename
++            IBM_Container contObj(s_mode);
++
++            THROW_EXCEPTION( contObj.Save( s_imgFileName ) == false );
++        }
++        else if (flags & s_CMD_UPD_CONTAINER_FLD)
++        {
++            if (s_imgFileName.size() == 0)
++            {
++                THROW_EXCEPTION_STR( "misssing --imagefile parameter." );
++            }
++ 
++            if (s_fldName.size() == 0)
++            {
++                THROW_EXCEPTION_STR( "missing --fldname parameter." );
++            }
++
++            if (s_fldValue.size() == 0)
++            {
++                THROW_EXCEPTION_STR( "missing --fldvalue parameter." );
++            }
++
++            // Open the container and update the specified field
++            IBM_Container contObj(s_mode, s_imgFileName);
++
++            THROW_EXCEPTION( contObj.UpdateField( s_fldName, s_fldValue ) == false );
++            THROW_EXCEPTION( contObj.Save( s_imgFileName ) == false );
++        }
++        else if (flags & s_CMD_PRINT_CONTAINER)
++        {
++            if (s_imgFileName.size() == 0)
++            {
++                THROW_EXCEPTION_STR( "misssing --imagefile parameter." );
++            }
++
++            // Open the container and print its contents
++            IBM_Container contObj(s_mode, s_imgFileName);
++
++            contObj.Print();
++        }
++        else if (flags & s_CMD_SIGN)
++        {
++            // construct the Crypto Object
++            IBM_Crypto crypto(s_mode);
++
++            if (s_privkeyOrProjName.size() == 0 )
++            {
++                THROW_EXCEPTION_STR( "missing --privkeyfile or --projname parameter." );
++            }
++
++            if (s_shaDigest.size() == 0)
++            {
++                THROW_EXCEPTION_STR( "missing --digest parameter." );
++            }
++
++            if (s_signFileName.size() == 0)
++            {
++                THROW_EXCEPTION_STR( "missing --sigfile paramater." );
++            }
++
++            //  send the request to sign and save the signature
++            //  in the specified filename
++            bool retVal = crypto.Sign( s_privkeyOrProjName,
++                                       s_shaDigest,
++                                       s_signFileName,
++                                       s_saHostName,
++                                       s_saPortNum );
++            THROW_EXCEPTION(retVal == false );
++        }
++        else if (flags & s_CMD_VERIFY)
++        {
++            // construct the Crypto Object
++            IBM_Crypto crypto(s_mode);
++
++            if (s_pubkeyFileName.size() == 0 )
++            {
++                THROW_EXCEPTION( "missing --pubkeyfile parameter." );
++            }
++
++            if (s_shaDigest.size() == 0)
++            {
++                THROW_EXCEPTION_STR( "missing --digest parameter." );
++            }
++
++            if (s_signFileName.size() == 0)
++            {
++                THROW_EXCEPTION_STR( "missing --sigfile paramater." );
++            }
++
++            //  Verify the signature
++            int status = crypto.Verify( s_pubkeyFileName,
++                                        s_shaDigest,
++                                        s_signFileName );
++
++            std::cout << "ECC Signature ";
++            switch (status)
++            {
++                case s_SIGN_VERIFY_SUCCESS:
++                {
++                    std::cout << "Verified OK";
++                    rc = 0;
++                    break;
++                }
++
++                case s_SIGN_VERIFY_FAILURE:
++                {
++                    std::cout << "Verification Failure";
++                    rc = 1;
++                    break;
++                }
++
++                default:
++                {
++                    std::cout << "encountered Openssl Error";
++                    rc = status;
++                    break;
++                }
++            }
++            std::cout << std::endl;
++        }
++        else if (flags & s_CMD_CREATE_KEY)
++        {
++            // construct the Crypto Object
++            IBM_Crypto crypto(s_mode);
++
++            if (s_pubkeyFileName.size() == 0 )
++            {
++                THROW_EXCEPTION_STR( "missing --pubkeyfile parameter." );
++            }
++
++            if (s_privkeyOrProjName.size() == 0 )
++            {
++                THROW_EXCEPTION_STR( "missing --privkeyfile parameter." );
++            }
++
++            //  Create the keypair and save them in the specfied
++            //  files in PEM foramt
++            THROW_EXCEPTION( crypto.CreateKeyPair( s_privkeyOrProjName, s_pubkeyFileName ) == false );
++        }
++        else if (flags & s_CMD_CALCULATE_HASH)
++        {
++            if (s_imgFileName.size() == 0)
++            {
++                THROW_EXCEPTION_STR( "misssing --imagefile parameter." );
++            }
++ 
++            if (s_hashHdrType.size() == 0)
++            {
++                THROW_EXCEPTION_STR( "missing --fldtype parameter." );
++            }
++
++            if (s_hashAlgo.size() == 0)
++            {
++                THROW_EXCEPTION_STR( "missing --hashalgo parameter." );
++            }
++
++            // calculate the hash of the requested field of the specfied container
++            // using the specified hash algoritm
++            IBM_Container contObj(s_mode, s_imgFileName);
++
++            std::string digestStr;
++
++            THROW_EXCEPTION( contObj.ComputeHash( s_hashHdrType, s_hashAlgo, digestStr ) == false );
++
++            std::cout << digestStr << std::endl;
++        }
++    }
++    catch ( IBM_Exception& e )
++    {
++        std::cout << e.what() << std::endl;
++        rc = 3;
++    }
++    
++    return rc;
++}
+-- 
+1.8.2.2
+
diff --git a/openpower/package/sb-signing-utils/sb-signing-utils.mk b/openpower/package/sb-signing-utils/sb-signing-utils.mk
new file mode 100644
index 0000000..6bbe3ab
--- /dev/null
+++ b/openpower/package/sb-signing-utils/sb-signing-utils.mk
@@ -0,0 +1,28 @@
+################################################################################
+#
+#  sb-signing-utils
+#
+################################################################################
+
+SB_SIGNING_UTILS_SITE ?= $(call github,open-power,sb-signing-utils,$(SB_SIGNING_UTILS_VERSION))
+SB_SIGNING_UTILS_VERSION ?= 6d0ba6519d719227daaeae96a3b00f0d953e3af1
+
+SB_SIGNING_UTILS_LICENSE = Apache-2.0
+SB_SIGNING_UTILS_LICENSE_FILES = LICENSE
+
+HOST_SB_SIGNING_UTILS_DEPENDENCIES = host-openssl
+
+HOST_SB_SIGNING_UTILS_AUTORECONF = YES
+
+SB_SIGNING_UTILS_KEY_SRC_PATH=$(BR2_EXTERNAL)/package/sb-signing-utils/keys
+SB_SIGNING_UTILS_KEY_DST_PATH=$(HOST_DIR)/etc/keys
+
+define COPY_KEYS_TO_DESTINATION
+	$(INSTALL) -d -m 0755 $(SB_SIGNING_UTILS_KEY_DST_PATH)
+	$(INSTALL) -m 0755 $(SB_SIGNING_UTILS_KEY_SRC_PATH)/* \
+		$(SB_SIGNING_UTILS_KEY_DST_PATH)
+endef
+
+HOST_SB_SIGNING_UTILS_POST_INSTALL_HOOKS += COPY_KEYS_TO_DESTINATION
+
+$(eval $(host-autotools-package))
-- 
1.8.2.2

