From f4ca5fb46a11c947cc1a334a6e846a9f8a8852cd Mon Sep 17 00:00:00 2001
From: Matt Ploetz <maploetz@us.ibm.com>
Date: Fri, 20 Feb 2015 10:59:29 -0600
Subject: [PATCH 01/10] Revert "Support for PNOR version string sections in
 openPOWER"

This reverts commit 3a15c8bd258a5cb61821b9325f214a47b8faffbf.
---
 src/include/usr/pnor/pnorif.H | 1 -
 src/usr/pnor/pnor_common.C    | 3 +--
 2 files changed, 1 insertion(+), 3 deletions(-)

diff --git a/src/include/usr/pnor/pnorif.H b/src/include/usr/pnor/pnorif.H
index 7229466..00f80f4 100644
--- a/src/include/usr/pnor/pnorif.H
+++ b/src/include/usr/pnor/pnorif.H
@@ -61,7 +61,6 @@ enum SectionId
     ATTR_TMP,       /**< Temporary Attribute Override */
     ATTR_PERM,      /**< Permanent Attribute Override */
     CAPP,           /**< CAPP lid */
-    VERSION,        /**< PNOR version string section */
     TEST,           /**< Scratch space for PNOR test cases */
     TESTRO,         /**< Scratch space for PNOR ReadOnly test cases */
 
diff --git a/src/usr/pnor/pnor_common.C b/src/usr/pnor/pnor_common.C
index c8c1e14..00931ec 100644
--- a/src/usr/pnor/pnor_common.C
+++ b/src/usr/pnor/pnor_common.C
@@ -66,8 +66,7 @@ const char* cv_EYECATCHER[] = {
     "FIRDATA",   /**< PNOR::FIRDATA        : FIRDATA */
     "ATTR_TMP",  /**< PNOR::ATTR_TMP       : Temporary Attribute Overrides */
     "ATTR_PERM", /**< PNOR::ATTR_PERM      : Permanent Attribute Overrides */
-    "CAPP",      /**< PNOR::CAPP           : CAPP LID */
-    "VERSION",   /**< PNOR::VERSION        : PNOR Version string */
+    "CAPP",      /**< PNOR::CAPP            : CAPP LID */
     "TEST",      /**< PNOR::TEST           : Test space for PNOR*/
     "TESTRO",    /**< PNOR::TESTRO         : ReadOnly Test space for PNOR */
     //Not currently used
-- 
1.8.2.2


From a67aea13a1a3227e47a782bb7a5b965f22c9524b Mon Sep 17 00:00:00 2001
From: Matt Ploetz <maploetz@us.ibm.com>
Date: Fri, 20 Feb 2015 10:59:41 -0600
Subject: [PATCH 02/10] Revert "Increasing size of HBRT to 3MB+ECC in
 defaultPnorLayout"

This reverts commit 110da83dad46fd3ac100bf60375ff1b7716114c9.
---
 src/build/buildpnor/defaultPnorLayout.xml | 10 +++++-----
 1 file changed, 5 insertions(+), 5 deletions(-)

diff --git a/src/build/buildpnor/defaultPnorLayout.xml b/src/build/buildpnor/defaultPnorLayout.xml
index adb04fd..18c309d 100644
--- a/src/build/buildpnor/defaultPnorLayout.xml
+++ b/src/build/buildpnor/defaultPnorLayout.xml
@@ -165,10 +165,10 @@ Layout Description
         <ecc/>
     </section>
     <section>
-        <description>Hostboot Runtime Services for Sapphire (3.375MB)</description>
+        <description>Hostboot Runtime Services for Sapphire (2.25MB)</description>
         <eyeCatch>HBRT</eyeCatch>
         <physicalOffset>0xA35000</physicalOffset>
-        <physicalRegionSize>0x360000</physicalRegionSize>
+        <physicalRegionSize>0x240000</physicalRegionSize>
         <sha512Version/>
         <side>sideless</side>
         <ecc/>
@@ -176,7 +176,7 @@ Layout Description
     <section>
         <description>Payload (22.5MB)</description>
         <eyeCatch>PAYLOAD</eyeCatch>
-        <physicalOffset>0xD95000</physicalOffset>
+        <physicalOffset>0xC75000</physicalOffset>
         <physicalRegionSize>0x1680000</physicalRegionSize>
         <side>sideless</side>
         <ecc/>
@@ -184,7 +184,7 @@ Layout Description
     <section>
         <description>Special PNOR Test Space (36K)</description>
         <eyeCatch>TEST</eyeCatch>
-        <physicalOffset>0x2415000</physicalOffset>
+        <physicalOffset>0x3590000</physicalOffset>
         <physicalRegionSize>0x9000</physicalRegionSize>
         <testonly/>
         <side>sideless</side>
@@ -193,7 +193,7 @@ Layout Description
     <section>
         <description>Special PNOR Test Space (36K)</description>
         <eyeCatch>TESTRO</eyeCatch>
-        <physicalOffset>0x241E000</physicalOffset>
+        <physicalOffset>0x3599000</physicalOffset>
         <physicalRegionSize>0x9000</physicalRegionSize>
         <side>sideless</side>
         <testonly/>
-- 
1.8.2.2


From 2a5e7bdd359976c1c87096fd78b21fa235a067f1 Mon Sep 17 00:00:00 2001
From: Matt Ploetz <maploetz@us.ibm.com>
Date: Fri, 20 Feb 2015 10:59:51 -0600
Subject: [PATCH 03/10] Revert "New interfaces to get FSI and PNOR info for
 Xstop code"

This reverts commit 79ea7abf6d31c146c680d39b9f3ae007e434a573.
---
 src/include/usr/fsi/fsiif.H   |  7 +---
 src/include/usr/pnor/pnorif.H | 16 --------
 src/usr/fsi/fsidd.C           | 31 ++++++---------
 src/usr/fsi/test/fsiddtest.H  | 92 +------------------------------------------
 src/usr/pnor/pnordd.C         | 33 ----------------
 src/usr/pnor/pnordd.H         | 16 +-------
 src/usr/pnor/sfcdd.H          | 11 +-----
 7 files changed, 16 insertions(+), 190 deletions(-)

diff --git a/src/include/usr/fsi/fsiif.H b/src/include/usr/fsi/fsiif.H
index 5ab2e44..756dbb7 100644
--- a/src/include/usr/fsi/fsiif.H
+++ b/src/include/usr/fsi/fsiif.H
@@ -5,9 +5,7 @@
 /*                                                                        */
 /* OpenPOWER HostBoot Project                                             */
 /*                                                                        */
-/* Contributors Listed Below - COPYRIGHT 2011,2015                        */
-/* [+] International Business Machines Corp.                              */
-/*                                                                        */
+/* COPYRIGHT International Business Machines Corp. 2011,2014              */
 /*                                                                        */
 /* Licensed under the Apache License, Version 2.0 (the "License");        */
 /* you may not use this file except in compliance with the License.       */
@@ -111,11 +109,10 @@ struct FsiLinkInfo_t
     uint8_t link; ///< Which link is this chip hanging off of
     uint8_t cascade; ///< Slave cascade position
     uint8_t mPort; ///< FSI Master port (0=A,1=B)
-    uint32_t baseAddr; ///< Base FSI Address for this chip
 
     FsiLinkInfo_t() :
       master(NULL), type(TARGETING::FSI_MASTER_TYPE_NO_MASTER),
-    link(0xFF), cascade(0), mPort(0), baseAddr(UINT32_MAX)
+    link(0xFF), cascade(0), mPort(0)
     {};
 };
 
diff --git a/src/include/usr/pnor/pnorif.H b/src/include/usr/pnor/pnorif.H
index 00f80f4..2689077 100644
--- a/src/include/usr/pnor/pnorif.H
+++ b/src/include/usr/pnor/pnorif.H
@@ -183,22 +183,6 @@ enum sbeSeepromSide_t
 errlHndl_t getSbeBootSeeprom(TARGETING::Target* i_target,
                              sbeSeepromSide_t& o_bootSide);
 
-
-/** Information about PNOR Layout */
-struct PnorInfo_t
-{
-    uint32_t mmioOffset; //< Address of MMIO access
-    uint32_t norWorkarounds; //< NOR flash workarounds
-    uint32_t flashSize; //< Size of PNOR in bytes
-};
-
-/**
- * @brief Retrieve some information about the PNOR/SFC hardware
- *
- * @param[out] o_pnorInfo Information about PNOR
- */
-void getPnorInfo( PnorInfo_t& o_pnorInfo );
-
 }
 
 #endif
diff --git a/src/usr/fsi/fsidd.C b/src/usr/fsi/fsidd.C
index 6e7ae8a..7f313aa 100644
--- a/src/usr/fsi/fsidd.C
+++ b/src/usr/fsi/fsidd.C
@@ -1806,15 +1806,15 @@ errlHndl_t FsiDD::genFullFsiAddr(FsiAddrInfo_t& io_addrInfo)
     //start off with the addresses being the same
     io_addrInfo.absAddr = io_addrInfo.relAddr;
 
-    //pull the FSI info out for this target
-    io_addrInfo.accessInfo = getFsiInfo( io_addrInfo.fsiTarg );
-
     //target matches master so the address is correct as-is
     if( io_addrInfo.fsiTarg == iv_master )
     {
         return NULL;
     }
 
+    //pull the FSI info out for this target
+    io_addrInfo.accessInfo = getFsiInfo( io_addrInfo.fsiTarg );
+
     TRACU1COMP( g_trac_fsi, "target=%.8X : Link Id=%.8X", TARGETING::get_huid(io_addrInfo.fsiTarg), io_addrInfo.accessInfo.linkid.id );
 
     //FSI master is the master proc, find the port
@@ -3011,26 +3011,17 @@ FsiDD::FsiChipInfo_t FsiDD::getFsiInfo( TARGETING::Target* i_target )
 void FsiDD::getFsiLinkInfo( TARGETING::Target* i_slave,
                             FSI::FsiLinkInfo_t& o_info )
 {
-    FsiAddrInfo_t addr_info( i_slave, 0x0 );
-    errlHndl_t tmp_err = genFullFsiAddr( addr_info );
-    if( tmp_err )
-    {
-        TRACFCOMP( g_trac_fsi, "Error getting FsiLinkInfo for %.8X", TARGETING::get_huid(i_slave) );
-        delete tmp_err;
-        return;
-    }
-
-    o_info.master = addr_info.accessInfo.master;
-    o_info.type = addr_info.accessInfo.type;
-    o_info.link = addr_info.accessInfo.port;
-    o_info.cascade = addr_info.accessInfo.cascade;
+    FsiChipInfo_t info = getFsiInfo( i_slave );
+    o_info.master = info.master;
+    o_info.type = info.type;
+    o_info.link = info.port;
+    o_info.cascade = info.cascade;
     o_info.mPort = 0;
-    if( addr_info.accessInfo.master
-        && (addr_info.accessInfo.master != iv_master )
-        && (getFsiInfo(addr_info.accessInfo.master).flagbits.flipPort) )
+    if( info.master
+        && (info.master != iv_master )
+        && (getFsiInfo(info.master).flagbits.flipPort) )
     {
         o_info.mPort = 1;
     }
-    o_info.baseAddr = addr_info.absAddr;
 }
 
diff --git a/src/usr/fsi/test/fsiddtest.H b/src/usr/fsi/test/fsiddtest.H
index ab409bc..5d6eaaa 100644
--- a/src/usr/fsi/test/fsiddtest.H
+++ b/src/usr/fsi/test/fsiddtest.H
@@ -5,9 +5,7 @@
 /*                                                                        */
 /* OpenPOWER HostBoot Project                                             */
 /*                                                                        */
-/* Contributors Listed Below - COPYRIGHT 2011,2015                        */
-/* [+] International Business Machines Corp.                              */
-/*                                                                        */
+/* COPYRIGHT International Business Machines Corp. 2011,2014              */
 /*                                                                        */
 /* Licensed under the Apache License, Version 2.0 (the "License");        */
 /* you may not use this file except in compliance with the License.       */
@@ -447,94 +445,6 @@ class FsiDDTest : public CxxTest::TestSuite
 
         TRACFCOMP( g_trac_fsi, "FsiDDTest::test_FFDC> Finish" );
     };
-
-    /**
-     * @brief FSI DD test - FSI Link Info
-     *        Spot check getFsiLinkInfo results
-     */
-    void test_getFsiLinkInfo(void)
-    {
-        TRACFCOMP( g_trac_fsi, "FsiDDTest::test_getFsiLinkInfo> Start" );
-
-        enum {
-            PROC0,
-            CENTAUR4,
-            NUM_TARGETS
-        };
-        TARGETING::Target* fsi_targets[NUM_TARGETS];
-        for( size_t x = 0; x < NUM_TARGETS; x++ )
-        {
-            fsi_targets[x] = NULL;
-        }
-
-        TARGETING::Target* fsi_target = NULL;
-
-        // master processor target
-        TARGETING::EntityPath epath(TARGETING::EntityPath::PATH_PHYSICAL);
-        epath.addLast(TARGETING::TYPE_SYS,0);
-        epath.addLast(TARGETING::TYPE_NODE,0);
-        epath.addLast(TARGETING::TYPE_PROC,0);
-        fsi_target = TARGETING::targetService().toTarget(epath);
-        fsi_targets[PROC0] = fsi_target;
-
-        // local centaur target (physical:sys-0/node-0/membuf-4)
-        epath.removeLast();
-        epath.addLast(TARGETING::TYPE_MEMBUF,4);
-        fsi_target = TARGETING::targetService().toTarget(epath);
-        fsi_targets[CENTAUR4] = fsi_target;
-
-
-
-        // loop through all of the targets we defined to
-        //  check the data
-        for( size_t x = 0; x < NUM_TARGETS; x++ )
-        {
-            if( fsi_targets[x] == NULL )
-            {
-                continue;
-            }
-
-            // Get the FSI port info for this target
-            TARGETING::FSI_MASTER_TYPE type =
-              fsi_targets[x]->getAttr<TARGETING::ATTR_FSI_MASTER_TYPE>();
-            uint8_t slave_port =
-              fsi_targets[x]->getAttr<TARGETING::ATTR_FSI_MASTER_PORT>();
-            TARGETING::EntityPath masterpath =
-              fsi_targets[x]->getAttr<TARGETING::ATTR_FSI_MASTER_CHIP>();
-            TARGETING::Target* master =
-              TARGETING::targetService().toTarget(masterpath);
-            uint8_t master_port = 0;
-            if( type != TARGETING::FSI_MASTER_TYPE_NO_MASTER )
-            {
-                master_port =
-                  master->getAttr<TARGETING::ATTR_FSI_MASTER_PORT>()+1;
-            }
-
-            TRACFCOMP( g_trac_fsi, "sport=%d, mport=%d, master=%.8X, type=%d",slave_port,master_port, TARGETING::get_huid(master), master_port);
-            // Compute the offset
-            //   CMFSI ports start at 0x040000 and increment by 0x008000
-            //   MFSI ports start at 0x080000 and increment by 0x080000
-            //    (local CMFSI ports have no MFSI offset)
-            uint32_t offset = (master_port * 0x080000);
-            if( type == TARGETING::FSI_MASTER_TYPE_CMFSI )
-            {
-                offset += ((slave_port * 0x008000) + 0x040000);
-            }
-
-            // Now call the interface we want to test
-            FSI::FsiLinkInfo_t linkinfo;
-            FSI::getFsiLinkInfo( fsi_targets[x], linkinfo );
-
-            // Compare the results
-            TRACFCOMP( g_trac_fsi, "FsiDDTest::test_getFsiLinkInfo> Data for %.8X: exp=%.6X, act=%.6X", TARGETING::get_huid(fsi_targets[x]), offset, linkinfo.baseAddr );
-            if( linkinfo.baseAddr != offset )
-            {
-                TS_FAIL( "FsiDDTest::test_getFsiLinkInfo> Mismatch for %.8X: exp=%.6X, act=%.6X", TARGETING::get_huid(fsi_targets[x]), offset, linkinfo.baseAddr );
-            }
-        }
-
-        TRACFCOMP( g_trac_fsi, "FsiDDTest::test_getFsiLinkInfo> End" );
-    }
 };     
 
 
diff --git a/src/usr/pnor/pnordd.C b/src/usr/pnor/pnordd.C
index 13667ce..0d47898 100644
--- a/src/usr/pnor/pnordd.C
+++ b/src/usr/pnor/pnordd.C
@@ -191,19 +191,6 @@ bool usingL3Cache()
     return Singleton<PnorDD>::instance().usingL3Cache();
 }
 
-/**
- * @brief Retrieve some information about the PNOR/SFC hardware
- */
-void getPnorInfo( PnorInfo_t& o_pnorInfo )
-{
-    o_pnorInfo.mmioOffset = 0; //LPC_SFC_MMIO_OFFSET;//@fixme-need Prachi's code for this
-    o_pnorInfo.norWorkarounds =
-      Singleton<PnorDD>::instance().getNorWorkarounds();
-    o_pnorInfo.flashSize =
-      Singleton<PnorDD>::instance().getNorSize();
-}
-
-
 
 // Register PNORDD access functions to DD framework
 DEVICE_REGISTER_ROUTE(DeviceFW::READ,
@@ -878,23 +865,3 @@ errlHndl_t PnorDD::_eraseFlash( uint32_t i_addr )
 
     return l_err;
 }
-
-/**
- * @brief Retrieve bitstring of NOR workarounds
- */
-uint32_t PnorDD::getNorWorkarounds( void )
-{
-    return iv_sfc->getNorWorkarounds();
-}
-
-/**
- * @brief Retrieve size of NOR flash
- */
-uint32_t PnorDD::getNorSize( void )
-{
-#ifdef CONFIG_PNOR_IS_32MB
-    return (32*MEGABYTE);
-#else //default to 64MB
-    return (64*MEGABYTE);
-#endif
-}
diff --git a/src/usr/pnor/pnordd.H b/src/usr/pnor/pnordd.H
index 94c393b..589f60e 100644
--- a/src/usr/pnor/pnordd.H
+++ b/src/usr/pnor/pnordd.H
@@ -5,7 +5,7 @@
 /*                                                                        */
 /* OpenPOWER HostBoot Project                                             */
 /*                                                                        */
-/* Contributors Listed Below - COPYRIGHT 2011,2015                        */
+/* Contributors Listed Below - COPYRIGHT 2011,2014                        */
 /* [+] Google Inc.                                                        */
 /* [+] International Business Machines Corp.                              */
 /*                                                                        */
@@ -82,19 +82,6 @@ class PnorDD
     bool usingL3Cache( );
 
 
-    /**
-     * @brief Retrieve bitstring of NOR workarounds
-     * @return NOR workarounds (see VendorWorkarounds in norflash.H)
-     */
-    uint32_t getNorWorkarounds( void );
-
-    /**
-     * @brief Retrieve size of NOR flash
-     * @return Size of PNOR in bytes
-     */
-    uint32_t getNorSize( void );
-
-
     // Enumeration values must match those in debug framework.
     enum PnorMode_t {
         MODEL_UNKNOWN,   /**< Invalid */
@@ -353,7 +340,6 @@ class PnorDD
      */
     errlHndl_t _eraseFlash( uint32_t i_address );
 
-
   private: // Variables
 
    /**
diff --git a/src/usr/pnor/sfcdd.H b/src/usr/pnor/sfcdd.H
index 72285f5..7c27a1e 100644
--- a/src/usr/pnor/sfcdd.H
+++ b/src/usr/pnor/sfcdd.H
@@ -5,7 +5,7 @@
 /*                                                                        */
 /* OpenPOWER HostBoot Project                                             */
 /*                                                                        */
-/* Contributors Listed Below - COPYRIGHT 2014,2015                        */
+/* Contributors Listed Below - COPYRIGHT 2014                             */
 /* [+] Google Inc.                                                        */
 /* [+] International Business Machines Corp.                              */
 /*                                                                        */
@@ -149,15 +149,6 @@ class SfcDD
     };
 
     /**
-     * @brief Retrieve bitstring of NOR workarounds
-     * @return NOR workarounds (see VendorWorkarounds in norflash.H)
-     */
-    uint32_t getNorWorkarounds( void )
-    {
-        return iv_flashWorkarounds;
-    };
-
-    /**
      * @brief Destructor
      */
     virtual ~SfcDD();
-- 
1.8.2.2


From d54db81391beca781b7a5e4f233dea8971ced5c7 Mon Sep 17 00:00:00 2001
From: Matt Ploetz <maploetz@us.ibm.com>
Date: Fri, 20 Feb 2015 11:00:00 -0600
Subject: [PATCH 04/10] Revert "Skipping over readTOC if hostInterface for
 pnor_read/write doesn't exist"

This reverts commit 7c5d303237f2bec25b7072ec3119d6d4fef875fc.
---
 src/usr/pnor/runtime/rt_pnor.C            | 50 ++++++++++++++-----------------
 src/usr/util/runtime/test/testlidmgr_rt.H |  7 ++---
 2 files changed, 26 insertions(+), 31 deletions(-)

diff --git a/src/usr/pnor/runtime/rt_pnor.C b/src/usr/pnor/runtime/rt_pnor.C
index f616e98..c61aa1d 100644
--- a/src/usr/pnor/runtime/rt_pnor.C
+++ b/src/usr/pnor/runtime/rt_pnor.C
@@ -588,35 +588,31 @@ errlHndl_t RtPnor::readTOC ()
             break;
         }
 
-        if (g_hostInterfaces && g_hostInterfaces->pnor_read)
+        // @TODO RTC:120733
+        // RT code needs a way to get the active side tocs vs just defaulting
+        // to SIDE_A
+        l_err = readFromDevice (l_procId, PNOR::TOC, PNOR::SIDE_A_TOC_0_OFFSET,
+                PAGESIZE,false,toc0Buffer);
+        if (l_err)
         {
-            //@TODO RTC:120733
-            //RT code needs a way to get the active side tocs vs just defaulting
-            //to SIDE_A
-            l_err = readFromDevice(l_procId,PNOR::TOC,PNOR::SIDE_A_TOC_0_OFFSET,
-                    PAGESIZE,false,toc0Buffer);
-            if (l_err)
-            {
-                TRACFCOMP(g_trac_pnor,"RtPnor::readTOC:readFromDevice failed"
-                          " for TOC0");
-                break;
-            }
-
-            l_err = readFromDevice(l_procId,PNOR::TOC,PNOR::SIDE_A_TOC_1_OFFSET,
-                    PAGESIZE, false,toc1Buffer);
-            if (l_err)
-            {
-                TRACFCOMP(g_trac_pnor, "RtPnor::readTOC:readFromDevice failed"
-                          " for TOC1");
-                break;
-            }
+            TRACFCOMP(g_trac_pnor,"RtPnor::readTOC:readFromDevice failed"
+                      " for TOC0");
+            break;
+        }
+        l_err = readFromDevice (l_procId, PNOR::TOC, PNOR::SIDE_A_TOC_1_OFFSET,
+                PAGESIZE, false,toc1Buffer);
+        if (l_err)
+        {
+            TRACFCOMP(g_trac_pnor, "RtPnor::readTOC:readFromDevice failed"
+                      " for TOC1");
+            break;
+        }
 
-            l_err = PNOR::parseTOC(toc0Buffer,toc1Buffer,iv_TOC_used,iv_TOC,0);
-            if (l_err)
-            {
-                TRACFCOMP(g_trac_pnor, "RtPnor::readTOC: parseTOC failed");
-                break;
-            }
+        l_err = PNOR::parseTOC(toc0Buffer, toc1Buffer, iv_TOC_used, iv_TOC, 0);
+        if (l_err)
+        {
+            TRACFCOMP(g_trac_pnor, "RtPnor::readTOC: parseTOC failed");
+            break;
         }
     } while (0);
 
diff --git a/src/usr/util/runtime/test/testlidmgr_rt.H b/src/usr/util/runtime/test/testlidmgr_rt.H
index d869e3c..4514684 100644
--- a/src/usr/util/runtime/test/testlidmgr_rt.H
+++ b/src/usr/util/runtime/test/testlidmgr_rt.H
@@ -26,7 +26,6 @@
 #include <cxxtest/TestSuite.H>
 #include <errl/errlmanager.H>
 #include <utilbase.H>
-#include <config.h>
 
 class LidMgrRtTest : public CxxTest::TestSuite
 {
@@ -65,11 +64,11 @@ class LidMgrRtTest : public CxxTest::TestSuite
 
                 PNOR::SectionInfo_t l_lidPnorInfo;
                 l_errl = PNOR::getSectionInfo(PNOR::TEST, l_lidPnorInfo);
+                // Section only present in openPOWER systems
                 if (l_errl)
                 {
-                    errlCommit(l_errl,UTIL_COMP_ID);
-                    TS_FAIL("testLidInPnor: Error getting lidId=0x%.8x",
-                            Util::TEST_LIDID);
+                    delete l_errl;
+                    l_errl = NULL;
                     break;
                 }
 
-- 
1.8.2.2


From 6ee93d64558e1d536cc10cd47fef5ce33416a288 Mon Sep 17 00:00:00 2001
From: Matt Ploetz <maploetz@us.ibm.com>
Date: Fri, 20 Feb 2015 11:04:00 -0600
Subject: [PATCH 05/10] Revert "Support BIOS framework"

This reverts commit b24f1ca24db62f833c7f46e4244dbe8f00ee8a4c.
---
 src/build/mkrules/dist.targets.mk                  |    2 -
 src/usr/targeting/common/xmltohb/bios.xsd          |  302 ------
 .../common/xmltohb/bios_metadata_petitboot.xslt    |   93 --
 src/usr/targeting/common/xmltohb/xmltohb.pl        | 1030 +-------------------
 4 files changed, 3 insertions(+), 1424 deletions(-)
 delete mode 100644 src/usr/targeting/common/xmltohb/bios.xsd
 delete mode 100644 src/usr/targeting/common/xmltohb/bios_metadata_petitboot.xslt

diff --git a/src/build/mkrules/dist.targets.mk b/src/build/mkrules/dist.targets.mk
index 42a1525..ca28150 100644
--- a/src/build/mkrules/dist.targets.mk
+++ b/src/build/mkrules/dist.targets.mk
@@ -81,8 +81,6 @@ COPY_FILES = \
     src/usr/targeting/common/xmltohb/target_types_hb.xml:openpower \
     src/usr/targeting/common/xmltohb/xmltohb.pl:openpower \
     src/include/usr/vmmconst.h:openpower \
-    src/usr/targeting/common/xmltohb/bios.xsd:openpower \
-    src/usr/targeting/common/xmltohb/bios_metadata_petitboot.xslt:openpower \
     $(foreach file, $(call ROOTPATH_WILDCARD,releaseNotes.html), $(file):fsp)\
 
 #
diff --git a/src/usr/targeting/common/xmltohb/bios.xsd b/src/usr/targeting/common/xmltohb/bios.xsd
deleted file mode 100644
index 6cd7ff4..0000000
--- a/src/usr/targeting/common/xmltohb/bios.xsd
+++ /dev/null
@@ -1,302 +0,0 @@
-<?xml version="1.0" encoding="utf-8"?>
-<!-- IBM_PROLOG_BEGIN_TAG                                                   -->
-<!-- This is an automatically generated prolog.                             -->
-<!--                                                                        -->
-<!-- $Source: src/usr/targeting/common/xmltohb/bios.xsd $                   -->
-<!--                                                                        -->
-<!-- OpenPOWER HostBoot Project                                             -->
-<!--                                                                        -->
-<!-- Contributors Listed Below - COPYRIGHT 2015                             -->
-<!-- [+] International Business Machines Corp.                              -->
-<!--                                                                        -->
-<!--                                                                        -->
-<!-- Licensed under the Apache License, Version 2.0 (the "License");        -->
-<!-- you may not use this file except in compliance with the License.       -->
-<!-- You may obtain a copy of the License at                                -->
-<!--                                                                        -->
-<!--     http://www.apache.org/licenses/LICENSE-2.0                         -->
-<!--                                                                        -->
-<!-- Unless required by applicable law or agreed to in writing, software    -->
-<!-- distributed under the License is distributed on an "AS IS" BASIS,      -->
-<!-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or        -->
-<!-- implied. See the License for the specific language governing           -->
-<!-- permissions and limitations under the License.                         -->
-<!--                                                                        -->
-<!-- IBM_PROLOG_END_TAG                                                     -->
-
-<xs:schema
-    xmlns:xs="http://www.w3.org/2001/XMLSchema" >
-
-  <xs:element name="firmware-overrides">
-    <xs:annotation>
-      <xs:documentation>The firmware-overrides element is the root element.  An
-        empty firmware-overrides element implies there are no firmware overrides
-        for a given platform.  The firmware-overrides element can have any
-        number of attribute or group elements.
-      </xs:documentation>
-    </xs:annotation>
-    <xs:complexType>
-      <xs:sequence>
-        <xs:choice minOccurs="0" maxOccurs="unbounded">
-          <xs:element ref="group"/>
-          <xs:element ref="attribute"/>
-        </xs:choice>
-      </xs:sequence>
-    </xs:complexType>
-  </xs:element>
-
-  <xs:element name="group">
-    <xs:annotation>
-      <xs:documentation>A group element defines a logical collection of
-        firmware-overrides, and sub-groups of the same.  A group element
-        contains a name element and any number of attribute + group elements,
-        but it must have at least one element other than the name element.
-  </xs:documentation>
-    </xs:annotation>
-    <xs:complexType>
-      <xs:sequence>
-        <xs:element ref="name"/>
-        <xs:sequence>
-          <xs:choice maxOccurs="unbounded">
-            <xs:element ref="group"/>
-            <xs:element ref="attribute"/>
-          </xs:choice>
-        </xs:sequence>
-      </xs:sequence>
-    </xs:complexType>
-  </xs:element>
-
-  <xs:element name="attribute">
-    <xs:annotation>
-      <xs:documentation>An attribute element must have an id element, and up to
-        one each of a description element, display-name element,
-        targetRestriction element.  It may also have either a numericOverride
-        element (if signed/unsigned number) or enumerationOverride element (if
-        enumeration), in that order.
-      </xs:documentation>
-    </xs:annotation>
-    <xs:complexType>
-      <xs:sequence>
-        <xs:element ref="id"/>
-        <xs:element ref="description" minOccurs="0"/>
-        <xs:element ref="display-name" minOccurs="0"/>
-        <xs:element ref="targetRestriction" minOccurs="0"/>
-        <xs:choice minOccurs="0">
-          <xs:element ref="enumerationOverride" minOccurs="0"/>
-          <xs:element ref="numericOverride" minOccurs="0"/>
-        </xs:choice>
-      </xs:sequence>
-    </xs:complexType>
-  </xs:element>
-
-  <xs:element name="numericOverride">
-    <xs:annotation>
-      <xs:documentation>A numeric override limits the set of values an
-        attribute can be set to.  A numericOverride element must have a start
-        and end element in any order.
-      </xs:documentation>
-    </xs:annotation>
-    <xs:complexType>
-      <xs:choice>
-        <xs:sequence>
-          <xs:element ref="start" minOccurs="1" maxOccurs="1"/>
-          <xs:element ref="end" minOccurs="0" maxOccurs="1"/>
-        </xs:sequence>
-        <xs:sequence>
-          <xs:element ref="end" minOccurs="1" maxOccurs="1"/>
-          <xs:element ref="start" minOccurs="0" maxOccurs="1"/>
-        </xs:sequence>
-      </xs:choice>
-    </xs:complexType>
-  </xs:element>
-
-  <xs:element name="targetRestriction">
-    <xs:annotation>
-      <xs:documentation>A target restriction restricts the attribute to apply
-         only to the target indicated by the sub-restrictions.  A
-         targetRestriction element may have up to one each of
-         a type, node, position, and unit element, in any order, provided at
-         least one of those appears.  This schema cannot easily restrict the
-         latter condition, so the code must ensure at least one child element is
-         present.
-      </xs:documentation>
-    </xs:annotation>
-    <xs:complexType>
-       <xs:all minOccurs="0" maxOccurs="1">
-         <xs:element ref="type"     minOccurs="0"/>
-         <xs:element ref="node"     minOccurs="0"/>
-         <xs:element ref="position" minOccurs="0"/>
-         <xs:element ref="unit"     minOccurs="0"/>
-       </xs:all>
-    </xs:complexType>
-  </xs:element>
-
-  <xs:element name="enumerationOverride">
-    <xs:annotation>
-      <xs:documentation>An enumerationOverride allows an attribute to change
-        the behavior of the underlying enumeration.  An enumerationOverride
-        element can have one allowedEnumerator element, any number of
-        enumeratorOverride elements, or a union of those.
-      </xs:documentation>
-    </xs:annotation>
-    <xs:complexType>
-      <xs:choice>
-        <xs:sequence>
-          <xs:element ref="allowedEnumerators"/>
-          <xs:element ref="enumeratorOverride"
-            minOccurs="0" maxOccurs="unbounded"/>
-        </xs:sequence>
-        <xs:sequence>
-          <xs:element ref="enumeratorOverride" maxOccurs="unbounded"/>
-          <xs:element ref="allowedEnumerators" minOccurs="0"/>
-        </xs:sequence>
-      </xs:choice>
-    </xs:complexType>
-  </xs:element>
-
-  <xs:element name="allowedEnumerators">
-    <xs:annotation>
-      <xs:documentation>An allowedEnumerator restricts which enumerators can be
-        used by the attribute.An allowedEnumerators element requires one or more
-        name elements.
-      </xs:documentation>
-    </xs:annotation>
-    <xs:complexType>
-      <xs:sequence>
-        <xs:element ref="name" maxOccurs="unbounded"/>
-      </xs:sequence>
-    </xs:complexType>
-  </xs:element>
-
-  <xs:element name="enumeratorOverride">
-    <xs:annotation>
-      <xs:documentation>An enumeratorOverride allows an attribute to change the
-        default text associated with an enumerator.  An enumeratorOverride
-        requires a name element and a display-name element, descriptionElement,
-        or union of both.
-      </xs:documentation>
-    </xs:annotation>
-    <xs:complexType>
-      <xs:sequence>
-        <xs:element ref="name"/>
-        <xs:choice>
-          <xs:sequence>
-            <xs:element ref="display-name"/>
-            <xs:element ref="description" minOccurs="0"/>
-          </xs:sequence>
-          <xs:sequence>
-            <xs:element ref="description"/>
-            <xs:element ref="display-name" minOccurs="0"/>
-          </xs:sequence>
-        </xs:choice>
-      </xs:sequence>
-    </xs:complexType>
-  </xs:element>
-
-  <xs:element name="id" type="xs:string">
-    <xs:annotation>
-      <xs:documentation>An id element provides a symbolic attribute ID that maps
-        to a valid attribute in targeting
-      </xs:documentation>
-    </xs:annotation>
-  </xs:element>
-
-  <xs:element name="description" type="xs:string">
-    <xs:annotation>
-      <xs:documentation>A description element provides a longer help text for an
-        attribute, enumeration, etc.
-      </xs:documentation>
-    </xs:annotation>
-  </xs:element>
-
-  <xs:element name="display-name" type="xs:string">
-    <xs:annotation>
-      <xs:documentation>A display-name element provides a short name for an
-        enumeration, attribute, etc.
-      </xs:documentation>
-    </xs:annotation>
-  </xs:element>
-
-  <xs:element name="type" type="xs:string">
-    <xs:annotation>
-      <xs:documentation>A type element restricts the attribute to a specific
-        named attribute type.
-      </xs:documentation>
-    </xs:annotation>
-  </xs:element>
-
-  <xs:element name="start" type="xs:decimal">
-    <xs:annotation>
-      <xs:documentation>A start element gives the first value, inclusive, of one
-        of the valid ranges for a numerical attribute. It cannot fall outside
-        of the base range allowed for the given attribute type, and must be at
-        least one less than the max of the base range.
-      </xs:documentation>
-    </xs:annotation>
-  </xs:element>
-
-  <xs:element name="end" type="xs:decimal">
-    <xs:annotation>
-      <xs:documentation>An end element gives the last value, inclusive, of one
-        of the valid ranges for a numerical attribute. It cannot fall outside
-        of the base range allowed for the given attribute type, and must be at
-        least one less than the max of the base range.
-      </xs:documentation>
-    </xs:annotation>
-  </xs:element>
-
-  <xs:element name="name" type="xs:string">
-    <xs:annotation>
-      <xs:documentation>A name element gives the name of the attribute group,
-        etc.
-      </xs:documentation>
-    </xs:annotation>
-  </xs:element>
-
-  <xs:element name="unit">
-    <xs:annotation>
-      <xs:documentation>A unit element allows an attribute to restrict its
-        scope to a specific target unit.  If a position element is specified in
-        a targetRestriction along with a unit, then the unit's chip's position
-        must match that as well.
-      </xs:documentation>
-    </xs:annotation>
-    <xs:simpleType>
-      <xs:restriction base="xs:unsignedByte">
-        <xs:minInclusive value="0"/>
-        <xs:maxInclusive value="254"/>
-      </xs:restriction>
-    </xs:simpleType>
-  </xs:element>
-
-  <xs:element name="position">
-    <xs:annotation>
-      <xs:documentation>A position element allows an attribute to restrict
-        its scope to a specific position.  Only applicable for targets with
-        positions, unless used in conjuction with the unit element.
-      </xs:documentation>
-    </xs:annotation>
-    <xs:simpleType>
-      <xs:restriction base="xs:unsignedShort">
-        <xs:minInclusive value="0"/>
-        <xs:maxInclusive value="65534"/>
-      </xs:restriction>
-    </xs:simpleType>
-  </xs:element>
-
-  <xs:element name="node">
-    <xs:annotation>
-      <xs:documentation>A node element allows an attribute to restrict
-        its scope to a specific node.
-      </xs:documentation>
-    </xs:annotation>
-    <xs:simpleType>
-      <xs:restriction base="xs:unsignedByte">
-        <xs:minInclusive value="0"/>
-        <xs:maxInclusive value="14"/>
-      </xs:restriction>
-    </xs:simpleType>
-  </xs:element>
-
-</xs:schema>
-
diff --git a/src/usr/targeting/common/xmltohb/bios_metadata_petitboot.xslt b/src/usr/targeting/common/xmltohb/bios_metadata_petitboot.xslt
deleted file mode 100644
index ee2a2bc..0000000
--- a/src/usr/targeting/common/xmltohb/bios_metadata_petitboot.xslt
+++ /dev/null
@@ -1,93 +0,0 @@
-<?xml version="1.0"?>
-<!-- IBM_PROLOG_BEGIN_TAG                                                   -->
-<!-- This is an automatically generated prolog.                             -->
-<!--                                                                        -->
-<!-- $Source: src/usr/targeting/common/xmltohb/bios_metadata_petitboot.xslt $ -->
-<!--                                                                        -->
-<!-- OpenPOWER HostBoot Project                                             -->
-<!--                                                                        -->
-<!-- Contributors Listed Below - COPYRIGHT 2015                             -->
-<!-- [+] International Business Machines Corp.                              -->
-<!--                                                                        -->
-<!--                                                                        -->
-<!-- Licensed under the Apache License, Version 2.0 (the "License");        -->
-<!-- you may not use this file except in compliance with the License.       -->
-<!-- You may obtain a copy of the License at                                -->
-<!--                                                                        -->
-<!--     http://www.apache.org/licenses/LICENSE-2.0                         -->
-<!--                                                                        -->
-<!-- Unless required by applicable law or agreed to in writing, software    -->
-<!-- distributed under the License is distributed on an "AS IS" BASIS,      -->
-<!-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or        -->
-<!-- implied. See the License for the specific language governing           -->
-<!-- permissions and limitations under the License.                         -->
-<!--                                                                        -->
-<!-- IBM_PROLOG_END_TAG                                                     -->
-
-<xsl:stylesheet version="1.0"
-  xmlns:xsl="http://www.w3.org/1999/XSL/Transform">
-
-<xsl:output method="xml" version="1.0"
-  encoding="UTF-8" indent="yes"/>
-
-<xsl:template match="/">
-  <firmware-overrides>
-    <xsl:apply-templates select="firmware-overrides/attribute"/>
-    <xsl:apply-templates select="firmware-overrides/group"/>
-  </firmware-overrides>
-</xsl:template>
-
-<xsl:template match="attribute">
-  <attribute>
-    <xsl:attribute name="id">
-      <xsl:value-of select="id"/>
-    </xsl:attribute>
-    <numeric-id><xsl:value-of select="numeric-id"/></numeric-id>
-    <type>
-        <size><xsl:value-of select="size"/></size>
-        <encoding><xsl:value-of select="encoding"/></encoding>
-    </type>
-    <default><xsl:value-of select="default"/></default>
-    <display-name><xsl:value-of select="display-name"/></display-name>
-    <description><xsl:value-of select="description"/></description>
-    <target>
-      <type><xsl:value-of select="target/type"/></type>
-      <node><xsl:value-of select="target/node"/></node>
-      <position><xsl:value-of select="target/position"/></position>
-      <unit><xsl:value-of select="target/unit"/></unit>
-    </target>
-    <xsl:apply-templates select="numericOverride"/>
-    <xsl:apply-templates select="enumeration"/>
-  </attribute>
-</xsl:template>
-
-<xsl:template match="numericOverride">
-  <range>
-    <start><xsl:value-of select="start"/></start>
-    <end><xsl:value-of select="end"/></end>
-  </range>
-</xsl:template>
-
-<xsl:template match="enumeration">
-  <enumeration>
-    <xsl:apply-templates select="./enumerator"/>
-  </enumeration>
-</xsl:template>
-
-<xsl:template match="enumerator">
-  <enumerator>
-    <display-name><xsl:value-of select="display-name"/></display-name>
-    <description><xsl:value-of select="description"/></description>
-    <value><xsl:value-of select="value"/></value>
-  </enumerator>
-</xsl:template>
-
-<xsl:template match="group">
-  <group>
-    <name><xsl:value-of select="name"/></name>
-    <xsl:apply-templates select="./attribute"/>
-    <xsl:apply-templates select="./group"/>
-  </group>
-</xsl:template>
-
-</xsl:stylesheet>
diff --git a/src/usr/targeting/common/xmltohb/xmltohb.pl b/src/usr/targeting/common/xmltohb/xmltohb.pl
index 6e8db84..d02c1a7 100755
--- a/src/usr/targeting/common/xmltohb/xmltohb.pl
+++ b/src/usr/targeting/common/xmltohb/xmltohb.pl
@@ -48,7 +48,6 @@ use Text::Wrap;
 use Data::Dumper;
 use POSIX;
 use Env;
-use XML::LibXML;
 
 ################################################################################
 # Set PREFERRED_PARSER to XML::Parser. Otherwise it uses XML::SAX which contains
@@ -77,10 +76,6 @@ my $cfgIncludeFspAttributes = 0;
 my $CfgSMAttrFile = "";
 my $cfgAddVersionPage = 0;
 
-my $cfgBiosXmlFile = undef;
-my $cfgBiosSchemaFile = undef;
-my $cfgBiosOutputFile = undef;
-
 GetOptions("hb-xml-file:s" => \$cfgHbXmlFile,
            "src-output-dir:s" =>  \$cfgSrcOutputDir,
            "img-output-dir:s" =>  \$cfgImgOutputDir,
@@ -92,9 +87,6 @@ GetOptions("hb-xml-file:s" => \$cfgHbXmlFile,
            "smattr-output-file:s" => \$CfgSMAttrFile,
            "include-fsp-attributes!" =>  \$cfgIncludeFspAttributes,
            "version-page!" => \$cfgAddVersionPage,
-           "bios-xml-file:s" => \$cfgBiosXmlFile,
-           "bios-schema-file:s" => \$cfgBiosSchemaFile,
-           "bios-output-file:s" => \$cfgBiosOutputFile,
            "help" => \$cfgHelp,
            "man" => \$cfgMan,
            "verbose" => \$cfgVerbose ) || pod2usage(-verbose => 0);
@@ -124,9 +116,6 @@ if($cfgVerbose)
     print STDOUT "Big endian = $cfgBigEndian\n";
     print STDOUT "include-fsp-attributes = $cfgIncludeFspAttributes\n",
     print STDOUT "version-page = $cfgAddVersionPage\n",
-    print STDOUT "bios-schema-file = $cfgBiosSchemaFile\n";
-    print STDOUT "bios-xml-file = $cfgBiosXmlFile\n";
-    print STDOUT "bios-output-file = $cfgBiosOutputFile\n";
 }
 
 ################################################################################
@@ -151,11 +140,6 @@ my @associationTypes = ( PARENT_BY_CONTAINMENT,
 use constant ATTR_PHYS_PATH => "PHYS_PATH";
 use constant ATTR_AFFINITY_PATH => "AFFINITY_PATH";
 use constant ATTR_UNKNOWN => "UnknownAttributeName";
-use constant ATTR_POSITION => "POSITION";
-use constant ATTR_CHIP_UNIT => "CHIP_UNIT";
-use constant ATTR_CLASS => "CLASS";
-use constant ATTR_TYPE => "TYPE";
-use constant ATTR_MODEL => "MODEL";
 
 # Data manipulation constants
 use constant BITS_PER_BYTE => 8;
@@ -475,7 +459,6 @@ sub validateAttributes {
                              = { required => 0, isscalar => 0};
     $elements{"hwpfToHbAttrMap"}
                              = { required => 0, isscalar => 0};
-    $elements{"display-name"} = { required => 0, isscalar => 1};
 
     foreach my $attribute (@{$attributes->{attribute}})
     {
@@ -5267,10 +5250,6 @@ sub generateTargetingImage {
     my $pnorRoOffset = $offset;
     my $attributesWritten = 0;
 
-    my %biosData = ();
-    my %attributeDefCache =
-        map { $_->{id} => $_} @{$attributes->{attribute}};
-
     foreach my $targetInstance (@targetsAoH)
     {
         my $data;
@@ -5306,6 +5285,9 @@ sub generateTargetingImage {
         # themselves FSP specific.  Only need to do this 1x per target instance
         my $fspTarget = isFspTargetInstance($attributes,$targetInstance);
 
+        my %attributeDefCache =
+            map { $_->{id} => $_} @{$attributes->{attribute}};
+
         # Must have the same order as the attribute list from above.
         for my $attributeId
             (sort
@@ -5322,20 +5304,6 @@ sub generateTargetingImage {
                     $attrhash{$attributeId}->{default};
             }
 
-            # Cache these attributes away in the BIOS data structure as
-            # identifying information that will be used to enforce the target
-            # restrictions
-            if(    ($attributeId eq ATTR_PHYS_PATH)
-                || ($attributeId eq ATTR_POSITION )
-                || ($attributeId eq ATTR_CHIP_UNIT)
-                || ($attributeId eq ATTR_CLASS    )
-                || ($attributeId eq ATTR_TYPE     )
-                || ($attributeId eq ATTR_MODEL    ) )
-            {
-                $biosData{$targetInstance->{id}}{_identity_}{$attributeId} =
-                     $attrhash{$attributeId}->{default};
-            }
-
             my $attrValue =
             enumNameToValue($attributeIdEnumeration,$attributeId);
             $attrValue = sprintf ("%0x", $attrValue);
@@ -5498,11 +5466,6 @@ sub generateTargetingImage {
                         $attributes,
                         $attributeDef,$attrhash{$attributeId}->{default});
 
-                $biosData{$targetInstance->{id}}{$attributeId}{size} =
-                    (length $heapZeroInitData);
-                $biosData{$targetInstance->{id}}{$attributeId}{default} =
-                    $attrhash{$attributeId}->{default};
-
                 my $hex = unpack ("H*",$heapZeroInitData);
                 push @attrDataforSM, [$attrValue, $huidValue,
                     $hex, $section, $targetInstance->{id}, $attributeId];
@@ -5527,11 +5490,6 @@ sub generateTargetingImage {
                         $attributes,
                         $attributeDef,$attrhash{$attributeId}->{default});
 
-                $biosData{$targetInstance->{id}}{$attributeId}{size} =
-                    (length $heapPnorInitData);
-                $biosData{$targetInstance->{id}}{$attributeId}{default} =
-                    $attrhash{$attributeId}->{default};
-
                 my $hex = unpack ("H*",$heapPnorInitData);
                 push @attrDataforSM, [$attrValue, $huidValue,
                     $hex, $section, $targetInstance->{id}, $attributeId];
@@ -5701,11 +5659,6 @@ sub generateTargetingImage {
                         $attributes,
                         $attributeDef,$attrhash{$attributeId}->{default});
 
-                $biosData{$targetInstance->{id}}{$attributeId}{size} =
-                    (length $hbHeapZeroInitData);
-                $biosData{$targetInstance->{id}}{$attributeId}{default} =
-                    $attrhash{$attributeId}->{default};
-
                 # Align the data as necessary
                 my $pads = ($alignment - ($hbHeapZeroInitOffset
                             % $alignment)) % $alignment;
@@ -6028,37 +5981,6 @@ sub generateTargetingImage {
             - $fspP1DefaultedFromP3Offset));
     }
 
-    if(defined $cfgBiosXmlFile)
-    {
-        unless (-e $cfgBiosXmlFile)
-        {
-            fatal("BIOS XML file $cfgBiosXmlFile does not exist.\n");
-        }
-
-        unless (defined $cfgBiosSchemaFile)
-        {
-            fatal("BIOS XML file $cfgBiosXmlFile specified, but a BIOS schema "
-                . "file was not.\n");
-        }
-
-        unless (-e $cfgBiosSchemaFile)
-        {
-            fatal("BIOS schema file $cfgBiosSchemaFile does not exist.\n");
-        }
-
-        unless (defined $cfgBiosOutputFile)
-        {
-            fatal("BIOS output file not specified.\n");
-        }
-
-        my $bios = new
-            Bios($cfgBiosXmlFile,$cfgBiosSchemaFile,$cfgBiosOutputFile);
-        $bios->load();
-        $bios->processBios(
-            \%attributeDefCache,\$attributes,\%biosData,%targetPhysicalPath);
-        $bios->export();
-    }
-
     return $outFile;
 }
 
@@ -6090,935 +6012,6 @@ print SM_TARGET_FILE"
     close(SM_TARGET_FILE);
 }
 
-################################################################################
-# BIOS Package
-#    Consumes platform-specific BIOS XML file, validates it, and outputs
-#    extended data on the attributes, which will be transformed (via xslt
-#    stylesheets) and used by 3rd parties (like Petitboot).  The BIOS
-#    package validates the input file against a stylesheet to ensure
-#    proper formatting.
-################################################################################
-
-{
-
-package Bios;
-
-################################################################################
-# Constructor; create a new Bios object
-################################################################################
-
-sub new
-{
-    my ($class,$biosInputXmlFile,$biosSchemaXsdFile,$biosOutputXmlFile) = @_;
-    my $self = {
-        _biosInputXmlFile => $biosInputXmlFile,
-        _libXmlParser => XML::LibXML->new(),
-        _biosXmlDoc => undef,
-        _biosSchemaXsdFile => $biosSchemaXsdFile,
-        _biosOutputXmlFile => $biosOutputXmlFile,
-    };
-
-    bless $self, $class;
-
-    return $self;
-}
-
-################################################################################
-# Load and parse the BIOS XML data, then validate it
-################################################################################
-
-sub load
-{
-    my ($self) = @_;
-    my $biosSchemaXsd = undef;
-
-    eval
-    {
-        $self->{_biosXmlDoc} =
-            $self->{_libXmlParser}->parse_file($self->{_biosInputXmlFile});
-    };
-
-    main::fatal ("Failed to parse BIOS file [$self->{_biosInputXmlFile}].\n"
-        . " Reason: $@") if $@;
-
-    eval
-    {
-        $biosSchemaXsd =
-            XML::LibXML::Schema->new(location => $self->{_biosSchemaXsdFile} );
-    };
-
-    main::fatal ("Failed to load valid schema [$self->{_biosSchemaXsdFile}].\n"
-        . "Reason: $@") if $@;
-
-    eval
-    {
-        $biosSchemaXsd->validate($self->{_biosXmlDoc})
-    };
-
-    main::fatal ("Failed to validate [$self->{_biosInputXmlFile}] "
-        . "using schema [$self->{_biosSchemaXsdFile}].\n"
-        . "Reason: $@") if $@;
-}
-
-################################################################################
-# Export the working version of the BIOS document to a file our STDOUT
-################################################################################
-
-sub export
-{
-    my ($self,$forceStdout) = @_;
-
-    if(defined $forceStdout
-        && ($forceStdout == 1))
-    {
-        print STDOUT "In-memory BIOS XML dump:\n";
-        print STDOUT $self->{_biosXmlDoc}->toString();
-    }
-    else
-    {
-        open(OUTPUT_XML,">$self->{_biosOutputXmlFile}") or
-            main::fatal("Could not open output BIOS XML file "
-                . "[$self->{_biosOutputXmlFile}] for writing.\n"
-                . "Reason: $!");
-
-        print OUTPUT_XML $self->{_biosXmlDoc}->toString() or
-            main::fatal ("Failed write output BIOS XML file "
-                . "[$self->{_biosOutputXmlFile}].\n"
-                . "Reason: $!");
-
-        close OUTPUT_XML or
-            main::fatal ("Failed to close output BIOS XML file "
-                . "[$self->{_biosOutputXmlFile}].\n"
-                . "Reason: $!");
-    }
-}
-
-################################################################################
-# Create child element in BIOS XML tree and return it
-################################################################################
-
-sub createChildElement()
-{
-    my ($self,$parent,$name,$value) = @_;
-
-    my $child = XML::LibXML::Element->new($name);
-
-    # Value is optional parameter; if not specified, only the child container
-    # element is created
-    if(defined $value)
-    {
-        $child->appendTextNode($value);
-    }
-    $parent->addChild($child);
-
-    return $child;
-}
-
-################################################################################
-# Validate any constraint not enforced by the schema and amend the XML tree
-################################################################################
-
-sub processBios
-{
-    my($self,$attrMapRef,$attributesRef,$instanceRef,%targetPhysicalPath) = @_;
-
-    use bigint;
-
-    my %attrTargAttrSetByBios = ();
-
-    # Process all attribute elements regardless of tree location
-    foreach my $attribute ($self->{_biosXmlDoc}->findnodes('//attribute'))
-    {
-        my($id) = $attribute->findnodes('./id');
-        my $attributeId =  $id->to_literal;
-
-        # Attribute must be defined in targeting
-        if(!exists $attrMapRef->{$attributeId})
-        {
-            main::fatal("BIOS definition specified attribute $attributeId, but "
-                . "that attribute is not defined in targeting.\n");
-        }
-
-        # Attribute must have volatile persistency
-        if($attrMapRef->{$attributeId}{persistency} ne "volatile"
-             && $attrMapRef->{$attributeId}{persistency} ne "volatile-zeroed")
-        {
-            main::fatal("BIOS definition specified attribute $attributeId, but "
-                . "that attribute is neither volatile nor volatile-zeroed "
-                . "in targeting.  Actual persistency is "
-                . "$attrMapRef->{$attributeId}{persistency}.\n");
-        }
-
-        # Attribute must be read only
-        my $readable = exists $attrMapRef->{$attributeId}{readable} ? 1 : 0;
-        my $writeable = exists $attrMapRef->{$attributeId}{writeable} ? 1 : 0;
-        if(!$readable || $writeable)
-        {
-            main::fatal("BIOS definition specified attribute $attributeId, but "
-                . "that attribute is not read-only in targeting.  "
-                . "Readable? " . $readable
-                . " writeable? " . $writeable . "\n");
-        }
-
-        # Attribute must not be an FSP-only attribute
-        my $fspOnly = exists $attrMapRef->{$attributeId}{fspOnly} ? 1 : 0;
-        if($fspOnly)
-        {
-            main::fatal("BIOS definition specified attribute $attributeId, but "
-                . "that attribute is FSP only in targeting.\n");
-        }
-
-        # Attribute must be an allowed type -and- supported by the BIOS code
-        # Current support is for signed/unsigned ints (1,2,4,8 bytes in size)
-        # and enumerations
-        my $simpleType = exists $attrMapRef->{$attributeId}{simpleType} ? 1 : 0;
-        my $complexType =
-            exists $attrMapRef->{$attributeId}{complexType} ? 1 : 0;
-        my $nativeType = exists $attrMapRef->{$attributeId}{nativeType} ? 1 : 0;
-        if(!$simpleType)
-        {
-            main::fatal("BIOS definition specified attribute $attributeId, but "
-                . "that attribute is not a simple type in targeting.  "
-                . "Complex type? $complexType, native type? $nativeType.\n");
-        }
-
-        # Defines which attributes can be put in the BIOS and provides
-        # associated BIOS type hint for 3rd party consumer
-        my %typeHash = ();
-
-        $typeHash{"int8_t"} =
-             { generalType => 'signed',
-               min         => -128,
-               max         => 127,
-               ror         => 1,
-             };
-        $typeHash{"int16_t"} =
-             { generalType => 'signed',
-               min         => -32768,
-               max         => 32767,
-               ror         => 1,
-             };
-        $typeHash{"int32_t"} =
-             { generalType => 'signed',
-               min         => -2147483648,
-               max         => 2147483647,
-               ror         => 1,
-             };
-        $typeHash{"int64_t"} =
-             { generalType => 'signed',
-               min         => -9223372036854775808,
-               max         => 9223372036854775807,
-               ror         => 1,
-             };
-        $typeHash{"uint8_t"} =
-             { generalType => 'unsigned',
-               min         => 0,
-               max         => 255,
-               ror         => 1,
-              };
-        $typeHash{"uint16_t"} =
-             { generalType => 'unsigned',
-               min         => 0,
-               max         => 65535,
-               ror         => 1,
-             };
-        $typeHash{"uint32_t"} =
-             { generalType => 'unsigned',
-               min         => 0,
-               max         => 4294967295,
-               ror         => 1,
-             };
-        $typeHash{"uint64_t"} =
-             { generalType => 'unsigned',
-               min         => 0,
-               max         => 18446744073709551615,
-               ror         => 1,
-             };
-        $typeHash{"enumeration"} =
-             { generalType => 'unsigned',
-               min         => 'na',
-               max         => 'na',
-               ror         => 1,
-             };
-
-        my $validType = 0;
-        my $attrType = "unknown";
-        # Convert actual type into a generalized type hint for the BIOS consumer
-        # and append to the XML tree
-        foreach my $type (keys %typeHash)
-        {
-            if(exists $attrMapRef->{$attributeId}{simpleType}{$type})
-            {
-                $self->createChildElement($attribute,"encoding",
-                    $typeHash{$type}{generalType});
-                $attrType = $type;
-                $validType = 1;
-                last;
-            }
-        }
-        if(!$validType)
-        {
-            main::fatal("BIOS definition specified attribute $attributeId, but "
-                . "that attribute's type is not supported in BIOS context. "
-                . "Dump of type:\n"
-                . ::Dumper($attrMapRef->{$attributeId}{simpleType}) . "\n");
-        }
-
-        # Simple type must not be array
-        if(exists $attrMapRef->{$attributeId}{simpleType}{array})
-        {
-            main::fatal("BIOS definition specified attribute $attributeId, but "
-                . "that attribute is an array which is not supported in "
-                . "BIOS context.\n");
-        }
-
-        # If attribute definition doesn't have a short name, it must be
-        # overridden by the BIOS config.  Add final value to the XML tree
-        my($displayNameNodes) = $attribute->findnodes('./display-name');
-        if(!$displayNameNodes)
-        {
-            if(exists $attrMapRef->{$attributeId}{'display-name'})
-            {
-                $self->createChildElement(
-                    $attribute,"display-name",
-                    $attrMapRef->{$attributeId}{'display-name'});
-            }
-            else
-            {
-                main::fatal("BIOS definition specified attribute $attributeId, "
-                    . "but attribute definition does not give a display name, "
-                    . "so BIOS config must (but failed to do so).\n");
-            }
-        }
-
-        # If attribute definition doesn't have a description, it must be
-        # overridden by the BIOS config.  Add final value to the XML tree
-        my($descriptionNodes) = $attribute->findnodes('./description');
-        if(!$descriptionNodes)
-        {
-            if(exists $attrMapRef->{$attributeId}{description})
-            {
-               $self->createChildElement(
-                    $attribute,"description",
-                    $attrMapRef->{$attributeId}{description});
-            }
-            else
-            {
-                main::fatal("BIOS definition specified attribute $attributeId, "
-                    . "but attribute definition does not give a description, "
-                    . "so BIOS config must (but failed to do so).\n");
-            }
-        }
-
-        my $default = undef;
-        my $size = undef;
-        my @targetRestrictions = $attribute->findnodes('./targetRestriction');
-
-        # Assume all targets have this BIOS attribute to begin with, then prove
-        # otherwise during processing
-        my %filteredTargets = %$instanceRef;
-        foreach my $target (keys %filteredTargets)
-        {
-            $filteredTargets{$target}{_allowed_} = 1;
-        }
-
-        # Hold the target override data
-        my %restriction = ();
-        $restriction{node} = 0x0F; # FAPI override value = any position
-        $restriction{position} = 0xFFFF; # FAPI override value = any position
-        $restriction{unit} = 0xFF; # FAPI override value = any unit
-        $restriction{symbolicType} = "*"; # Easy to understand target type
-        $restriction{numericType} = 0x0; # FAPI type indicator; 0 = any
-
-        # Scan target restriction(s).  If no restriction, the BIOS attribute
-        # must have same default for all instances.  If target restriction, all
-        # attributes that are grouped by the restriction must have the same
-        # default value.
-        if(scalar @targetRestrictions > 0)
-        {
-            my $restrictNode = "*";
-            my $restrictPos  = "*"; # NA except for things with positions
-                                    # including units
-            my $restrictUnit = "*"; # NA except for units
-            my $restrictType = "*";
-
-            # By default, a BIOS setting applies to every target the attribute
-            # is assigned to in targeting.  However, a target restriction can
-            # restrict an attribute to one or more subsets of those.  The set of
-            # targets tied to same BIOS attribute+restriction cannot intersect
-            # with any other similar grouping.  Further, all attributes of
-            # same type tied to same BIOS attribute via the restriction must
-            # have same default value.  Only one target restriction allowed by
-            # the schema
-            foreach my $targetRestriction (@targetRestrictions)
-            {
-                # Schema validation doesn't easily force targetRestrictions to
-                # have at least one child, so bail if that's the case
-                my @childElements = $targetRestriction->findnodes('./*');
-                if(scalar @childElements == 0)
-                {
-                    main::fatal("BIOS definition specified attribute "
-                        . "$attributeId, but requested targetRestriction with "
-                        . "no parameters.\n");
-                }
-
-                my @nodeElements = $targetRestriction->findnodes('./node');
-                my @positionElements
-                    = $targetRestriction->findnodes('./position');
-                my @unitElements = $targetRestriction->findnodes('./unit');
-                my @typeElements = $targetRestriction->findnodes('./type');
-
-                if(scalar @nodeElements)
-                {
-                    $restriction{node} = $nodeElements[0]->to_literal;
-                }
-
-                if(scalar @positionElements)
-                {
-                    $restriction{position} = $positionElements[0]->to_literal;
-                }
-
-                if(scalar @unitElements)
-                {
-                    $restriction{unit} = $unitElements[0]->to_literal;
-                }
-
-                # If any type restriction, verify it is a valid type designator
-                # any hold onto the numeric ID which will end up in the XML tree
-                if(scalar @typeElements)
-                {
-                    my $symbolicType = $typeElements[0]->to_literal;
-                    my $typeEnumDef =
-                        ::getEnumerationType($$attributesRef,"TYPE");
-                    my $numericType =
-                        ::enumNameToValue($typeEnumDef,$symbolicType);
-
-                    $restriction{numericType} = $numericType;
-                    $restriction{symbolicType} = $symbolicType;
-                }
-
-                # Compute the affected targets
-                foreach my $target (keys %filteredTargets)
-                {
-                    if(scalar @typeElements > 0)
-                    {
-                        $restrictType = $typeElements[0]->to_literal;
-
-                        # Screen out targets that don't match the given type
-                        if($filteredTargets{$target}{_allowed_} == 1)
-                        {
-                            my $type =
-                                $filteredTargets{$target}{_identity_}{TYPE};
-                            if($restrictType ne $type
-                                && $filteredTargets{$target}{_allowed_} == 1)
-                            {
-                                $filteredTargets{$target}{_allowed_} = 0;
-                                next;
-                            }
-                        }
-                    }
-
-                    if(scalar @nodeElements > 0)
-                    {
-                        $restrictNode = $nodeElements[0]->to_literal;
-
-                        # Screen out targets that don't match the given node.
-                        # A target matches the node restriction if its physical
-                        # path contains the same node ID.
-                        my $isInSameNodeExpr =
-                            quotemeta "physical:sys-0/node-$restrictNode" ;
-                        my $path =
-                            $filteredTargets{$target}{_identity_}{PHYS_PATH};
-
-                        if($path !~ m/^$isInSameNodeExpr/)
-                        {
-                            $filteredTargets{$target}{_allowed_} = 0;
-                            next;
-                        }
-                    }
-
-                    if(scalar @unitElements > 0)
-                    {
-                        $restrictUnit = $unitElements[0]->to_literal;
-
-                        my $checkPosition = 0;
-
-                        # Screen out targets that do not have unit attributes,
-                        # or which have non-matching unit attributes
-                        if(   (!exists
-                               $filteredTargets{$target}{_identity_}{CHIP_UNIT})
-                           || ($filteredTargets{$target}{_identity_}{CHIP_UNIT}
-                               != $restrictUnit)   )
-                        {
-                            $filteredTargets{$target}{_allowed_} = 0;
-                            next;
-                        }
-                        else
-                        {
-                            $checkPosition = 1;
-                        }
-
-                        # If unit matches, need to make sure it also sits on
-                        # chip at requested position, if specified
-                        if($checkPosition && ((scalar @positionElements) > 0))
-                        {
-                            my $candidatePath =
-                               $filteredTargets{$target}{_identity_}{PHYS_PATH};
-
-                            my $parent_phys_path = substr(
-                                $candidatePath, 0,(rindex $candidatePath, "/"));
-                            my $foundPosition = 0;
-
-                            # Walk from unit to whatever parent has the position
-                            # attribute; Remove this target from consideration
-                            # if the position does not match the restriction
-                            while(
-                                defined $targetPhysicalPath{$parent_phys_path})
-                            {
-                                if(defined $filteredTargets{
-                                       $targetPhysicalPath{$parent_phys_path}
-                                   }{_identity_}{POSITION})
-                                {
-                                    if ($filteredTargets{
-                                          $targetPhysicalPath{$parent_phys_path}
-                                        }{_identity_}{POSITION}
-                                        == $positionElements[0]->to_literal)
-                                    {
-                                        $foundPosition = 1;
-                                    }
-
-                                    last;
-                                }
-
-                                $candidatePath = $parent_phys_path;
-                                $parent_phys_path = substr(
-                                    $candidatePath, 0,
-                                    (rindex $candidatePath, "/"));
-                            }
-
-                            if(!$foundPosition)
-                            {
-                                $filteredTargets{$target}{_allowed_} = 0;
-                                next;
-                            }
-                        }
-                    }
-
-                    # If no unit restriction but position restriction, screen
-                    # out targets that don't have position attribute or whose
-                    # position attribute does not match the restriction
-                    if(   (scalar @positionElements > 0)
-                       && (scalar @unitElements == 0)   )
-                    {
-                        $restrictPos = $positionElements[0]->to_literal;
-
-                        if(   (!exists
-                                $filteredTargets{$target}{_identity_}{POSITION})
-                           || (  $filteredTargets{$target}{_identity_}{POSITION}
-                               != $restrictPos))
-                        {
-                            $filteredTargets{$target}{_allowed_} = 0;
-                        }
-                    }
-                 }
-            }
-        }
-
-        foreach my $target (keys %filteredTargets)
-        {
-            # Don't bother with any target that is not in play
-            if($filteredTargets{$target}{_allowed_} != 1)
-            {
-                next;
-            }
-
-            # Candidate is any target having the attribute and a default
-            # value determined
-            if(   exists $instanceRef->{$target}{$attributeId}
-               && exists $instanceRef->{$target}{$attributeId}{default}
-               && exists $instanceRef->{$target}{$attributeId}{size})
-            {
-                # Multiple BIOS directives cannot touch same
-                # target/attribute
-                if(defined $attrTargAttrSetByBios{$target}{$attributeId})
-                {
-                    main::fatal("$target, $attributeId set by multiple BIOS "
-                        . "definitions.\n");
-                }
-                else
-                {
-                    $attrTargAttrSetByBios{$target}{$attributeId} = 1;
-                }
-
-                # If no default set yet
-                if(! (defined $default) )
-                {
-                    $default = $instanceRef->{$target}{$attributeId}{default};
-                    $size = $instanceRef->{$target}{$attributeId}{size};
-                }
-                # Cannot have different defaults in same group
-                elsif(   $instanceRef->{$target}{$attributeId}{default}
-                      != $default )
-                {
-                    main::fatal("BIOS definition specified attribute "
-                        . "$attributeId, but default values are not same "
-                        . "across all qualifying targets.  "
-                        . "$target/ $attributeId = "
-                        . "$instanceRef->{$target}{$attributeId}{default}.\n");
-                }
-            }
-        }
-
-        # If no targets had the attribute
-        if(!defined $default || !defined $size)
-        {
-            main::fatal("BIOS definition specified attribute $attributeId, but "
-                . "after considering target restrictions/etc., no "
-                . "valid targets were found.\n");
-        }
-
-        # Add the restriction info to the XML tree.  This info is useful for 3rd
-        # parties to create Hostboot attribute overrides.
-        my $targetElement = $self->createChildElement($attribute,"target");
-        $self->createChildElement(
-            $targetElement,"type",sprintf("0x%08X",$restriction{numericType}));
-        $self->createChildElement(
-            $targetElement,"node",sprintf("0x%02X",$restriction{node}));
-        $self->createChildElement(
-            $targetElement,"position",sprintf("0x%04X",$restriction{position}));
-        $self->createChildElement(
-            $targetElement,"unit",sprintf("0x%02X",$restriction{unit}));
-
-        my @enumerationOverrideElement
-            = $attribute->findnodes('./enumerationOverride');
-        if($attrType eq "enumeration")
-        {
-            # Get a copy of the enumeration description.  Schema requires
-            # enumerator to have only a name (symbolic handle) + value.
-            # Customization allows overriding description + short name
-            # Customization allows specifying subset of values to actually use
-            # Output includes short name, long name, value
-            my $enumType =
-                $attrMapRef->{$attributeId}{simpleType}{enumeration}{id};
-            my $enumerationType =
-                ::getEnumerationType($$attributesRef,$enumType);
-
-            my %foundAllowed = ();
-            my $enableRestrictions = 0;
-            if(scalar @enumerationOverrideElement)
-            {
-                # Each enumerator name must tie back to a valid enumeration
-                foreach my $overrideNameElement (
-                    $attribute->findnodes(
-                        './enumerationOverride/allowedEnumerators/name'))
-                {
-                    my $overrideName = $overrideNameElement->to_literal;
-                    my $nameFound = 0;
-                    foreach my $enumerator (@{$enumerationType->{enumerator}})
-                    {
-                        if($enumerator->{name} eq $overrideName)
-                        {
-                            # Each allowed value must be different from all the
-                            # rest previously found for this attribute
-                            if(exists $foundAllowed{$overrideName})
-                            {
-                                main::fatal("BIOS definition specified "
-                                    . "attribute $attributeId, and supplied "
-                                    . "override to allowed enumeration values, "
-                                    . "but duplicated a value of "
-                                    . "$overrideName.\n");
-                            }
-                            else
-                            {
-                                $foundAllowed{$overrideName} = 1;
-                                $enumerator->{allowed} = 1;
-                            }
-
-                            $enableRestrictions = 1;
-                            $nameFound = 1;
-
-                            last;
-                        }
-                    }
-
-                    if(!$nameFound)
-                    {
-                        main::fatal("BIOS definition specified attribute "
-                            . "$attributeId, and supplied override to allowed "
-                            . "enumeration values, but requested enumerator "
-                            . "$overrideName is not valid.\n");
-                    }
-                }
-
-                # Apply any overrides to the enumerator text
-                my %textOverrideAllowed = ();
-                foreach my $enumeratorOverrideElement (
-                    $attribute->findnodes(
-                        './enumerationOverride/enumeratorOverride'))
-                {
-                    # Each override must have exactly one name element
-                    my @name = $enumeratorOverrideElement->findnodes('./name');
-
-                    # Each override must have 0 or 1 display-name and
-                    # descriptions elements
-                    my @displayName =
-                        $enumeratorOverrideElement->findnodes('./display-name');
-                    my @description =
-                        $enumeratorOverrideElement->findnodes('./description');
-
-                    # Make sure enumerator name is valid
-                    my $overrideName = $name[0]->to_literal;
-                    my $nameFound = 0;
-                    foreach my $enumerator (@{$enumerationType->{enumerator}})
-                    {
-                        if($enumerator->{name} eq $overrideName)
-                        {
-                            # Must not duplicate already overridden enumerator
-                            if(exists $textOverrideAllowed{$overrideName})
-                            {
-                                main::fatal("BIOS definition specified "
-                                     . "attribute $attributeId, and supplied "
-                                     . "override to allowed enumerator, "
-                                     . "but already overrode this "
-                                     . "enuemrator.\n");
-                            }
-                            # Can only override things that are not restricted
-                            elsif(   !exists $foundAllowed{$overrideName}
-                                  && $enableRestrictions)
-                            {
-                                main::fatal("BIOS definition specified "
-                                     . "attribute $attributeId, and supplied "
-                                     . "override to allowed enumerator, but "
-                                     . "this enumerator $overrideName is "
-                                     . "restricted.\n");
-                            }
-                            else
-                            {
-                                $textOverrideAllowed{$overrideName} = 1;
-                            }
-
-                            if(scalar @displayName)
-                            {
-                                $enumerator->{'display-name'} =
-                                    $displayName[0]->to_literal;
-                            }
-
-                            if(scalar @description)
-                            {
-                                $enumerator->{description} =
-                                    $description[0]->to_literal;
-                            }
-
-                            $nameFound = 1;
-                            last;
-                        }
-                    }
-
-                    if(!$nameFound)
-                    {
-                        main::fatal("BIOS definition specified attribute "
-                            . "$attributeId, and supplied override to allowed "
-                            . "enumeration, but requested invalid enumerator "
-                            . "name to override of $overrideName.\n");
-                    }
-                }
-            }
-
-            my $enumerationElement =
-                $self->createChildElement($attribute,"enumeration");
-
-            foreach my $enumerator (@{$enumerationType->{enumerator}})
-            {
-                if($enableRestrictions && !exists $enumerator->{allowed})
-                {
-                    # If enumerator is not allowed and is same as attribute
-                    # default then can't continue
-                    if($default eq  $enumerator->{name})
-                    {
-                        main::fatal("BIOS definition specified attribute "
-                            . "$attributeId as not allowing "
-                            . "$enumerator->{name}, but that is the attribute "
-                            . "default.\n");
-                    }
-
-                    next;
-                }
-
-                my $enumeratorElement =
-                    $self->createChildElement($enumerationElement,"enumerator");
-
-                if(!exists $enumerator->{'display-name'})
-                {
-                    main::fatal("BIOS definition specified attribute "
-                        . "$attributeId, and supplied override to enumerator "
-                        . "$enumerator->{name}, but there is no "
-                        . "display-name.\n");
-                }
-
-                $self->createChildElement(
-                   $enumeratorElement,"display-name",
-                   $enumerator->{'display-name'});
-
-                if(!exists $enumerator->{description})
-                {
-                    main::fatal("BIOS definition specified attribute "
-                        . "$attributeId, and supplied override to enumerator "
-                        . "$enumerator->{name}, but there is no "
-                        . "description.\n");
-                }
-
-                $self->createChildElement(
-                   $enumeratorElement,"description",$enumerator->{description});
-                $self->createChildElement(
-                   $enumeratorElement,"value",
-                   sprintf("0x%08X",$enumerator->{value}));
-            }
-
-            # Translate attribute default to actual value
-            $default = ::enumNameToValue($enumerationType,$default);
-        }
-        # No enums allowed to be specified
-        elsif(scalar @enumerationOverrideElement)
-        {
-                main::fatal("BIOS definition specified attribute $attributeId, "
-                    . "and supplied enumerated values, but this is not an "
-                    . "enumeration attribute, it is of type $attrType.\n");
-        }
-
-        # Can only specify numeric override for signed/unsigned values of
-        # 1,2,4,8 byte values
-        my @numericOverrideElements= $attribute->findnodes('./numericOverride');
-
-        # Hash of min(key), max(value) pairs
-        my %allowedRange = ();
-        if(scalar @numericOverrideElements)
-        {
-            # If range override not allowed for this attribute, bail
-            if($typeHash{$attrType}{ror} != 1)
-            {
-                main::fatal("BIOS definition specified attribute $attributeId, "
-                    . "and supplied numeric override, but this attribute "
-                    . "type does not support such override.  Type is "
-                    . "$attrType.\n");
-            }
-
-            # A numericOverride has exactly one start + end element
-            my @startElements =
-                @numericOverrideElements[0]->findnodes('./start');
-            my @endElements = @numericOverrideElements[0]->findnodes('./end');
-            my $min = $typeHash{$attrType}{min};
-            my $max = $typeHash{$attrType}{max};
-
-            # Validate range min
-            if(scalar @startElements)
-            {
-                my $rawMin = @startElements[0]->to_literal;
-
-                if($rawMin < $min || $rawMin > $max)
-                {
-                    main::fatal("BIOS definition specified attribute "
-                        . "$attributeId, and supplied valid start or end "
-                        . "range, but min out of range. requested "
-                        . "min = $rawMin, allowed min = "
-                        . "$typeHash{$attrType}{min}, allowed max = "
-                        . "$typeHash{$attrType}{max}.\n");
-                }
-                $min = $rawMin;
-            }
-
-            # Validate range max
-            if(scalar @endElements)
-            {
-                my $rawMax = @endElements[0]->to_literal;
-
-                if($rawMax > $max || $rawMax < $min)
-                {
-                    main::fatal("BIOS definition specified attribute "
-                        . "$attributeId, and supplied valid start or end "
-                        . "range, but max out of range. requested "
-                        . "max = $rawMax, current min = $min, "
-                        . "allowed min = "
-                        . "$typeHash{$attrType}{min}, allowed max = "
-                        . "$typeHash{$attrType}{max}.\n");
-                }
-                $max = $rawMax;
-            }
-
-            # Min must be <= Max
-            if($min > $max)
-            {
-                main::fatal("BIOS definition specified attribute "
-                    . "$attributeId, and supplied valid start or end "
-                    . "range, but min > max. min = $min, "
-                    . "max = $max.\n");
-            }
-
-            # To prevent range overlaps, cannot duplicate the same start of
-            # a range
-            if(defined $allowedRange{$min})
-            {
-                main::fatal("Already range starting at $min.\n");
-            }
-
-            $allowedRange{$min} = $max;
-            my $defaultInRange = 0;
-
-            my $min = undef;
-            my $max = undef;
-
-            # Ensure default value falls within a defined range.  The ranges are
-            # sorted in numerically ascending order according to the start of
-            # each range, so if the start of
-            # range N falls within range N-1, we know there is an illegal range
-            # overlap and fail.
-            foreach my $rangeKey (sort {$a <=> $b} keys %allowedRange)
-            {
-                if(   ($default >= $rangeKey)
-                   && ($default <= $allowedRange{$rangeKey}) )
-                {
-                    $defaultInRange = 1;
-                }
-
-                if(!defined $min)
-                {
-                    $min = $rangeKey;
-                    $max = $allowedRange{$rangeKey};
-                    next;
-                }
-
-                if($rangeKey <= $max)
-                {
-                    main::fatal("Range starting with $rangeKey overlaps "
-                        . "range ending at $max.\n");
-                }
-
-                $min = $rangeKey;
-                $max = $allowedRange{$rangeKey};
-            }
-
-            if(!$defaultInRange)
-            {
-                main::fatal("Default value $default not in any valid range.\n");
-            }
-        }
-
-        # Convert attribute ID to numerical value and append to XML tree
-        my $attributeIdEnumeration
-            = ::getAttributeIdEnumeration($$attributesRef);
-        my $attrValue = ::enumNameToValue($attributeIdEnumeration,$attributeId);
-        $attrValue = sprintf ("0x%0X", $attrValue);
-
-        # Add the remaining metadata to the XML tree
-        $self->createChildElement($attribute,"default",$default);
-        $self->createChildElement($attribute,"numeric-id",$attrValue);
-        $self->createChildElement($attribute,"size",$size);
-    }
-}
-
-1;
-
-}
-
 __END__
 
 =head1 NAME
@@ -7117,23 +6110,6 @@ Adds 4096 bytes of version page as first page in the generated binaries.
 Does not add 4096 bytes of version page as first page in the generated
 binaries . This is the default behavior.
 
-=item B<--bios-xml-file>
-
-Path + file name of XML file describing the platform's BIOS configuration.
-Optional.
-
-=item B<--bios-schema-file>
-
-Path + file name of XSD schema file used to validate the BIOS XML file. Required
-if a BIOS XML file is given.
-
-=item B<--bios-output-file>
-
-Path + filename of output XML file describing the amended BIOS configuration.
-This output is commonly later modified by 3rd parties via xslt transformation to
-tailor the output for a given application.  Required if a BIOS XML file is
-given.
-
 =item B<--verbose>
 
 Prints out some internal workings
-- 
1.8.2.2


From 2a45170e801056f7f2952610ccd9079ad5324c98 Mon Sep 17 00:00:00 2001
From: Matt Ploetz <maploetz@us.ibm.com>
Date: Fri, 20 Feb 2015 11:04:36 -0600
Subject: [PATCH 06/10] Revert "Targeting: Generate VERSION page for binaries."

This reverts commit 34c58e19162834ff5bb8d4ffb9975b50d5a0770a.
---
 src/build/buildpnor/defaultPnorLayout.xml   |  1 -
 src/usr/targeting/common/xmltohb/xmltohb.pl | 59 +----------------------------
 src/usr/targeting/xmltohb/makefile          |  5 +--
 3 files changed, 4 insertions(+), 61 deletions(-)

diff --git a/src/build/buildpnor/defaultPnorLayout.xml b/src/build/buildpnor/defaultPnorLayout.xml
index 18c309d..d5d5d25 100644
--- a/src/build/buildpnor/defaultPnorLayout.xml
+++ b/src/build/buildpnor/defaultPnorLayout.xml
@@ -97,7 +97,6 @@ Layout Description
         <eyeCatch>HBD</eyeCatch>
         <physicalOffset>0x5D000</physicalOffset>
         <physicalRegionSize>0x120000</physicalRegionSize>
-        <sha512Version/>
         <side>sideless</side>
         <ecc/>
     </section>
diff --git a/src/usr/targeting/common/xmltohb/xmltohb.pl b/src/usr/targeting/common/xmltohb/xmltohb.pl
index d02c1a7..a658c74 100755
--- a/src/usr/targeting/common/xmltohb/xmltohb.pl
+++ b/src/usr/targeting/common/xmltohb/xmltohb.pl
@@ -74,7 +74,6 @@ my $cfgShortEnums = 0;
 my $cfgBigEndian = 1;
 my $cfgIncludeFspAttributes = 0;
 my $CfgSMAttrFile = "";
-my $cfgAddVersionPage = 0;
 
 GetOptions("hb-xml-file:s" => \$cfgHbXmlFile,
            "src-output-dir:s" =>  \$cfgSrcOutputDir,
@@ -86,7 +85,6 @@ GetOptions("hb-xml-file:s" => \$cfgHbXmlFile,
            "big-endian!" =>  \$cfgBigEndian,
            "smattr-output-file:s" => \$CfgSMAttrFile,
            "include-fsp-attributes!" =>  \$cfgIncludeFspAttributes,
-           "version-page!" => \$cfgAddVersionPage,
            "help" => \$cfgHelp,
            "man" => \$cfgMan,
            "verbose" => \$cfgVerbose ) || pod2usage(-verbose => 0);
@@ -115,7 +113,6 @@ if($cfgVerbose)
     print STDOUT "Short enums = $cfgShortEnums\n";
     print STDOUT "Big endian = $cfgBigEndian\n";
     print STDOUT "include-fsp-attributes = $cfgIncludeFspAttributes\n",
-    print STDOUT "version-page = $cfgAddVersionPage\n",
 }
 
 ################################################################################
@@ -337,21 +334,9 @@ use constant SECTION => 3;
 use constant TARGET => 4;
 use constant ATTRNAME => 5;
 my @attrDataforSM = ();
-
-#Flag which indicates if the script needs to add the 4096 bytes of version
-#checksum as first page in the binary file generated.
-my $addRO_Section_VerPage = 0;
 if( !($cfgImgOutputDir =~ "none") )
 {
-    #Version page will be added only if the script is called in with the flag
-    #--version-flag
-    if ($cfgAddVersionPage)
-    {
-        $addRO_Section_VerPage = 1;
-    }
-    #Pass the $addRO_Section_VerPage into the sub rotuine
-    my $Data = generateTargetingImage($cfgVmmConstsFile,$attributes,\%Target_t,
-                                      $addRO_Section_VerPage);
+    my $Data = generateTargetingImage($cfgVmmConstsFile,$attributes,\%Target_t);
 
     open(PNOR_TARGETING_FILE,">$cfgImgOutputDir".$cfgImgOutputFile)
       or fatal ("Targeting image file: \"$cfgImgOutputDir"
@@ -4973,7 +4958,7 @@ sub serializeAssociations
 ################################################################################
 
 sub generateTargetingImage {
-    my($vmmConstsFile, $attributes, $Target_t,$addRO_Section_VerPage) = @_;
+    my($vmmConstsFile, $attributes, $Target_t) = @_;
 
     # 128 MB virtual memory offset between sections
     my $vmmSectionOffset = 128 * 1024 * 1024; # 128MB
@@ -4998,12 +4983,6 @@ sub generateTargetingImage {
     my $headerSize = 256;
     my $offset = $headerSize;
 
-
-    #If the file to be created is the HB targeting binary , then it will contain
-    #first page (4096 bytes) as the read-only data checksum. Need to adjust the
-    #read-only section offset.
-    my $versionSectionSize = 4096;
-
     # Reserve space for the pointer to the # of targets, update later;
     my $numTargetsPointer = 0;
     my $numTargetsPointerBinData = pack8byte($numTargetsPointer);
@@ -5768,15 +5747,6 @@ sub generateTargetingImage {
     my $blockSize = 4*1024;
 
     my %sectionHoH = ();
-
-    my $roOffset = 0;
-    if ($addRO_Section_VerPage == 1)
-    {
-        #First section to start after 4096 bytes
-        #as RO version data occupies first page in the binary file
-        $roOffset = $versionSectionSize;
-    }
-
     $sectionHoH{ pnorRo }{ offset } = 0;
     $sectionHoH{ pnorRo }{ type   } = 0;
     $sectionHoH{ pnorRo }{ size   } = sizeBlockAligned($offset,$blockSize,1);
@@ -5897,24 +5867,6 @@ sub generateTargetingImage {
     }
 
     my $outFile;
-
-    #HB Targeting binary file will contain <Version Page>+<Targeting Header>+
-    #<Section  data>...
-    if ($addRO_Section_VerPage == 1)
-    {
-        #Generate the MD5 checksum value for the read-only data and update the
-        #content of the version section
-        my $versionHeader = "VERSION";
-        $versionHeader .= md5_hex($roAttrBinData);
-
-        $outFile .= $versionHeader;
-        my $versionHeaderPadSize =
-            (sizeBlockAligned ((length $versionHeader),$versionSectionSize,1)
-             - (length $versionHeader));
-        $outFile .= pack ("@".$versionHeaderPadSize);
-    }
-
-    #Append the 256 bytes header data
     $outFile .= $headerBinData;
     my $padSize = sizeBlockAligned((length $headerBinData),$headerSize,1)
         - (length $headerBinData);
@@ -6103,13 +6055,6 @@ generated code.
 Omits FSP specific attributes and targets from the generated binaries and
 generated code.  This is the default behavior.
 
-=item B<--version-page>
-Adds 4096 bytes of version page as first page in the generated binaries.
-
-=item B<--no-version-page>
-Does not add 4096 bytes of version page as first page in the generated
-binaries . This is the default behavior.
-
 =item B<--verbose>
 
 Prints out some internal workings
diff --git a/src/usr/targeting/xmltohb/makefile b/src/usr/targeting/xmltohb/makefile
index eb0b05a..6d1fff3 100644
--- a/src/usr/targeting/xmltohb/makefile
+++ b/src/usr/targeting/xmltohb/makefile
@@ -5,7 +5,7 @@
 #
 # OpenPOWER HostBoot Project
 #
-# Contributors Listed Below - COPYRIGHT 2011,2015
+# Contributors Listed Below - COPYRIGHT 2011,2014
 # [+] International Business Machines Corp.
 #
 #
@@ -154,6 +154,5 @@ ${GENDIR}/%_targeting.bin: ${XMLTOHB_COMPILER_SCRIPT} ${GENDIR}/%.hb.xml \
         $(addprefix --fapi-attributes-xml-file=,${GENDIR}/${XMLTOHB_FAPI_XML}) \
          --src-output-dir=none --img-output-dir=$(dir $@) \
          --img-output-file=$(notdir $@) \
-         --vmm-consts-file=$(VMM_CONSTS_FILE) --noshort-enums \
-         --version-page
+         --vmm-consts-file=$(VMM_CONSTS_FILE) --noshort-enums
 
-- 
1.8.2.2


From 0a4989176f0ef4f1374f88ae5dd4157cd63d45ce Mon Sep 17 00:00:00 2001
From: Matt Ploetz <maploetz@us.ibm.com>
Date: Fri, 20 Feb 2015 11:04:47 -0600
Subject: [PATCH 07/10] Revert "adding toc offsets to defaultPnorLayout for
 hwsv team"

This reverts commit 6990adda0f2996cc7baacba9f485c7b5a415904c.
---
 src/build/buildpnor/defaultPnorLayout.xml | 7 -------
 1 file changed, 7 deletions(-)

diff --git a/src/build/buildpnor/defaultPnorLayout.xml b/src/build/buildpnor/defaultPnorLayout.xml
index d5d5d25..897d4db 100644
--- a/src/build/buildpnor/defaultPnorLayout.xml
+++ b/src/build/buildpnor/defaultPnorLayout.xml
@@ -28,9 +28,6 @@ Layout Description
     <imageSize>    -> Size of PNOR image in bytes.
     <blockSize>    -> size of erase blocks in bytes.
     <tocSize>      -> size of each partition table
-    <!- TODO:RTC:123734 - remove side offsets once hwsv implements new layout ->
-    <sideAOffset>  -> Location of Side A Partition Table
-    <sideBOffset>  -> Location of Side B Partition Table
     <side>         -> Contains information about the side
         <id>            -> Id of the side (A or B)
         <arrangement>   -> Tag that specifies the arrangement of the side
@@ -67,10 +64,6 @@ Layout Description
         <imageSize>0x4000000</imageSize>
         <blockSize>0x1000</blockSize>
         <tocSize>0x8000</tocSize>
-        <!--TODO: RTC 123734 - remove side offsets once hwsv implements new
-        layout-->
-        <sideAOffset>0x0</sideAOffset>
-        <sideBOffset>0x8000</sideBOffset>
         <arrangement>A-B-D</arrangement>
         <side>
             <id>B</id>
-- 
1.8.2.2


From 2f98670c4b42a64f481a336e4d8d34a9a5ad93a8 Mon Sep 17 00:00:00 2001
From: Matt Ploetz <maploetz@us.ibm.com>
Date: Fri, 20 Feb 2015 11:04:55 -0600
Subject: [PATCH 08/10] Revert "Created 2-sided and golden-side pnor layouts"

This reverts commit e83759d6aa90999933318155772b50a8af679ec6.
---
 src/build/buildpnor/buildpnor.pl          | 254 ++++++++----------------------
 src/build/buildpnor/defaultPnorLayout.xml |  69 ++++----
 src/usr/pnor/common/ffs_hb.H              |   3 +-
 3 files changed, 96 insertions(+), 230 deletions(-)

diff --git a/src/build/buildpnor/buildpnor.pl b/src/build/buildpnor/buildpnor.pl
index aad7c34..f6df6c8 100755
--- a/src/build/buildpnor/buildpnor.pl
+++ b/src/build/buildpnor/buildpnor.pl
@@ -61,7 +61,6 @@ my $g_trace = 1;
 
 my $programName = File::Basename::basename $0;
 my %pnorLayout;
-my %PhysicalOffsets;
 my %binFiles;
 my $pnorLayoutFile;
 my $pnorBinName = "";
@@ -71,6 +70,7 @@ my $emitTestSections = 0;
 my $g_fpartCmd = "";
 my $g_fcpCmd = "";
 my %sidelessSecFilled = ();
+
 my %SideOptions = (
         A => "A",
         B => "B",
@@ -132,7 +132,7 @@ if (-e $pnorBinName)
 }
 
 #Load PNOR Layout XML file
-my $rc = loadPnorLayout($pnorLayoutFile, \%pnorLayout, \%PhysicalOffsets);
+my $rc = loadPnorLayout($pnorLayoutFile, \%pnorLayout);
 if($rc != 0)
 {
     trace(0, "Error detected from call to loadPnorLayout().  Exiting");
@@ -163,6 +163,8 @@ if($rc != 0)
 }
 trace(1, "Done checkSpaceConstraints");
 
+# @TODO RTC: 120062 - Determine which side is Golden, possibly handle a new
+#                    xml tag
 # Create all Partition Tables at each TOC offset
 # Each side has 2 TOC's created at different offsets for backup purposes.
 # Loop all side sections
@@ -172,6 +174,7 @@ foreach my $sideId ( keys %{$pnorLayout{metadata}{sides}} )
     foreach my $toc ( keys %{$pnorLayout{metadata}{sides}{$sideId}{toc}})
     {
         my $tocOffset = $pnorLayout{metadata}{sides}{$sideId}{toc}{$toc};
+
         $rc = createPnorPartition($tocVersion, $pnorBinName, \%pnorLayout,
                                   $sideId, $tocOffset);
         if($rc != 0)
@@ -179,31 +182,9 @@ foreach my $sideId ( keys %{$pnorLayout{metadata}{sides}} )
             trace(0, "Error detected from createPnorPartition() $tocOffset Exiting");
             exit 1;
         }
-
-        #Add the golden side tag to the "part" partition of PNOR`
-        my $userflags1 = ($pnorLayout{metadata}{sides}{$sideId}{golden} eq "yes") ?
-                            0x01 : 0x00;
-
-        #add a golden bit to the misc flags in userflag1
-        $userflags1 = $userflags1 << 16;
-        trace(2, "$g_fpartCmd --target $pnorBinName --partition-offset $tocOffset --user 1 --name part --value $userflags1 --force");
-        $rc =    `$g_fpartCmd --target $pnorBinName --partition-offset $tocOffset --user 1 --name part --value $userflags1 --force`;
-        if($rc != 0)
-        {
-            trace(0, "Call to add golden flag to PART failed.  rc=$rc.  Aborting!");
-            exit;
-        }
     }
 }
 
-#add backup TOC and other side's toc information to each TOC
-$rc = addTOCInfo(\%pnorLayout, $pnorBinName);
-if($rc)
-{
-    trace(0, "Error detected from call to addTOCInfo().  Exiting");
-    exit 1;
-}
-
 # Fill all sides
 foreach my $sideId ( keys %{$pnorLayout{metadata}{sides}} )
 {
@@ -227,7 +208,7 @@ exit 0;
 ################################################################################
 sub loadPnorLayout
 {
-    my ($i_pnorFile, $i_pnorLayoutRef, $i_physicalOffsets) = @_;
+    my ($i_pnorFile, $i_pnorLayoutRef) = @_;
     my $this_func = (caller(0))[3];
 
     unless(-e $i_pnorFile)
@@ -240,6 +221,49 @@ sub loadPnorLayout
     my $xs = new XML::Simple(keyattr=>[], forcearray => 1);
     my $xml = $xs->XMLin($i_pnorFile);
 
+    #Save the meatadata - imageSize, blockSize, etc.
+    # @TODO RTC:120062 enhance metadata section, fix metadataE1 to match xml
+    # and change TOC names accordingly
+    foreach my $metadataEl (@{$xml->{metadata}})
+    {
+        # Get meta data
+        my $imageSize = $metadataEl->{imageSize}[0];
+        my $blockSize = $metadataEl->{blockSize}[0];
+        $imageSize = getNumber($imageSize);
+        $blockSize = getNumber($blockSize);
+        $$i_pnorLayoutRef{metadata}{imageSize} = $imageSize;
+        $$i_pnorLayoutRef{metadata}{blockSize} = $blockSize;
+
+        # Get Side A
+        my $sideATocOffset = $metadataEl->{sideATocOffset}[0];
+        my $sideATocBackupOffset = $metadataEl->{sideATocBackupOffset}[0];
+        $sideATocOffset = getNumber($sideATocOffset);
+        $sideATocBackupOffset = getNumber($sideATocBackupOffset);
+        # @TODO RTC: 120062 change pnorLayoutRef hash to match new xml
+        $$i_pnorLayoutRef{metadata}{sides}{$SideOptions{A}}{toc}{primary} = $sideATocOffset;
+        $$i_pnorLayoutRef{metadata}{sides}{$SideOptions{A}}{toc}{backup} = $sideATocBackupOffset;
+
+        # Get side B info (if it exists)
+        if (exists $metadataEl->{sideBTocOffset}[0])
+        {
+            trace(1, "Adding Side B information ....");
+            my $sideBTocOffset = $metadataEl->{sideBTocOffset}[0];
+            my $sideBTocBackupOffset = $metadataEl->{sideBTocBackupOffset}[0];
+            $sideBTocOffset = getNumber($sideBTocOffset);
+            $sideBTocBackupOffset = getNumber($sideBTocBackupOffset);
+            # @TODO RTC: 120062 change pnorLayoutRef hash to match new xml
+            $$i_pnorLayoutRef{metadata}{sides}{$SideOptions{B}}{toc}{primary} = $sideBTocOffset;
+            $$i_pnorLayoutRef{metadata}{sides}{$SideOptions{B}}{toc}{backup} = $sideBTocBackupOffset;
+
+            trace(3, "$this_func: metadata: imageSize = $imageSize, blockSize=$blockSize, sideATocOffset=$sideATocOffset, sideATocBackupOffset=$sideATocBackupOffset, sideBTocOffset=$sideBTocOffset, sideBTocBackupOffset=$sideBTocBackupOffset");
+        }
+        else
+        {
+           trace(3, "$this_func: metadata: imageSize = $imageSize, blockSize=$blockSize, sideATocOffset=$sideATocOffset, sideATocBackupOffset=$sideATocBackupOffset");
+        }
+
+    }
+
     #Iterate over the <section> elements.
     foreach my $sectionEl (@{$xml->{section}})
     {
@@ -252,6 +276,7 @@ sub loadPnorLayout
         my $ecc = (exists $sectionEl->{ecc} ? "yes" : "no");
         my $sha512Version = (exists $sectionEl->{sha512Version} ? "yes" : "no");
         my $sha512perEC = (exists $sectionEl->{sha512perEC} ? "yes" : "no");
+        my $sideless = (exists $sectionEl->{sideless} ? "yes" : "no");
         my $preserved = (exists $sectionEl->{preserved} ? "yes" : "no");
         my $readOnly = (exists $sectionEl->{readOnly} ? "yes" : "no");
         if (($emitTestSections == 0) && ($sectionEl->{testonly}[0] eq "yes"))
@@ -272,93 +297,12 @@ sub loadPnorLayout
         $$i_pnorLayoutRef{sections}{$physicalOffset}{ecc} = $ecc;
         $$i_pnorLayoutRef{sections}{$physicalOffset}{sha512Version} = $sha512Version;
         $$i_pnorLayoutRef{sections}{$physicalOffset}{sha512perEC} = $sha512perEC;
+        $$i_pnorLayoutRef{sections}{$physicalOffset}{sideless} = $sideless;
         $$i_pnorLayoutRef{sections}{$physicalOffset}{preserved} = $preserved;
         $$i_pnorLayoutRef{sections}{$physicalOffset}{readOnly} = $readOnly;
 
-        #store the physical offsets of each section in a hash, so, it is easy
-        #to search physicalOffsets based on the name of the section (eyecatch)
-        if ($side eq "sideless")
-        {
-            foreach my $metadata (@{$xml->{metadata}})
-            {
-                foreach my $sides (@{$metadata->{side}})
-                {
-                    $$i_physicalOffsets{side}{$sides->{id}[0]}{eyecatch}{$eyeCatch} = $physicalOffset;
-                }
-            }
-        }
-        else
-        {
-            $$i_physicalOffsets{side}{$side}{eyecatch}{$eyeCatch} = $physicalOffset;
-        }
     }
-    # Save the metadata - imageSize, blockSize, toc Information etc.
-    foreach my $metadataEl (@{$xml->{metadata}})
-    {
-        # Get meta data
-        my $imageSize   = $metadataEl->{imageSize}[0];
-        my $blockSize   = $metadataEl->{blockSize}[0];
-        my $tocSize     = $metadataEl->{tocSize}[0];
-        my $arrangement = $metadataEl->{arrangement}[0];
-        $imageSize      = getNumber($imageSize);
-        $blockSize      = getNumber($blockSize);
-        $tocSize        = getNumber($tocSize);
-        $$i_pnorLayoutRef{metadata}{imageSize}   = $imageSize;
-        $$i_pnorLayoutRef{metadata}{blockSize}   = $blockSize;
-        $$i_pnorLayoutRef{metadata}{tocSize}     = $tocSize;
-        $$i_pnorLayoutRef{metadata}{arrangement} = $arrangement;
-
-        my $numOfSides  = scalar (@{$metadataEl->{side}});
-        my $sideSize = ($imageSize)/($numOfSides);
-
-        trace(1, " $this_func: metadata: imageSize = $imageSize, blockSize=$blockSize, arrangement = $arrangement, numOfSides: $numOfSides, sideSize: $sideSize, tocSize: $tocSize");
-
-        #determine the TOC offsets from the arrangement and side Information
-        #stored in the layout xml
-        #
-        #Arrangement A-B-D means that the layout had Primary TOC (A), then backup TOC (B), then Data (pnor section information).
-        #Similaryly, arrangement A-D-B means that primary toc is followed by the data (section information) and then
-        #the backup TOC.
-        if ($arrangement eq "A-B-D")
-        {
-            my $count = 0;
-            foreach my $side (@{$metadataEl->{side}})
-            {
-                my $golden     = (exists $side->{golden} ? "yes" : "no");
-                my $sideId     = $side->{id}[0];
-                my $primaryTOC = ($sideSize)*($count);
-                my $backupTOC  = ($primaryTOC)+($tocSize);
 
-                $$i_pnorLayoutRef{metadata}{sides}{$sideId}{toc}{primary} = $primaryTOC;
-                $$i_pnorLayoutRef{metadata}{sides}{$sideId}{toc}{backup}  = $backupTOC;
-                $$i_pnorLayoutRef{metadata}{sides}{$sideId}{golden}       = $golden;
-
-                $count = $count + 1;
-                trace(1, "A-B-D: side:$sideId primaryTOC:$primaryTOC, backupTOC:$backupTOC, golden: $golden");
-            }
-        }
-        elsif ($arrangement eq "A-D-B")
-        {
-            foreach my $side (@{$metadataEl->{side}})
-            {
-                my $golden     = (exists $side->{golden} ? "yes" : "no");
-                my $sideId     = $side->{id}[0];
-                my $hbbAddr    = $$i_physicalOffsets{side}{$sideId}{eyecatch}{"HBB"};
-                my $primaryTOC = align_down($hbbAddr, $sideSize);
-                my $backupTOC  = align_up($hbbAddr, $sideSize) - $tocSize;
-
-                $$i_pnorLayoutRef{metadata}{sides}{$sideId}{toc}{primary} = $primaryTOC;
-                $$i_pnorLayoutRef{metadata}{sides}{$sideId}{toc}{backup}  = $backupTOC;
-                $$i_pnorLayoutRef{metadata}{sides}{$sideId}{golden}       = $golden;
-                trace(1, "A-D-B: side:$sideId HBB:$hbbAddr, primaryTOC:$primaryTOC, backupTOC:$backupTOC, golden: $golden");
-            }
-        }
-        else
-        {
-            trace(0, "Arrangement:$arrangement is not supported");
-            exit(1);
-        }
-    }
     return 0;
 }
 
@@ -387,6 +331,7 @@ sub createPnorImg
             $rc = 1;
             last;
         }
+
         #f{fs,part} --create tuleta.pnor --partition-offset 0 --size 8MiB --block 4KiB --force
         trace(2, "$g_fpartCmd --target $i_pnorBinName --partition-offset $i_offset --create --size $imageSize --block $blockSize --force");
         $rc = `$g_fpartCmd --target $i_pnorBinName --partition-offset $i_offset --create --size $imageSize --block $blockSize --force`;
@@ -449,6 +394,7 @@ sub addUserData
         $miscFlags |= 0x40;
     }
 
+
     #First User Data Word
     #[1:chip][1:compressType][2:dataInteg]
     my $userflags0 = ($chip << 24)
@@ -503,6 +449,7 @@ sub createPnorPartition
         {
             last;
         }
+
         #get Block size
         my $blockSize = $$i_pnorLayoutRef{metadata}{blockSize};
 
@@ -551,7 +498,7 @@ sub createPnorPartition
 
                 #Add Partition
                 #f{fs,part} --add --target tuleta.pnor --partition-offset 0 --offset 0x1000   --size 0x280000 --name HBI --flags 0x0
-                trace(2, "$this_func: $g_fpartCmd --target $i_pnorBinName --partition-offset $offset --add --offset $physicalOffset --size $physicalRegionSize --name $eyeCatch --flags 0x0");
+                trace(2, "$g_fpartCmd --target $i_pnorBinName --partition-offset $offset --add --offset $physicalOffset --size $physicalRegionSize --name $eyeCatch --flags 0x0");
                 $rc = `$g_fpartCmd --target $i_pnorBinName --partition-offset $offset --add --offset $physicalOffset --size $physicalRegionSize --name $eyeCatch --flags 0x0`;
                 if($rc)
                 {
@@ -588,67 +535,6 @@ sub createPnorPartition
 }
 
 ################################################################################
-# addTOCInfo -- adds BACKUP_PART and OTHER_SIDE information to all the TOCs
-################################################################################
-sub addTOCInfo
-{
-    my ($i_pnorLayout, $i_pnorBinName) = @_;
-    my $rc        = 0;
-    my $other_idx = 0;
-    my $sideShift = 0;
-    my @all_tocs;
-    foreach my $sideId (keys %{$$i_pnorLayout{metadata}{sides}})
-    {
-        push @all_tocs, $$i_pnorLayout{metadata}{sides}{$sideId}{toc}{primary};
-        push @all_tocs, $$i_pnorLayout{metadata}{sides}{$sideId}{toc}{backup};
-    }
-    foreach my $sideId ( keys %{$$i_pnorLayout{metadata}{sides}} )
-    {
-        my $physicalRegionSize = $$i_pnorLayout{metadata}{tocSize};
-        my $backup_part = "BACKUP_PART";
-        my $other_side  = "OTHER_SIDE";
-        my $backup_idx  = 0;
-        my $otherSide   = getOtherSide($sideId);
-        my $numOfTOCs   =  scalar keys %{$$i_pnorLayout{metadata}{sides}{$sideId}{toc}};
-
-        #Adding an extra entry in the TOC that points to its backup TOC and other side's TOC (if other side exists).
-        #This is used to search for all the TOCs in PnorRP code. The idea is to create a link between the tocs such that
-        #if we can find one valid TOC, then we can look at its  BACKUP_PART entry or OTHER_SIDE entry in the TOC to
-        #determine the location of backup TOC.Each TOC has only one BACKUP_PART entry and one OTHER_SIDE entry.
-        foreach my $toc (keys %{$$i_pnorLayout{metadata}{sides}{$sideId}{toc}})
-        {
-            #adding backup_part
-            my $toc_offset    = $$i_pnorLayout{metadata}{sides}{$sideId}{toc}{$toc};
-            my $backup_offset = $all_tocs[(($backup_idx + 1)% $numOfTOCs) + $sideShift ];
-            trace(1, "$g_fpartCmd --target $i_pnorBinName --partition-offset $toc_offset --add --offset $backup_offset --size $physicalRegionSize --name $backup_part --flags 0x0");
-            $rc = `$g_fpartCmd --target $i_pnorBinName --partition-offset $toc_offset --add --offset $backup_offset --size $physicalRegionSize --name $backup_part --flags 0x0`;
-            if($rc)
-            {
-                trace(0, "Call to add partition $backup_part failed.  rc=$rc.  Aborting!");
-                exit;
-            }
-
-            #Don't add OTHER_SIDE section if there is only one side in PNOR
-            if ((scalar keys % {$$i_pnorLayout{metadata}{sides}}) > 1)
-            {
-                #adding other_side
-                my $otherSide_offset = $all_tocs[(($other_idx + 2)% scalar @all_tocs)];
-                trace(1, "$g_fpartCmd --target $i_pnorBinName --partition-offset $toc_offset --add --offset $otherSide_offset --size $physicalRegionSize --name $other_side --flags 0x0");
-                $rc = `$g_fpartCmd --target $i_pnorBinName --partition-offset $toc_offset --add --offset $otherSide_offset --size $physicalRegionSize --name $other_side --flags 0x0`;
-                if($rc)
-                {
-                    trace(0, "Call to add partition $other_side failed.  rc=$rc.  Aborting!");
-                    exit;
-                }
-            }
-            $backup_idx++;
-            $other_idx++;
-        }
-        $sideShift = $sideShift + $numOfTOCs;
-    }
-    return $rc;
-}
-################################################################################
 # robustifyImgs - Perform any ECC or ShawHash manipulations
 ################################################################################
 sub robustifyImgs
@@ -663,24 +549,6 @@ sub robustifyImgs
 }
 
 ################################################################################
-# align_down: Align the input to the lower end of the PNOR side
-################################################################################
-sub align_down
-{
-    my ($addr,$n) = @_;
-    return (($addr) - ($addr)%($n));
-}
-
-################################################################################
-# align_up: Align the input address to the higher end of the PNOR side
-################################################################################
-sub align_up
-{
-    my ($addr,$n) = @_;
-    return ((($addr) + ($n-1)) & ~($n-1));
-}
-
-################################################################################
 # findLayoutKeyByEyeCatch - Figure out hash key based on eyeCatcher
 ################################################################################
 sub findLayoutKeyByEyeCatch
@@ -828,7 +696,7 @@ sub fillPnorImage
                 last;
             }
          }
-     }
+    }
 
     return $rc;
 }
@@ -924,7 +792,15 @@ sub getSideInfo
     my $side = "";
     my $eyeCatch = $i_sectionHash{$i_key}{eyeCatch};
 
-    $side = $i_sectionHash{$i_key}{side};
+
+    if($i_sectionHash{$i_key}{sideless} eq "yes")
+    {
+        return $SideOptions{sideless};
+    }
+    else
+    {
+        $side = $i_sectionHash{$i_key}{side};
+    }
 
     # Error paths
     if ($side eq "")
diff --git a/src/build/buildpnor/defaultPnorLayout.xml b/src/build/buildpnor/defaultPnorLayout.xml
index 897d4db..249bdb4 100644
--- a/src/build/buildpnor/defaultPnorLayout.xml
+++ b/src/build/buildpnor/defaultPnorLayout.xml
@@ -25,16 +25,12 @@
 <!--
 Layout Description
 <metadata> Element -> Contains high-level information about the PNOR layout.
-    <imageSize>    -> Size of PNOR image in bytes.
-    <blockSize>    -> size of erase blocks in bytes.
-    <tocSize>      -> size of each partition table
-    <side>         -> Contains information about the side
-        <id>            -> Id of the side (A or B)
-        <arrangement>   -> Tag that specifies the arrangement of the side
-                           (A-B-D or A-D-B)
-                           A-B-D: Primary TOC (A),Backup TOC (B), and Section Information (Data - D)
-                           A-D-B: Primary TOC (A), Section Information (Data - D), Backup TOC (B)
-        <golden/> -> Indicates that the side of the PNOR is golden
+    <imageSize>           -> Size of PNOR image in bytes.
+    <blockSize>           -> size of erase blocks in bytes.
+    <sideATocOffset>      -> Location of Side A Partition Table
+    <sideATocBackupOffset>-> Location of Side A Backup Partition Table
+    <sideBTocOffset>      -> Location of Side B Partition Table
+    <sideBTocBackupOffset>-> Location of Side B Backup Partition Table
 </metadata>
 <section> Element -> Contains information about a PNOR Partition
     <description>   -> Text description of the partition.
@@ -43,12 +39,11 @@ Layout Description
     <physicalOffset>-> Offset of the Partition in PNOR
                        in bytes.
     <physicalSize>  -> Size of the Partition in bytes.
-    <side>          -> Side that this section is associated with.
-                       could be (A, B, or sideless)
-                       A - Section is associated with side A
-                       B - Section is associated with side B
-                       sideless - Indicates partition will be in both TOCs but
-                                  only one copy of the partition should be created
+    <side>          -> Side the Partition should be associated with. This
+                       determines if the partition should be added to the
+                       partition table at <sideATocOffset> or <sideBTocOffset>
+    <sideless/>     -> Indicates partition will be in both TOCs but only one
+                       copy of the partition should be created
     <testonly/>     -> Indicates partition is used for internal testing only.
                        Partition should be skipped in production environments.
     <ecc/>          -> Indicates Partition should be ECC protected
@@ -63,18 +58,16 @@ Layout Description
     <metadata>
         <imageSize>0x4000000</imageSize>
         <blockSize>0x1000</blockSize>
-        <tocSize>0x8000</tocSize>
-        <arrangement>A-B-D</arrangement>
-        <side>
-            <id>B</id>
-        </side>
+        <!-- @TODO RTC: 120062 - Enhance meta info -->
+        <sideATocOffset>0x0</sideATocOffset>
+        <sideATocBackupOffset>0x8000</sideATocBackupOffset>
     </metadata>
     <section>
         <description>Hostboot Error Logs (144K)</description>
         <eyeCatch>HBEL</eyeCatch>
         <physicalOffset>0x10000</physicalOffset>
         <physicalRegionSize>0x24000</physicalRegionSize>
-        <side>sideless</side>
+        <sideless/>
         <ecc/>
     </section>
     <section>
@@ -82,7 +75,7 @@ Layout Description
         <eyeCatch>GUARD</eyeCatch>
         <physicalOffset>0x58000</physicalOffset>
         <physicalRegionSize>0x5000</physicalRegionSize>
-        <side>sideless</side>
+        <sideless/>
         <ecc/>
     </section>
     <section>
@@ -90,7 +83,7 @@ Layout Description
         <eyeCatch>HBD</eyeCatch>
         <physicalOffset>0x5D000</physicalOffset>
         <physicalRegionSize>0x120000</physicalRegionSize>
-        <side>sideless</side>
+        <sideless/>
         <ecc/>
     </section>
     <section>
@@ -99,7 +92,7 @@ Layout Description
         <!--NOTE: MUST update standalone.simics if offset changes -->
          <physicalOffset>0x17D000</physicalOffset>
         <physicalRegionSize>0x48000</physicalRegionSize>
-        <side>sideless</side>
+        <sideless/>
         <ecc/>
     </section>
     <section>
@@ -108,7 +101,7 @@ Layout Description
         <!--NOTE: MUST update standalone.simics if offset changes -->
         <physicalOffset>0x1C5000</physicalOffset>
         <physicalRegionSize>0x90000</physicalRegionSize>
-        <side>sideless</side>
+        <sideless/>
         <ecc/>
     </section>
     <section>
@@ -117,7 +110,7 @@ Layout Description
         <!--NOTE: MUST update standalone.simics if offset changes -->
         <physicalOffset>0x255000</physicalOffset>
         <physicalRegionSize>0x48000</physicalRegionSize>
-        <side>sideless</side>
+        <sideless/>
         <ecc/>
     </section>
     <section>
@@ -126,7 +119,7 @@ Layout Description
         <physicalOffset>0x29D000</physicalOffset>
         <physicalRegionSize>0x5A0000</physicalRegionSize>
         <sha512Version/>
-        <side>sideless</side>
+        <sideless/>
         <ecc/>
     </section>
     <section>
@@ -135,7 +128,7 @@ Layout Description
         <physicalOffset>0x83D000</physicalOffset>
         <physicalRegionSize>0x90000</physicalRegionSize>
         <sha512perEC/>
-        <side>sideless</side>
+        <sideless/>
         <ecc/>
     </section>
     <section>
@@ -144,7 +137,7 @@ Layout Description
         <physicalOffset>0x8CD000</physicalOffset>
         <physicalRegionSize>0x48000</physicalRegionSize>
         <sha512perEC/>
-        <side>sideless</side>
+        <sideless/>
         <ecc/>
     </section>
     <section>
@@ -153,7 +146,7 @@ Layout Description
         <physicalOffset>0x915000</physicalOffset>
         <physicalRegionSize>0x120000</physicalRegionSize>
         <sha512Version/>
-        <side>sideless</side>
+        <sideless/>
         <ecc/>
     </section>
     <section>
@@ -162,7 +155,7 @@ Layout Description
         <physicalOffset>0xA35000</physicalOffset>
         <physicalRegionSize>0x240000</physicalRegionSize>
         <sha512Version/>
-        <side>sideless</side>
+        <sideless/>
         <ecc/>
     </section>
     <section>
@@ -170,7 +163,7 @@ Layout Description
         <eyeCatch>PAYLOAD</eyeCatch>
         <physicalOffset>0xC75000</physicalOffset>
         <physicalRegionSize>0x1680000</physicalRegionSize>
-        <side>sideless</side>
+        <sideless/>
         <ecc/>
     </section>
     <section>
@@ -179,7 +172,7 @@ Layout Description
         <physicalOffset>0x3590000</physicalOffset>
         <physicalRegionSize>0x9000</physicalRegionSize>
         <testonly/>
-        <side>sideless</side>
+        <sideless/>
         <ecc/>
     </section>
     <section>
@@ -187,8 +180,8 @@ Layout Description
         <eyeCatch>TESTRO</eyeCatch>
         <physicalOffset>0x3599000</physicalOffset>
         <physicalRegionSize>0x9000</physicalRegionSize>
-        <side>sideless</side>
         <testonly/>
+        <sideless/>
         <preserved/>
         <readOnly/>
         <ecc/>
@@ -196,13 +189,11 @@ Layout Description
     <section>
         <description>Hostboot Base (576K)</description>
         <!--NOTE: MUST update standalone.simics if offset changes -->
-        <!--NOTE: HBB must be at pnorSize-0x99000 for a new proc
-                  part to be bootable -->
         <eyeCatch>HBB</eyeCatch>
         <physicalOffset>0x3F67000</physicalOffset>
         <physicalRegionSize>0x90000</physicalRegionSize>
         <sha512Version/>
-        <side>sideless</side>
+        <sideless/>
         <ecc/>
     </section>
     <section>
@@ -210,7 +201,7 @@ Layout Description
         <eyeCatch>GLOBAL</eyeCatch>
         <physicalOffset>0x3FF7000</physicalOffset>
         <physicalRegionSize>0x9000</physicalRegionSize>
-        <side>sideless</side>
+        <sideless/>
         <ecc/>
     </section>
 </pnor>
diff --git a/src/usr/pnor/common/ffs_hb.H b/src/usr/pnor/common/ffs_hb.H
index 30a6173..c96911b 100644
--- a/src/usr/pnor/common/ffs_hb.H
+++ b/src/usr/pnor/common/ffs_hb.H
@@ -66,8 +66,7 @@ enum
     /* Miscellaneous Bits : 1 byte */
     FFS_MISC_PRESERVED     = 0x80,    /**< Preserved across code updates */
     FFS_MISC_READ_ONLY     = 0x40,    /**< Read only section */
-    FFS_MISC_GOLDEN        = 0x01,    /**< Golden side of PNOR */
-    FFS_MISC_UNUSED        = 0x1E,    /**< Unused MISC Flags */
+    FFS_MISC_UNUSED        = 0x1F,    /**< Unused MISC Flags */
 };
 
 /**
-- 
1.8.2.2


From eea17a14de872f99c3d01a022f392b5f846fd746 Mon Sep 17 00:00:00 2001
From: Matt Ploetz <maploetz@us.ibm.com>
Date: Fri, 20 Feb 2015 11:05:03 -0600
Subject: [PATCH 09/10] Revert "Initial Support of SBE_UPDATE_INDEPENDENT Mode"

This reverts commit 002c4beefb54d288eee8faf4d9aa2b08b137aed3.
---
 src/usr/sbe/HBconfig     |  31 ++++++------
 src/usr/sbe/sbe_update.C | 126 +++++++++--------------------------------------
 2 files changed, 36 insertions(+), 121 deletions(-)

diff --git a/src/usr/sbe/HBconfig b/src/usr/sbe/HBconfig
index 952baf8..7244b31 100644
--- a/src/usr/sbe/HBconfig
+++ b/src/usr/sbe/HBconfig
@@ -1,30 +1,27 @@
 config SBE_UPDATE_SEQUENTIAL
-    default y if !SBE_UPDATE_SIMULTANEOUS && !SBE_UPDATE_INDEPENDENT
-    depends on !SBE_UPDATE_SIMULTANEOUS && !SBE_UPDATE_INDEPENDENT
+    default y if !SBE_UPDATE_SIMULTANEOUS && !SBE_UPDATE_GOLDEN
+    depends on !SBE_UPDATE_SIMULTANEOUS && !SBE_UPDATE_GOLDEN
     help
-        If an update is necessary, only 1 SBE SEEPROM per processor will be
-        updated on each IPL.  If a 2nd SBE SEEPROM needs to be updated, a re-IPL
-        will be requested.  The end result is that both SBE SEEPROMs will
-        contain the same code.
+        If an update is necessary, only 1 SBE SEEPROM will be updated on each
+        IPL per processor.  If a 2nd SBE SEEPROM needs to be updated, a re-IPL
+        will be requested.
 
 config SBE_UPDATE_SIMULTANEOUS
     default n
-    depends on !SBE_UPDATE_SEQUENTIAL && !SBE_UPDATE_INDEPENDENT
+    depends on !SBE_UPDATE_SEQUENTIAL && !SBE_UPDATE_GOLDEN
     help
-        If an update is necessary, both SBE SEEPROMs on a processor will be
-        updated at the same time before a re-IPL request is issued.  The end
-        result is that both SBE SEEPROMs will contain the same code.
+        If an update is necessary, both SBE SEEPROMs on a target will be updated
+        at the same time before a re-IPL request is issued.
 
-config SBE_UPDATE_INDEPENDENT
-    default y if TWO_SIDE_SUPPORT
+config SBE_UPDATE_GOLDEN
+    default n
     depends on !SBE_UPDATE_SEQUENTIAL && !SBE_UPDATE_SIMULTANEOUS
     help
-        If an update is necessary, and if the "current" SBE SEEPROM of this
-        IPL is not the 'GOLDEN' SBE SEEPROM, then only the current SBE SEEPROM
-        will be updated.  After the update a re-IPL request will be issued.
-        The other SBE SEEPROM, whether 'GOLDEN' or not, will not be updated.
+        If an update is necessary, only 1 SBE SEEPROM will be updated and
+        then a re-IPL request will be issued.  The other SBE SEEPROM will not
+        be touched and treated as the 'Golden' SEEPROM.
 
 config NO_SBE_UPDATES
     default n
     help
-        Don't update the SBE SEEPROMs at all.
+        Don't update the SBE SEEPROMs at all
diff --git a/src/usr/sbe/sbe_update.C b/src/usr/sbe/sbe_update.C
index a2fad1e..698d41a 100644
--- a/src/usr/sbe/sbe_update.C
+++ b/src/usr/sbe/sbe_update.C
@@ -354,10 +354,6 @@ namespace SBE
                     errlCommit( err, SBE_COMP_ID );
                 }
 
-#ifdef CONFIG_BMC_IPMI
-                // @todo RTC 120734 reset system's reboot count via IPMI sensor
-#endif
-
                 TRACFCOMP( g_trac_sbe,
                            INFO_MRK"updateProcessorSbeSeeproms(): Calling "
                            "INITSERVICE::doShutdown() with "
@@ -685,9 +681,6 @@ namespace SBE
 
         do{
 
-            // @todo RTC 120734 - before customizing, ensure correct HBB address
-            // is set in the necessary attribute
-
             // cast OUR type of target to a FAPI type of target.
             const fapi::Target
               l_fapiTarg(fapi::TARGET_TYPE_PROC_CHIP,
@@ -1942,6 +1935,7 @@ namespace SBE
             }
 
 
+
             /**************************************************************/
             /*  Compare SEEPROM 1 with PNOR and Customized Image CRC --   */
             /*  -- dirty or clean?                                        */
@@ -2145,91 +2139,25 @@ namespace SBE
         io_sbeState.update_actions   = CLEAR_ACTIONS;
         io_sbeState.seeprom_side_to_update = EEPROM::LAST_CHIP_TYPE;
 
+        // @todo RTC 107721 - Need to handle Habanero 'golden' SEEPROM side
+
         do{
 
             // To be safe, we're only look at the bits defined in sbe_update.H
             i_system_situation &= SITUATION_ALL_BITS_MASK;
 
-#ifdef CONFIG_SBE_UPDATE_INDEPENDENT
-
-            // The 2 SBE SEEPROMs are independent of each other
-            // Determine if PNOR is 1- or 2-sided and if there is a
-            // GOLDEN boot involved
-
-#ifdef CONFIG_TWO_SIDE_SUPPORT
-
-            // @todo RTC 120734 - ask PNOR if we are in "GOLDEN" mode,
-            // which would mean that we are booting off the the GOLDEN
-            // SBE SEEPROM which corresponds to the GOLDEN side of PNOR
-/*
-            if (true)
-            {
-                // If true, nothing to do (covered in istep 6 function)
-                l_actions = CLEAR_ACTIONS;
-
-                TRACFCOMP( g_trac_sbe, INFO_MRK"SBE Update tgt=0x%X: "
-                           "Booting GOLDEN SBE SEEPROM in PNOR 2-sided Mode. "
-                           "No updates for cur side=%d. Continue IPL. "
-                           "(sit=0x%.2X, act=0x%.8X flags=0x%.2X)",
-                           TARGETING::get_huid(io_sbeState.target),
-                           io_sbeState.cur_seeprom_side,
-                           i_system_situation, l_actions,
-                           io_sbeState.mvpdSbKeyword.flags);
-                break;
-            }
-            else // proceed to update this side
-            {
-                TRACUCOMP( g_trac_sbe, INFO_MRK"SBE Update tgt=0x%X: "
-                           "NOT Booting GOLDEN SBE SEEPROM in PNOR 2-sided "
-                           "mode. Checking for update on cur side=%d ",
-                           TARGETING::get_huid(io_sbeState.target),
-                           io_sbeState.cur_seeprom_side)
-            }
-*/
-#else
-
-            // @todo RTC 120734 - check this assumption
-            // Assume that we're only checking/updating the current side
-            TRACUCOMP( g_trac_sbe, INFO_MRK"SBE Update tgt=0x%X: "
-                       "PNOR 1-sided so only check for update on cur side=%d",
-                       TARGETING::get_huid(io_sbeState.target),
-                       io_sbeState.cur_seeprom_side);
-#endif
-
-            // Check for clean vs. dirty only on cur side
-            if ( i_system_situation & SITUATION_CUR_IS_DIRTY )
-            {
-                //  Update cur side and re-ipl
-                l_actions |= IPL_RESTART;
-                l_actions |= DO_UPDATE;
-                l_actions |= UPDATE_SBE;
-
-                // Set Update side to cur
-                io_sbeState.seeprom_side_to_update =
-                                ( io_sbeState.cur_seeprom_side ==
-                                              PNOR::SBE_SEEPROM0 )
-                                  ? EEPROM::SBE_PRIMARY : EEPROM::SBE_BACKUP;
-
-                TRACFCOMP( g_trac_sbe, INFO_MRK"SBE Update tgt=0x%X: "
-                           "cur side (%d) dirty. Update cur. Re-IPL. "
-                           "(sit=0x%.2X, act=0x%.8X flags=0x%.2X)",
-                           TARGETING::get_huid(io_sbeState.target),
-                           io_sbeState.cur_seeprom_side,
-                           i_system_situation, l_actions,
-                           io_sbeState.mvpdSbKeyword.flags);
-            }
-            else
-            {
-                // Cur side clean - No Updates - Continue IPL
-                l_actions = CLEAR_ACTIONS;
+#ifdef CONFIG_SBE_UPDATE_GOLDEN
+            // @todo RTC 107721 - Need to handle Habanero 'golden' SEEPROM side
+            // For now default to no update and continue IPL
+                    l_actions = CLEAR_ACTIONS;
 
-                TRACFCOMP( g_trac_sbe, INFO_MRK"SBE Update tgt=0x%X: "
-                           "cur side (%d) clean-no updates. "
-                           "Continue IPL. (sit=0x%.2X, act=0x%.8X)",
-                           TARGETING::get_huid(io_sbeState.target),
-                           io_sbeState.cur_seeprom_side,
-                           i_system_situation, l_actions);
-            }
+                    TRACFCOMP( g_trac_sbe, INFO_MRK"SBE Update tgt=0x%X: "
+                               "Habanero 'GOLDEN' Seeprom Support to come. "
+                               "For now no updates. cur side=%d. "
+                               "Continue IPL. (sit=0x%.2X, act=0x%.8X)",
+                               TARGETING::get_huid(io_sbeState.target),
+                               io_sbeState.cur_seeprom_side,
+                               i_system_situation, l_actions);
 
 #elif CONFIG_SBE_UPDATE_SIMULTANEOUS
             // Updates both SEEPROMs if either side is dirty
@@ -2324,8 +2252,7 @@ namespace SBE
 
                     // Set Update side to alt
                     io_sbeState.seeprom_side_to_update =
-                                ( io_sbeState.alt_seeprom_side ==
-                                              PNOR::SBE_SEEPROM0 )
+                                ( io_sbeState.alt_seeprom_side == PNOR::SBE_SEEPROM0 )
                                   ? EEPROM::SBE_PRIMARY : EEPROM::SBE_BACKUP ;
 
                     // Update MVPD PERMANENT flag: make cur=perm
@@ -2371,8 +2298,7 @@ namespace SBE
 
                     // Set Update side to alt
                     io_sbeState.seeprom_side_to_update =
-                                ( io_sbeState.alt_seeprom_side ==
-                                              PNOR::SBE_SEEPROM0 )
+                                ( io_sbeState.alt_seeprom_side == PNOR::SBE_SEEPROM0 )
                                   ? EEPROM::SBE_PRIMARY : EEPROM::SBE_BACKUP ;
 
 
@@ -2432,8 +2358,7 @@ namespace SBE
 
                     // Set Update side to alt
                     io_sbeState.seeprom_side_to_update =
-                                ( io_sbeState.alt_seeprom_side ==
-                                              PNOR::SBE_SEEPROM0 )
+                                ( io_sbeState.alt_seeprom_side == PNOR::SBE_SEEPROM0 )
                                   ? EEPROM::SBE_PRIMARY : EEPROM::SBE_BACKUP ;
 
                     // Update MVPD RE-IPL SEEPROM flag: re-IPL on ALT:
@@ -2530,8 +2455,7 @@ namespace SBE
 
                         // Set Update side to alt
                         io_sbeState.seeprom_side_to_update =
-                                ( io_sbeState.alt_seeprom_side ==
-                                              PNOR::SBE_SEEPROM0 )
+                                ( io_sbeState.alt_seeprom_side == PNOR::SBE_SEEPROM0 )
                                   ? EEPROM::SBE_PRIMARY : EEPROM::SBE_BACKUP ;
 
                         // Update MVPD RE-IPL SEEPROM flag: re-IPL on ALT:
@@ -2567,8 +2491,7 @@ namespace SBE
 
                     // Set Update side to alt
                     io_sbeState.seeprom_side_to_update =
-                                ( io_sbeState.alt_seeprom_side ==
-                                              PNOR::SBE_SEEPROM0 )
+                                ( io_sbeState.alt_seeprom_side == PNOR::SBE_SEEPROM0 )
                                   ? EEPROM::SBE_PRIMARY : EEPROM::SBE_BACKUP ;
 
                     TRACFCOMP( g_trac_sbe, INFO_MRK"SBE Update tgt=0x%X: "
@@ -3278,8 +3201,7 @@ namespace SBE
 
                     // Compare against 'current' Master side in case there is
                     // an issue with the other side
-                    if (io_sbeStates_v[i].cur_seeprom_side ==
-                                          PNOR::SBE_SEEPROM0)
+                    if (io_sbeStates_v[i].cur_seeprom_side == PNOR::SBE_SEEPROM0)
                     {
                         ver_ptr =
                             &(io_sbeStates_v[i].seeprom_0_ver.image_version);
@@ -3323,9 +3245,6 @@ namespace SBE
                 // Special Master Processor checks
                 if ( i == mP )
                 {
-// Skip Master Processor check of Both SEEPROMs being identical
-#ifndef CONFIG_SBE_UPDATE_INDEPENDENT
-
                     // Compare Versions of Both SEEPROMs to PNOR Version
                     // Create a Predictive Error if there's an issue
                     if ((0 != memcmp(
@@ -3420,15 +3339,14 @@ namespace SBE
                         errlCommit( err, SBE_COMP_ID );
 
                     } // end of check
-#endif
+
                     // Continue to avoid remaining non-Master Processor checks
                     continue;
                 }
                 else
                 {
                     // Not Master, so get 'current' version
-                    if (io_sbeStates_v[i].cur_seeprom_side ==
-                                          PNOR::SBE_SEEPROM0)
+                    if (io_sbeStates_v[i].cur_seeprom_side == PNOR::SBE_SEEPROM0)
                     {
                         ver_ptr =
                             &(io_sbeStates_v[i].seeprom_0_ver.image_version);
-- 
1.8.2.2


From 7820949b6720adb1b92f87175d373d1b01eea83a Mon Sep 17 00:00:00 2001
From: Matt Ploetz <maploetz@us.ibm.com>
Date: Fri, 20 Feb 2015 11:05:11 -0600
Subject: [PATCH 10/10] Revert "Support for Redundant Copy of HB code in PNOR"

This reverts commit 67c5a1ebe73f81bca1bb6608bbb8f204f0f37fa8.
---
 src/build/buildpnor/buildpnor.pl            | 590 +++++++++++-----------------
 src/build/buildpnor/defaultPnorLayout.xml   |  91 ++---
 src/build/mkrules/hbfw/img/makefile         |   4 +-
 src/include/usr/hwas/hwasPlatDeconfigGard.H |  19 +-
 src/include/usr/pnor/pnor_reasoncodes.H     |   2 -
 src/include/usr/pnor/pnorif.H               |  39 +-
 src/usr/hwas/hwasPlatDeconfigGard.C         |  89 +----
 src/usr/pnor/HBconfig                       |   5 -
 src/usr/pnor/common/ffs_hb.H                |   7 +-
 src/usr/pnor/makefile                       |   1 -
 src/usr/pnor/pnor_common.C                  | 182 ++-------
 src/usr/pnor/pnor_common.H                  |  19 +-
 src/usr/pnor/pnorrp.C                       | 152 +++----
 src/usr/pnor/pnorrp.H                       |  26 +-
 src/usr/pnor/pnorsbe.C                      |  87 ----
 src/usr/pnor/pnorvalid.C                    |   5 +-
 src/usr/pnor/runtime/rt_pnor.C              |  11 +-
 src/usr/pnor/runtime/rt_pnor.H              |   2 +-
 src/usr/pnor/test/pnorrptest.H              | 104 +----
 src/usr/sbe/sbe_update.C                    |  95 +++--
 src/usr/sbe/sbe_update.H                    |  38 +-
 src/usr/sbe/test/sbeupdatetest.H            |  24 +-
 22 files changed, 535 insertions(+), 1057 deletions(-)
 delete mode 100644 src/usr/pnor/pnorsbe.C

diff --git a/src/build/buildpnor/buildpnor.pl b/src/build/buildpnor/buildpnor.pl
index f6df6c8..51b6922 100755
--- a/src/build/buildpnor/buildpnor.pl
+++ b/src/build/buildpnor/buildpnor.pl
@@ -6,7 +6,7 @@
 #
 # OpenPOWER HostBoot Project
 #
-# Contributors Listed Below - COPYRIGHT 2012,2015
+# Contributors Listed Below - COPYRIGHT 2012,2014
 # [+] International Business Machines Corp.
 #
 #
@@ -62,20 +62,16 @@ my $g_trace = 1;
 my $programName = File::Basename::basename $0;
 my %pnorLayout;
 my %binFiles;
+
+
 my $pnorLayoutFile;
 my $pnorBinName = "";
 my $tocVersion = 0x1;
 my $g_TOCEyeCatch = "part";
 my $emitTestSections = 0;
+my $g_ffsCmd = "";
 my $g_fpartCmd = "";
 my $g_fcpCmd = "";
-my %sidelessSecFilled = ();
-
-my %SideOptions = (
-        A => "A",
-        B => "B",
-        sideless => "sideless",
-    );
 
 if ($#ARGV < 0) {
     usage();
@@ -106,6 +102,9 @@ for (my $i=0; $i < $#ARGV + 1; $i++)
         my $argVal = $ARGV[++$i];
         saveInputFile("--binFile", $argName, $argVal, \%binFiles);
     }
+    elsif($ARGV[$i] =~ /--ffsCmd/) {
+        $g_ffsCmd = $ARGV[++$i];
+    }
     elsif($ARGV[$i] =~ /--fpartCmd/) {
         $g_fpartCmd = $ARGV[++$i];
     }
@@ -122,14 +121,12 @@ for (my $i=0; $i < $#ARGV + 1; $i++)
     }
 }
 
-############################## Begin Actions ##################################
-
-#Delete File (pnorBinName) if exists to prevent errors when making layout
-#changes
-if (-e $pnorBinName)
-{
-    unlink $pnorBinName or warn "Could not unlink $pnorBinName: $!";
-}
+#Extract ffs version number from help text.
+#Use to trigger using proper input parms..
+#my $ffsParms = 0;
+#my $ffsVersion = `$g_ffsCmd 2>&1  | grep "Partition Tool" `;
+#$ffsVersion =~ s/.*(v[0-9\.]*).*/\1/;
+#$ffsVersion = $1;
 
 #Load PNOR Layout XML file
 my $rc = loadPnorLayout($pnorLayoutFile, \%pnorLayout);
@@ -139,6 +136,9 @@ if($rc != 0)
     exit 1;
 }
 
+#trace(1, Dumper(%pnorLayout->{1576960}));
+#trace(1, Dumper(%binFiles));
+
 #Verify all the section files exist
 my $rc = verifyFilesExist(\%pnorLayout, \%binFiles);
 if($rc != 0)
@@ -161,48 +161,42 @@ if($rc != 0)
     trace(0, "Error detected from call to checkSpaceConstraints().  Exiting");
     exit 1;
 }
-trace(1, "Done checkSpaceConstraints");
-
-# @TODO RTC: 120062 - Determine which side is Golden, possibly handle a new
-#                    xml tag
-# Create all Partition Tables at each TOC offset
-# Each side has 2 TOC's created at different offsets for backup purposes.
-# Loop all side sections
-foreach my $sideId ( keys %{$pnorLayout{metadata}{sides}} )
+
+#create the PNOR image
+#two copies of TOC created at different offsets
+my $sideAOffset =  $pnorLayout{metadata}{sideAOffset};
+my $sideBOffset =  $pnorLayout{metadata}{sideBOffset};
+
+$rc = createPnorImg($tocVersion, $pnorBinName, \%pnorLayout, $sideAOffset, 'A');
+if($rc != 0)
 {
-    # Loop all tocs (primary and backup)
-    foreach my $toc ( keys %{$pnorLayout{metadata}{sides}{$sideId}{toc}})
-    {
-        my $tocOffset = $pnorLayout{metadata}{sides}{$sideId}{toc}{$toc};
+    trace(0, "Error detected from createPnorImg() sideAOffset. Exiting");
+    exit 1;
+}
 
-        $rc = createPnorPartition($tocVersion, $pnorBinName, \%pnorLayout,
-                                  $sideId, $tocOffset);
-        if($rc != 0)
-        {
-            trace(0, "Error detected from createPnorPartition() $tocOffset Exiting");
-            exit 1;
-        }
-    }
+$rc = createPnorImg($tocVersion, $pnorBinName, \%pnorLayout, $sideBOffset, 'B');
+if($rc != 0)
+{
+    trace(0, "Error detected from createPnorImg() sideBOffset. Exiting");
+    exit 1;
 }
 
-# Fill all sides
-foreach my $sideId ( keys %{$pnorLayout{metadata}{sides}} )
+$rc = fillPnorImage($pnorBinName, \%pnorLayout, \%binFiles, $sideAOffset, 'A');
+if($rc != 0)
 {
-    my $tocOffset = $pnorLayout{metadata}{sides}{$sideId}{toc}{primary};
+    trace(0, "Error detected from call to fillPnorImage() sideAOffset. Exiting");
+    exit 1;
+}
 
-    $rc = fillPnorImage($pnorBinName, \%pnorLayout, \%binFiles, $sideId,
-                        $tocOffset);
-    if($rc != 0)
-    {
-        trace(0, "Error detected from call to fillPnorImage() sideATocOffset. Exiting");
-        exit 1;
-    }
+$rc = fillPnorImage($pnorBinName, \%pnorLayout, \%binFiles, $sideBOffset, 'B');
+if($rc != 0)
+{
+    trace(0, "Error detected from call to fillPnorImage() sideBOffset. Exiting");
+    exit 1;
 }
 
 exit 0;
 
-#########################  Begin Utility Subroutines ###########################
-
 ################################################################################
 # loadPnorLayout
 ################################################################################
@@ -221,52 +215,33 @@ sub loadPnorLayout
     my $xs = new XML::Simple(keyattr=>[], forcearray => 1);
     my $xml = $xs->XMLin($i_pnorFile);
 
+    #trace(1, "pnorLayoutXML \n ".Dumper($xml));
+
     #Save the meatadata - imageSize, blockSize, etc.
-    # @TODO RTC:120062 enhance metadata section, fix metadataE1 to match xml
-    # and change TOC names accordingly
     foreach my $metadataEl (@{$xml->{metadata}})
     {
-        # Get meta data
         my $imageSize = $metadataEl->{imageSize}[0];
         my $blockSize = $metadataEl->{blockSize}[0];
+        my $sideAOffset = $metadataEl->{sideAOffset}[0];
+        my $sideBOffset = $metadataEl->{sideBOffset}[0];
+
+        trace(3, "$this_func: metadata: imageSize = $imageSize, blockSize=$blockSize, sideAOffset=$sideAOffset, sideBOffset=$sideBOffset");
+
         $imageSize = getNumber($imageSize);
         $blockSize = getNumber($blockSize);
+        $sideAOffset = getNumber($sideAOffset);
+        $sideBOffset = getNumber($sideBOffset);
+
         $$i_pnorLayoutRef{metadata}{imageSize} = $imageSize;
         $$i_pnorLayoutRef{metadata}{blockSize} = $blockSize;
-
-        # Get Side A
-        my $sideATocOffset = $metadataEl->{sideATocOffset}[0];
-        my $sideATocBackupOffset = $metadataEl->{sideATocBackupOffset}[0];
-        $sideATocOffset = getNumber($sideATocOffset);
-        $sideATocBackupOffset = getNumber($sideATocBackupOffset);
-        # @TODO RTC: 120062 change pnorLayoutRef hash to match new xml
-        $$i_pnorLayoutRef{metadata}{sides}{$SideOptions{A}}{toc}{primary} = $sideATocOffset;
-        $$i_pnorLayoutRef{metadata}{sides}{$SideOptions{A}}{toc}{backup} = $sideATocBackupOffset;
-
-        # Get side B info (if it exists)
-        if (exists $metadataEl->{sideBTocOffset}[0])
-        {
-            trace(1, "Adding Side B information ....");
-            my $sideBTocOffset = $metadataEl->{sideBTocOffset}[0];
-            my $sideBTocBackupOffset = $metadataEl->{sideBTocBackupOffset}[0];
-            $sideBTocOffset = getNumber($sideBTocOffset);
-            $sideBTocBackupOffset = getNumber($sideBTocBackupOffset);
-            # @TODO RTC: 120062 change pnorLayoutRef hash to match new xml
-            $$i_pnorLayoutRef{metadata}{sides}{$SideOptions{B}}{toc}{primary} = $sideBTocOffset;
-            $$i_pnorLayoutRef{metadata}{sides}{$SideOptions{B}}{toc}{backup} = $sideBTocBackupOffset;
-
-            trace(3, "$this_func: metadata: imageSize = $imageSize, blockSize=$blockSize, sideATocOffset=$sideATocOffset, sideATocBackupOffset=$sideATocBackupOffset, sideBTocOffset=$sideBTocOffset, sideBTocBackupOffset=$sideBTocBackupOffset");
-        }
-        else
-        {
-           trace(3, "$this_func: metadata: imageSize = $imageSize, blockSize=$blockSize, sideATocOffset=$sideATocOffset, sideATocBackupOffset=$sideATocBackupOffset");
-        }
-
+        $$i_pnorLayoutRef{metadata}{sideAOffset} = $sideAOffset;
+        $$i_pnorLayoutRef{metadata}{sideBOffset} = $sideBOffset;
     }
 
     #Iterate over the <section> elements.
     foreach my $sectionEl (@{$xml->{section}})
     {
+        #trace(1, "current Element: \n ".Dumper($sectionEl));
         my $description = $sectionEl->{description}[0];
         my $eyeCatch = $sectionEl->{eyeCatch}[0];
         my $physicalOffset = $sectionEl->{physicalOffset}[0];
@@ -276,9 +251,7 @@ sub loadPnorLayout
         my $ecc = (exists $sectionEl->{ecc} ? "yes" : "no");
         my $sha512Version = (exists $sectionEl->{sha512Version} ? "yes" : "no");
         my $sha512perEC = (exists $sectionEl->{sha512perEC} ? "yes" : "no");
-        my $sideless = (exists $sectionEl->{sideless} ? "yes" : "no");
-        my $preserved = (exists $sectionEl->{preserved} ? "yes" : "no");
-        my $readOnly = (exists $sectionEl->{readOnly} ? "yes" : "no");
+
         if (($emitTestSections == 0) && ($sectionEl->{testonly}[0] eq "yes"))
         {
             next;
@@ -289,6 +262,8 @@ sub loadPnorLayout
         $physicalOffset = getNumber($physicalOffset);
         $physicalRegionSize = getNumber($physicalRegionSize);
 
+        # trace(4, "$this_func: physicalOffset=$physicalOffset, physicalRegionSize=$physicalRegionSize");
+
         $$i_pnorLayoutRef{sections}{$physicalOffset}{description} = $description;
         $$i_pnorLayoutRef{sections}{$physicalOffset}{eyeCatch} = $eyeCatch;
         $$i_pnorLayoutRef{sections}{$physicalOffset}{physicalOffset} = $physicalOffset;
@@ -297,9 +272,6 @@ sub loadPnorLayout
         $$i_pnorLayoutRef{sections}{$physicalOffset}{ecc} = $ecc;
         $$i_pnorLayoutRef{sections}{$physicalOffset}{sha512Version} = $sha512Version;
         $$i_pnorLayoutRef{sections}{$physicalOffset}{sha512perEC} = $sha512perEC;
-        $$i_pnorLayoutRef{sections}{$physicalOffset}{sideless} = $sideless;
-        $$i_pnorLayoutRef{sections}{$physicalOffset}{preserved} = $preserved;
-        $$i_pnorLayoutRef{sections}{$physicalOffset}{readOnly} = $readOnly;
 
     }
 
@@ -307,16 +279,23 @@ sub loadPnorLayout
 }
 
 ################################################################################
-# createPnorImg - Create PNOR image based on input data.
+# createPnorImg - Create PNOR image and partitions based on input data.
 ################################################################################
 sub createPnorImg
 {
-    my ($i_tocVersion, $i_pnorBinName, $i_pnorLayoutRef, $i_offset) = @_;
+    my ($i_tocVersion, $i_pnorBinName, $i_pnorLayoutRef, $offset, $side) = @_;
     my $this_func = (caller(0))[3];
     my $rc = 0;
+    my $key;
+    my $other_side = 'B';
     trace(4, "$this_func: >>Enter");
 
-    trace(1, "createPnorImg:: $i_offset");
+    trace(1, "createPnorImg:: $offset");
+
+    if($side eq 'B')
+    {
+        $other_side = 'A';
+    }
 
     #get Block size
     my $blockSize = $$i_pnorLayoutRef{metadata}{blockSize};
@@ -324,212 +303,154 @@ sub createPnorImg
     #Get size of image in blocks
     my $imageSize = $$i_pnorLayoutRef{metadata}{imageSize};
     my $blockCount = $imageSize/$blockSize;
-    do{
-        if ($blockCount != int($blockCount))
-        {
-            trace(0, "$this_func: Image size ($imageSize) is not an even multiple of erase blocks ($blockSize).  This is not supported.  Aborting!");
-            $rc = 1;
-            last;
-        }
-
-        #f{fs,part} --create tuleta.pnor --partition-offset 0 --size 8MiB --block 4KiB --force
-        trace(2, "$g_fpartCmd --target $i_pnorBinName --partition-offset $i_offset --create --size $imageSize --block $blockSize --force");
-        $rc = `$g_fpartCmd --target $i_pnorBinName --partition-offset $i_offset --create --size $imageSize --block $blockSize --force`;
-        if($rc)
-        {
-            trace(0, "$this_func: Call to creating image failed.  rc=$rc.  Aborting!");
-            last;
-        }
-    }while(0);
-
-    return $rc;
-}
-
-################################################################################
-# addUserData - Add partition user data.
-################################################################################
-sub addUserData
-{
-    my $i_pnorBinName = shift;
-    my $i_offset = shift;
-    my $i_key = shift;
-    my %i_sectionHash = @_;
-
-    my $this_func = (caller(0))[3];
-    my $rc = 0;
-    trace(4, "$this_func: >>Enter");
-
-    my $eyeCatch = $i_sectionHash{$i_key}{eyeCatch};
-
-    # User data Flags based on FFS entry user data (ffs_hb_user_t)
-    my $chip = 0;
-    my $compressType = 0;
-    my $dataInteg = 0;
-    my $verCheck = 0;
-    my $miscFlags = 0;
-
-    # DataInteg flag
-    if( ($i_sectionHash{$i_key}{ecc} eq "yes") )
-    {
-        $dataInteg = 0x8000;
-    }
-
-    # VerCheck Flag
-    if( ($i_sectionHash{$i_key}{sha512Version} eq "yes") )
+    if ($blockCount != int($blockCount))
     {
-        $verCheck = 0x80;
-    }
-    elsif( ($i_sectionHash{$i_key}{sha512perEC} eq "yes") )
-    {
-        $verCheck = 0x40;
+        trace(0, "$this_func: Image size ($imageSize) is not an even multiple of erase blocks ($blockSize).  This is not supported.  Aborting!");
+        $rc = 1;
+        return $rc;
     }
 
-    # Misc Flags
-    if( ($i_sectionHash{$i_key}{preserved} eq "yes") )
-    {
-        $miscFlags |= 0x80;
+    #f{fs,part} --create tuleta.pnor --partition-offset 0 --size 8MiB --block 4KiB --force
+    if ($g_ffsCmd eq "") {
+        my $Out = `$g_fpartCmd --target $i_pnorBinName --partition-offset $offset --create --size $imageSize --block $blockSize --force`;
+    } else {
+        my $Out = `$g_ffsCmd --target $i_pnorBinName --partition-offset $offset --create --size $imageSize --block $blockSize --force`;
     }
-    if( ($i_sectionHash{$i_key}{readOnly} eq "yes") )
+    $rc = $?;
+    if($rc)
     {
-        $miscFlags |= 0x40;
+        trace(0, "$this_func: Call to creating image failed.  rc=$rc.  Aborting!");
+        return $rc;
     }
 
+    #key into hash data is the physical offset of section.  Need to sort the keys
+    #so we put things in the correct order in toc.
+    #Generally speaking, this loop is populating the FFS Header with records based on the
+    #section data specified in the XML + actual sizes of the input binary files.
+    my %sectionHash = %{$$i_pnorLayoutRef{sections}};
 
-    #First User Data Word
-    #[1:chip][1:compressType][2:dataInteg]
-    my $userflags0 = ($chip << 24)
-      | ($compressType << 16)
-      | $dataInteg;
+    for $key ( sort {$a<=> $b} keys %sectionHash)
+    {
+        my $eyeCatch = "UNDEF";
+        my $physicalOffset = 0xFFFFFFFF;
+        my $physicalRegionSize = 0xFFFFFFFF;
 
-    #Second User Data Word
-    #[1:sha512Version/sha512perEC][1:miscFlags]
-    my $userflags1 = ($verCheck << 24)
-        | ($miscFlags << 16);
+        # eyecatcher
+        my $eyeCatch = $sectionHash{$key}{eyeCatch};
+        my $myside = $sectionHash{$key}{side};
 
-    do{
-        trace(2, "$g_fpartCmd --target $i_pnorBinName --partition-offset $i_offset --user 0 --name $eyeCatch --value userflags0=$userflags0");
-        $rc = `$g_fpartCmd --target $i_pnorBinName --partition-offset $i_offset --user 0 --name $eyeCatch --value $userflags0`;
-        if($rc)
-        {
-            trace(0, "$this_func: Call to add userdata to $eyeCatch failed.  rc=$rc.  Aborting!");
-            last;
-        }
-        trace(2, "$g_fpartCmd --target $i_pnorBinName --partition-offset $i_offset --user 1 --name $eyeCatch --value userflags1=$userflags1");
-        $rc = `$g_fpartCmd --target $i_pnorBinName --partition-offset $i_offset --user 1 --name $eyeCatch --value $userflags1`;
-        if($rc)
+        #don't try to add the TOC, but need to update all other paritions
+        #Add if side matches (or not set) -- so if it isn't equal to other side
+        if(( $eyeCatch ne $g_TOCEyeCatch ) && ( $myside ne $other_side ))
         {
-            trace(0, "$this_func: Call to add userdata to $eyeCatch failed.  rc=$rc.  Aborting!");
-            last;
-        }
-    }while(0);
-
-    return $rc;
-}
-
-################################################################################
-# createPnorPartition - Create PNOR partitions based on input data.
-################################################################################
-sub createPnorPartition
-{
-    my ($i_tocVersion, $i_pnorBinName, $i_pnorLayoutRef, $side, $offset) = @_;
-    my $this_func = (caller(0))[3];
-    my $rc = 0;
-    my $key;
-    my $other_side = getOtherSide($side);
 
-    trace(4, "$this_func: >>Enter");
-
-    trace(1, "createPnorPartition:: $offset");
-
-    do{
-        # Create pnor image at partition offset
-        $rc = createPnorImg($i_tocVersion, $i_pnorBinName, $i_pnorLayoutRef,
-                            $offset);
-        if($rc)
-        {
-            last;
-        }
+            # base/physical offset
+            my $physicalOffset = $sectionHash{$key}{physicalOffset};
+            #make sure offset is on a block boundary
+            my $val = $physicalOffset/$blockSize;
+            if ($val != int($val))
+            {
+                trace(0, "$this_func: Partition offset ($val) is does not fall on an erase block ($blockSize) boundary.  This is not supported.  Aborting!");
+                $rc = -1;
+                last;
+            }
 
-        #get Block size
-        my $blockSize = $$i_pnorLayoutRef{metadata}{blockSize};
+            #physical size
+            my $physicalRegionSize = $sectionHash{$key}{physicalRegionSize};
+            $val = $physicalRegionSize/$blockSize;
+            if($val != int($val))
+            {
+                trace(0, "$this_func: Partition size ($val) is not an even multiple of erase blocks ($blockSize).  This is not supported.  Aborting!");
+                exit 1;
+            }
 
-        # key into hash data is the physical offset of section.  Need to sort the
-        # keys so we put things in the correct order in toc. Generally speaking,
-        # this loop is populating the FFS Header with records based on the section
-        # data specified in the XML + actual sizes of the input binary files.
-        my %sectionHash = %{$$i_pnorLayoutRef{sections}};
+            #Add Partition
+            #f{fs,part} --add --target tuleta.pnor --partition-offset 0 --offset 0x1000   --size 0x280000 --name HBI --flags 0x0
+            if ($g_ffsCmd eq "") {
+                trace(1, "$g_fpartCmd --target $i_pnorBinName --partition-offset $offset --add --offset $physicalOffset --size $physicalRegionSize --name $eyeCatch --flags 0x0");
+                my $Out = `$g_fpartCmd --target $i_pnorBinName --partition-offset $offset --add --offset $physicalOffset --size $physicalRegionSize --name $eyeCatch --flags 0x0`;
+            } else {
+                my $Out = `$g_ffsCmd --target $i_pnorBinName --partition-offset $offset --add --offset $physicalOffset --size $physicalRegionSize --name $eyeCatch --flags 0x0`;
+            }
+            $rc = $?;
+            if($rc)
+            {
+                trace(0, "$this_func: Call to add partition $eyeCatch failed.  rc=$rc.  Aborting!");
+                last;
+            }
 
-        for $key ( sort {$a<=> $b} keys %sectionHash)
-        {
-            my $eyeCatch = "UNDEF";
-            my $physicalOffset = 0xFFFFFFFF;
-            my $physicalRegionSize = 0xFFFFFFFF;
+            # User data Flags
+            my $chip = 0;
+            my $compress = 0;
+            my $ecc = 0;
+            my $version = 0;
 
-            # eyecatcher
-            my $eyeCatch = $sectionHash{$key}{eyeCatch};
+            if( ($sectionHash{$key}{ecc} eq "yes") )
+            {
+                $ecc = 0x8000;
+            }
+            if( ($sectionHash{$key}{sha512Version} eq "yes") )
+            {
+                $version = 0x80;
+            }
+            elsif( ($sectionHash{$key}{sha512perEC} eq "yes") )
+            {
+                $version = 0x40;
+            }
 
-            my $sideInfo = getSideInfo($key, %sectionHash);
+            #First User Data Word
+            #[1:chip][1:compression][2:ecc]
+            my $userflags0 = ($chip << 24)
+              | ($compress << 16)
+              | $ecc;
+
+            #Second User Data Word
+            #[1:sha512Version/sha512perEC]
+            my $userflags1 = ($version << 24);
+
+            trace(1,"userflags0 = $userflags0");
+            trace(1,"userflags1 = $userflags1");
+            if ($g_ffsCmd eq "") {
+                trace(1, "$g_fpartCmd --target $i_pnorBinName --partition-offset $offset --user 0 --name $eyeCatch --value $userflags0");
+                my $Out = `$g_fpartCmd --target $i_pnorBinName --partition-offset $offset --user 0 --name $eyeCatch --value $userflags0`;
+                trace(1, "$g_fpartCmd --target $i_pnorBinName --partition-offset $offset --user 1 --name $eyeCatch --value $userflags1");
+                my $Out = `$g_fpartCmd --target $i_pnorBinName --partition-offset $offset --user 1 --name $eyeCatch --value $userflags1`;
+            }
+            $rc = $?;
+            if($rc)
+            {
+                trace(0, "$this_func: Call to add userdata to $eyeCatch failed.  rc=$rc.  Aborting!");
+                last;
+            }
 
-            #don't try to add the TOC, but need to update all other paritions
-            #Add if side matches (or not set) -- so if it isn't equal to other side
-            #Also add if sideless
-            if( ($eyeCatch ne $g_TOCEyeCatch ) &&
-                ($sideInfo ne $other_side ))
+            #Trunc Partition
+            #f{fs,part} --target tuleta.pnor --partition-offset 0 --name HBI --trunc
+            if ($g_ffsCmd eq "") {
+                my $Out = `$g_fpartCmd --target $i_pnorBinName --partition-offset $offset --trunc --name $eyeCatch`;
+            } else {
+                my $Out = `$g_ffsCmd --target $i_pnorBinName --partition-offset $offset --trunc --name $eyeCatch`;
+            }
+            $rc = $?;
+            if($rc)
             {
-                # base/physical offset
-                my $physicalOffset = $sectionHash{$key}{physicalOffset};
-                #make sure offset is on a block boundary
-                my $val = $physicalOffset/$blockSize;
-                if ($val != int($val))
-                {
-                    trace(0, "$this_func: Partition offset ($val) does not fall on an erase block ($blockSize) boundary.  This is not supported.  Aborting!");
-                    $rc = -1;
-                    last;
-                }
-
-                #physical size
-                my $physicalRegionSize = $sectionHash{$key}{physicalRegionSize};
-                $val = $physicalRegionSize/$blockSize;
-                if($val != int($val))
-                {
-                    trace(0, "$this_func: Partition size ($val) is not an even multiple of erase blocks ($blockSize).  This is not supported.  Aborting!");
-                    exit 1;
-                }
-
-                #Add Partition
-                #f{fs,part} --add --target tuleta.pnor --partition-offset 0 --offset 0x1000   --size 0x280000 --name HBI --flags 0x0
-                trace(2, "$g_fpartCmd --target $i_pnorBinName --partition-offset $offset --add --offset $physicalOffset --size $physicalRegionSize --name $eyeCatch --flags 0x0");
-                $rc = `$g_fpartCmd --target $i_pnorBinName --partition-offset $offset --add --offset $physicalOffset --size $physicalRegionSize --name $eyeCatch --flags 0x0`;
-                if($rc)
-                {
-                    trace(0, "$this_func: Call to add partition $eyeCatch failed.  rc=$rc.  Aborting!");
-                    last;
-                }
-
-                # Add User Partition data
-                $rc = addUserData($i_pnorBinName, $offset, $key, %sectionHash);
-                if($rc)
-                {
-                    trace(0, "$this_func: Call to add user data to partition $eyeCatch failed.  rc=$rc.  Aborting!");
-                    last;
-                }
-
-                #Trunc Partition
-                #f{fs,part} --target tuleta.pnor --partition-offset 0 --name HBI --trunc
-                $rc = `$g_fpartCmd --target $i_pnorBinName --partition-offset $offset --trunc --name $eyeCatch`;
-                if($rc)
-                {
-                    trace(0, "$this_func: Call to trunc partition $eyeCatch failed.  rc=$rc.  Aborting!");
-                    last;
-                }
+                trace(0, "$this_func: Call to trunc partition $eyeCatch failed.  rc=$rc.  Aborting!");
+                last;
             }
         }
-        # Added in case more functionality added before while ends
-        if ($rc)
-        {
-            last;
-        }
-    }while(0);
+
+        #Disable usewords for now.  Will get re-enabled and fixed up as
+        #we add support for underlying functions
+
+#        my $Out = `$g_fpartCmd --target $i_pnorBinName --partition-offset $offset
+#        		--user 0 --name $eyeCatch --value $actualRegionSize`;
+#        $rc = $?;
+#        if($rc)
+#        {
+#            trace(0, "$this_func: Call to fpart setting user 0 for partition $eyeCatch failed.  rc=$rc.  Aborting!");
+#            last;
+#        }
+
+    }
 
     return $rc;
 }
@@ -649,13 +570,21 @@ sub checkSpaceConstraints
 ################################################################################
 sub fillPnorImage
 {
-    my ($i_pnorBinName, $i_pnorLayoutRef, $i_binFiles, $side, $offset) = @_;
+    my ($i_pnorBinName, $i_pnorLayoutRef, $i_binFiles, $offset, $side) = @_;
     my $this_func = (caller(0))[3];
     my $rc = 0;
     my $key;
-    my $other_side = getOtherSide($side);
+    my $other_side = 'B';
+
+
+    if($side eq 'B')
+    {
+        $other_side = 'A';
+    }
+
 
     trace(1, "fillPnorImage:: $offset");
+
     #key is the physical offset into the file, however don't need to sort
     #since FFS allows populating partitions in any order
     my %sectionHash = %{$$i_pnorLayoutRef{sections}};
@@ -676,26 +605,27 @@ sub fillPnorImage
             next;
         }
 
-        my $sideInfo = getSideInfo($key, %sectionHash);
+        my $myside = $sectionHash{$key}{side};
 
-        # Add if side matches (or not set) -- so if it isn't equal to other side
-        # Only fill sideless sections once
-        if( ($sideInfo ne $other_side) &&
-            (!exists($sidelessSecFilled{$eyeCatch})))
+        #Add if side matches (or not set) -- so if it isn't equal to other side
+        if( $myside ne $other_side )
         {
-            if($sideInfo eq $SideOptions{sideless})
-            {
-                $sidelessSecFilled{$eyeCatch} = 1;
-            }
-            trace(5, "$this_func: populating section $sideInfo:$eyeCatch, filename=$inputFile");
+            trace(5, "$this_func: populating section $myside:$eyeCatch, filename=$inputFile");
+
             #fcp --target tuleta.pnor --partition-offset 0 --name HBI --write hostboot_extended.bin
-            $rc = `$g_fcpCmd $inputFile $i_pnorBinName:$eyeCatch --offset $offset --write --buffer 0x40000000`;
+            if ($g_ffsCmd eq "") {
+                my $Out = `$g_fcpCmd $inputFile $i_pnorBinName:$eyeCatch --offset $offset --write --buffer 0x40000000`;
+            } else {
+                my $Out = `$g_ffsCmd --target $i_pnorBinName --partition-offset $offset --name $eyeCatch  --write $inputFile`;
+            }
+            $rc = $?;
             if($rc)
             {
                 trace(0, "$this_func: Call to fcp adding data to partition $eyeCatch failed.  rc=$rc.  Aborting!");
                 last;
             }
          }
+
     }
 
     return $rc;
@@ -723,6 +653,28 @@ sub saveInputFile
 }
 
 #################################################
+# getFFSEntrySize: Returns number of bytes in an ffs_entry based on specified version
+#################################################
+sub getFFSEntrySize
+{
+    my($i_tocVersion, $i_pnorLayoutRef) = @_;
+    my $this_func = (caller(0))[3];
+    my $ffsEntrySize = 0;
+
+    if($i_tocVersion == 0x1)
+    {
+        #16 char name + 12 fixed words + 16 user data words
+        $ffsEntrySize = 16+(12*4)+(16*4);
+    }
+    else
+    {
+        trace(0, "$this_func:  Layout Version Unsupported!  i_tocVersion=$i_tocVersion");
+        exit 1;
+    }
+    return $ffsEntrySize;
+}
+
+#################################################
 # Insert specifed number of pad bytes into file
 #
 #################################################
@@ -780,70 +732,6 @@ sub trace
     }
 }
 
-################################################################################
-# getSideInfo - return side info of certain sections and determine if value is
-#               a supported value
-################################################################################
-sub getSideInfo
-{
-    my $i_key = shift;
-    my %i_sectionHash = @_;
-
-    my $side = "";
-    my $eyeCatch = $i_sectionHash{$i_key}{eyeCatch};
-
-
-    if($i_sectionHash{$i_key}{sideless} eq "yes")
-    {
-        return $SideOptions{sideless};
-    }
-    else
-    {
-        $side = $i_sectionHash{$i_key}{side};
-    }
-
-    # Error paths
-    if ($side eq "")
-    {
-        trace(0, "Error detected from call to getSideInfo() - $eyeCatch has no side info specified Exiting");
-        exit 1;
-    }
-    elsif (!exists($SideOptions{$side}))
-    {
-        trace(0, "Error detected from call to getSideInfo() - $eyeCatch has sideInfo = $side which is not supported Exiting");
-        exit 1;
-    }
-
-    return $side;
-}
-
-################################################################################
-# getOtherSide - return other side of the given side
-#                does not default to main side in case more sides are added
-################################################################################
-sub getOtherSide
-{
-    my $i_side = shift;
-    my $other_side = "";
-
-    if($i_side eq $SideOptions{A})
-    {
-        $other_side = $SideOptions{B};
-    }
-    elsif($i_side eq $SideOptions{B})
-    {
-        $other_side = $SideOptions{A};
-    }
-
-    # Error paths
-    if ($other_side eq "")
-    {
-        trace(0, "Error detected from call to getOtherSide() - Could not get other side of side = $i_side Exiting");
-        exit 1;
-    }
-
-    return $other_side;
-}
 
 
 ################################################################################
diff --git a/src/build/buildpnor/defaultPnorLayout.xml b/src/build/buildpnor/defaultPnorLayout.xml
index 249bdb4..e34f0fe 100644
--- a/src/build/buildpnor/defaultPnorLayout.xml
+++ b/src/build/buildpnor/defaultPnorLayout.xml
@@ -5,9 +5,7 @@
 <!--                                                                        -->
 <!-- OpenPOWER HostBoot Project                                             -->
 <!--                                                                        -->
-<!-- Contributors Listed Below - COPYRIGHT 2012,2015                        -->
-<!-- [+] International Business Machines Corp.                              -->
-<!--                                                                        -->
+<!-- COPYRIGHT International Business Machines Corp. 2012,2014              -->
 <!--                                                                        -->
 <!-- Licensed under the Apache License, Version 2.0 (the "License");        -->
 <!-- you may not use this file except in compliance with the License.       -->
@@ -24,50 +22,48 @@
 <!-- IBM_PROLOG_END_TAG                                                     -->
 <!--
 Layout Description
-<metadata> Element -> Contains high-level information about the PNOR layout.
-    <imageSize>           -> Size of PNOR image in bytes.
-    <blockSize>           -> size of erase blocks in bytes.
-    <sideATocOffset>      -> Location of Side A Partition Table
-    <sideATocBackupOffset>-> Location of Side A Backup Partition Table
-    <sideBTocOffset>      -> Location of Side B Partition Table
-    <sideBTocBackupOffset>-> Location of Side B Backup Partition Table
-</metadata>
-<section> Element -> Contains information about a PNOR Partition
-    <description>   -> Text description of the partition.
-                       Does not have to be machine readable.
-    <eyeCatch>      -> Name of the Partition
-    <physicalOffset>-> Offset of the Partition in PNOR
-                       in bytes.
-    <physicalSize>  -> Size of the Partition in bytes.
-    <side>          -> Side the Partition should be associated with. This
-                       determines if the partition should be added to the
-                       partition table at <sideATocOffset> or <sideBTocOffset>
-    <sideless/>     -> Indicates partition will be in both TOCs but only one
-                       copy of the partition should be created
-    <testonly/>     -> Indicates partition is used for internal testing only.
-                       Partition should be skipped in production environments.
-    <ecc/>          -> Indicates Partition should be ECC protected
-    <sha512Version/>-> Indicates Partition uses SHA512 for version information.
-    <sha512perEC/>  -> Indicates SHA512 is used to indicate version for each
-                       EC-specific image within the Partition.
-    <preserved/>    -> Indicates Partition is preserved across code updates.
-</section>
+<metadata> Element -> Contains high-level information about
+   the PNOR layout.
+    <imageSize> -> Size of PNOR image in bytes.
+    <blockSize> -> size of erase blocks in bytes.
+    <sideAOffset> -> Location of Side A Partition Table
+    <sideBOffset> -> Location of Side B Partition Table
+<section> -> Contains information about a PNOR Partition
+    <description> -> Text description of the partition.
+                     Does not have to be machine readable.
+    <eyeCatch> -> Name of the Partition
+    <physicalOffset> -> Offset of the Partition in PNOR
+                        in bytes.
+    <physicalSize> -> Size of the Partition in bytes.
+    <side> -> Side the partition should be associated with.
+              This determines if the partition should be
+              added to the partition table at <sideAOffset>
+              or <sideBOffset>
+    <testonly/> Indicates partition is used for internal
+                testing only.  Partition should be skipped
+                 in production environments.
+    <ecc/>  Indicates Partition should be ECC protected
+    <sha512Version/> Indicates Partition uses SHA512 for
+                     version information.
+    <sha512perEC/> Indicates SHA512 is used to indicate
+                   version for each EC-specific image
+                   within the Partition.
+    <preserved/>   Indicates Partition is preserved
+                   across code updates.
 -->
 
 <pnor>
     <metadata>
         <imageSize>0x4000000</imageSize>
         <blockSize>0x1000</blockSize>
-        <!-- @TODO RTC: 120062 - Enhance meta info -->
-        <sideATocOffset>0x0</sideATocOffset>
-        <sideATocBackupOffset>0x8000</sideATocBackupOffset>
+        <sideAOffset>0x0</sideAOffset>
+        <sideBOffset>0x8000</sideBOffset>
     </metadata>
     <section>
         <description>Hostboot Error Logs (144K)</description>
         <eyeCatch>HBEL</eyeCatch>
         <physicalOffset>0x10000</physicalOffset>
         <physicalRegionSize>0x24000</physicalRegionSize>
-        <sideless/>
         <ecc/>
     </section>
     <section>
@@ -75,7 +71,6 @@ Layout Description
         <eyeCatch>GUARD</eyeCatch>
         <physicalOffset>0x58000</physicalOffset>
         <physicalRegionSize>0x5000</physicalRegionSize>
-        <sideless/>
         <ecc/>
     </section>
     <section>
@@ -83,7 +78,6 @@ Layout Description
         <eyeCatch>HBD</eyeCatch>
         <physicalOffset>0x5D000</physicalOffset>
         <physicalRegionSize>0x120000</physicalRegionSize>
-        <sideless/>
         <ecc/>
     </section>
     <section>
@@ -92,7 +86,6 @@ Layout Description
         <!--NOTE: MUST update standalone.simics if offset changes -->
          <physicalOffset>0x17D000</physicalOffset>
         <physicalRegionSize>0x48000</physicalRegionSize>
-        <sideless/>
         <ecc/>
     </section>
     <section>
@@ -101,7 +94,6 @@ Layout Description
         <!--NOTE: MUST update standalone.simics if offset changes -->
         <physicalOffset>0x1C5000</physicalOffset>
         <physicalRegionSize>0x90000</physicalRegionSize>
-        <sideless/>
         <ecc/>
     </section>
     <section>
@@ -110,7 +102,6 @@ Layout Description
         <!--NOTE: MUST update standalone.simics if offset changes -->
         <physicalOffset>0x255000</physicalOffset>
         <physicalRegionSize>0x48000</physicalRegionSize>
-        <sideless/>
         <ecc/>
     </section>
     <section>
@@ -119,7 +110,6 @@ Layout Description
         <physicalOffset>0x29D000</physicalOffset>
         <physicalRegionSize>0x5A0000</physicalRegionSize>
         <sha512Version/>
-        <sideless/>
         <ecc/>
     </section>
     <section>
@@ -128,7 +118,6 @@ Layout Description
         <physicalOffset>0x83D000</physicalOffset>
         <physicalRegionSize>0x90000</physicalRegionSize>
         <sha512perEC/>
-        <sideless/>
         <ecc/>
     </section>
     <section>
@@ -137,7 +126,6 @@ Layout Description
         <physicalOffset>0x8CD000</physicalOffset>
         <physicalRegionSize>0x48000</physicalRegionSize>
         <sha512perEC/>
-        <sideless/>
         <ecc/>
     </section>
     <section>
@@ -146,7 +134,6 @@ Layout Description
         <physicalOffset>0x915000</physicalOffset>
         <physicalRegionSize>0x120000</physicalRegionSize>
         <sha512Version/>
-        <sideless/>
         <ecc/>
     </section>
     <section>
@@ -155,7 +142,6 @@ Layout Description
         <physicalOffset>0xA35000</physicalOffset>
         <physicalRegionSize>0x240000</physicalRegionSize>
         <sha512Version/>
-        <sideless/>
         <ecc/>
     </section>
     <section>
@@ -163,7 +149,6 @@ Layout Description
         <eyeCatch>PAYLOAD</eyeCatch>
         <physicalOffset>0xC75000</physicalOffset>
         <physicalRegionSize>0x1680000</physicalRegionSize>
-        <sideless/>
         <ecc/>
     </section>
     <section>
@@ -172,18 +157,6 @@ Layout Description
         <physicalOffset>0x3590000</physicalOffset>
         <physicalRegionSize>0x9000</physicalRegionSize>
         <testonly/>
-        <sideless/>
-        <ecc/>
-    </section>
-    <section>
-        <description>Special PNOR Test Space (36K)</description>
-        <eyeCatch>TESTRO</eyeCatch>
-        <physicalOffset>0x3599000</physicalOffset>
-        <physicalRegionSize>0x9000</physicalRegionSize>
-        <testonly/>
-        <sideless/>
-        <preserved/>
-        <readOnly/>
         <ecc/>
     </section>
     <section>
@@ -193,7 +166,6 @@ Layout Description
         <physicalOffset>0x3F67000</physicalOffset>
         <physicalRegionSize>0x90000</physicalRegionSize>
         <sha512Version/>
-        <sideless/>
         <ecc/>
     </section>
     <section>
@@ -201,7 +173,6 @@ Layout Description
         <eyeCatch>GLOBAL</eyeCatch>
         <physicalOffset>0x3FF7000</physicalOffset>
         <physicalRegionSize>0x9000</physicalRegionSize>
-        <sideless/>
         <ecc/>
     </section>
 </pnor>
diff --git a/src/build/mkrules/hbfw/img/makefile b/src/build/mkrules/hbfw/img/makefile
index 925061e..c0b0900 100755
--- a/src/build/mkrules/hbfw/img/makefile
+++ b/src/build/mkrules/hbfw/img/makefile
@@ -5,7 +5,7 @@
 #
 # OpenPOWER HostBoot Project
 #
-# Contributors Listed Below - COPYRIGHT 2012,2015
+# Contributors Listed Below - COPYRIGHT 2012,2014
 # [+] International Business Machines Corp.
 #
 #
@@ -226,7 +226,7 @@ PNOR_BUILD_SCRIPT = ${buildpnor.pl:P}
 #so need to use tryinclude for now.
 .tryinclude <${.PATH:Ffips_pnor.mk}>
 
-HOSTBOOT_DEFAULT_SECTIONS = HBB=${BASE_W_HEADER_ECC_IMAGE},HBI=${EXT_ECC_HEADER_IMAGE},HBRT=${HBRT_ECC_HEADER_IMAGE},TEST=${TESTDATA_ECC},TESTRO=${TESTDATA_ECC},HBEL=${HBEL_ECC_IMAGE},GUARD=${GUARD_ECC_IMAGE},GLOBAL=${GLOBAL_ECC_IMAGE},PAYLOAD=${PAYLOAD_ECC_IMAGE},CVPD=${CVPD_ECC_IMAGE},MVPD=${MVPD_ECC_IMAGE},DJVPD=${DJVPD_ECC_IMAGE}
+HOSTBOOT_DEFAULT_SECTIONS = HBB=${BASE_W_HEADER_ECC_IMAGE},HBI=${EXT_ECC_HEADER_IMAGE},HBRT=${HBRT_ECC_HEADER_IMAGE},TEST=${TESTDATA_ECC},HBEL=${HBEL_ECC_IMAGE},GUARD=${GUARD_ECC_IMAGE},GLOBAL=${GLOBAL_ECC_IMAGE},PAYLOAD=${PAYLOAD_ECC_IMAGE},CVPD=${CVPD_ECC_IMAGE},MVPD=${MVPD_ECC_IMAGE},DJVPD=${DJVPD_ECC_IMAGE}
 
 
 HBFW_OBJPATH = ${.PATH:M*obj*}
diff --git a/src/include/usr/hwas/hwasPlatDeconfigGard.H b/src/include/usr/hwas/hwasPlatDeconfigGard.H
index c439a42..4b89353 100644
--- a/src/include/usr/hwas/hwasPlatDeconfigGard.H
+++ b/src/include/usr/hwas/hwasPlatDeconfigGard.H
@@ -5,9 +5,7 @@
 /*                                                                        */
 /* OpenPOWER HostBoot Project                                             */
 /*                                                                        */
-/* Contributors Listed Below - COPYRIGHT 2012,2015                        */
-/* [+] International Business Machines Corp.                              */
-/*                                                                        */
+/* COPYRIGHT International Business Machines Corp. 2012,2014              */
 /*                                                                        */
 /* Licensed under the Apache License, Version 2.0 (the "License");        */
 /* you may not use this file except in compliance with the License.       */
@@ -32,8 +30,6 @@
 #ifndef HWASPLATDECONFIGGARD_H_
 #define HWASPLATDECONFIGGARD_H_
 
-#include <pnor/pnorif.H>
-
 /**
  *  @brief Adapt common singleton declaration to specific platform
  *
@@ -68,19 +64,6 @@ struct HBDeconfigGard
     void *iv_pGardRecords;          // Pointer to the GARD Records in PNOR
 };
 
-/**
- *  @brief Gets iv_gardSectionInfo and sets it if first time called.
- *         Sets o_sectionInfo based on iv_gardSectionInfo for the caller
- *
- *  @param[out] Guard PNOR section info
- *
- *  @return errlHndl_t Error log handle, depending on config options will
- *          ignore error because no Guard section exists in PNOR
- *          (e.g. CONFIG_GOLDEN_PNOR_SIDE_SUPPORT)
- *
- */
-errlHndl_t getGardSectionInfo(PNOR::SectionInfo_t& o_sectionInfo);
-
 } // namespace HWAS
 
 #endif // HWASPLATDECONFIGGARD_H_
diff --git a/src/include/usr/pnor/pnor_reasoncodes.H b/src/include/usr/pnor/pnor_reasoncodes.H
index 4857c1b..a9854a4 100644
--- a/src/include/usr/pnor/pnor_reasoncodes.H
+++ b/src/include/usr/pnor/pnor_reasoncodes.H
@@ -136,8 +136,6 @@ namespace PNOR
         RC_PNOR_READ_NOT_SUPPORTED   = PNOR_COMP_ID | 0x1F,
         RC_PNOR_WRITE_NOT_SUPPORTED  = PNOR_COMP_ID | 0x20,
         RC_NON_ECC_PROTECTED_SECTION = PNOR_COMP_ID | 0x21,
-        RC_WRITABLE_PERM_FAIL        = PNOR_COMP_ID | 0x22,
-        RC_WRITE_TRACKED_PERM_FAIL   = PNOR_COMP_ID | 0x23,
     };
 
     enum UserDetailsTypes
diff --git a/src/include/usr/pnor/pnorif.H b/src/include/usr/pnor/pnorif.H
index 2689077..a9856f8 100644
--- a/src/include/usr/pnor/pnorif.H
+++ b/src/include/usr/pnor/pnorif.H
@@ -29,7 +29,6 @@
 #include <stdint.h>
 #include <builtins.h>
 #include <errl/errlentry.H>
-#include <utility>
 
 namespace PNOR
 {
@@ -62,7 +61,6 @@ enum SectionId
     ATTR_PERM,      /**< Permanent Attribute Override */
     CAPP,           /**< CAPP lid */
     TEST,           /**< Scratch space for PNOR test cases */
-    TESTRO,         /**< Scratch space for PNOR ReadOnly test cases */
 
     NUM_SECTIONS,   /**< Number of defined sections */
 
@@ -84,8 +82,7 @@ struct SectionInfo_t
     uint64_t size;      /**< Size of partition in bytes */
     bool eccProtected;  /**< Section is ECC protected */
     bool sha512Version; /**< Version Checking */
-    bool sha512perEC; /**< Version Checking perEC */
-    bool readOnly; /**< Section is read only */
+    bool sha512perEC;   /**< Version Checking perEC */
 };
 
 /**
@@ -124,7 +121,6 @@ errlHndl_t fixECC (SectionId i_section);
  *         true = PNOR DD is using L3 Cache for fake PNOR
  *         false = PNOR DD not using L3 Cache for fake PNOR
  */
- bool usingL3Cache();
 
 /**
  * @brief  Clears the specified PNOR section with all FF's (w/ good ECC)
@@ -135,6 +131,8 @@ errlHndl_t fixECC (SectionId i_section);
  */
 errlHndl_t clearSection(PNOR::SectionId i_section);
 
+bool usingL3Cache();
+
 /**
  * @brief Validate the Alternative Master Processor's LPC
  *        Connection to PNOR
@@ -143,14 +141,6 @@ errlHndl_t clearSection(PNOR::SectionId i_section);
  */
 errlHndl_t validateAltMaster( void );
 
-//@ TODO RTC: 120061 add golden info
-//@ TODO RTC: 109703 make golden changes for informing OPAL
-struct TocInfo_t
-{
-    std::pair<uint64_t, uint64_t> activeTocOffsets;
-    std::pair<uint64_t, uint64_t> altTocOffsets;
-};
-
 /** @brief PNOR::TEST section offsets for test cases to prevent
  *         concurrency problems
  */
@@ -160,29 +150,6 @@ enum TestSectionOffset{
     pnorTestSec_rt_readwrite_offset = 0x6000,
 };
 
-////////////////////////////////////////////////////////////////////////////////
-// SBE functionality that lives in PNOR
-
-// Used to keep track of perm/temp, and cur/alt
-enum sbeSeepromSide_t
-{
-    SBE_SEEPROM0         = 0x00,   // corresponds to EEPROM::SBE_PRIMARY
-    SBE_SEEPROM1         = 0x01,   // corresponts to EEPROM::SBE_BACKUP
-    SBE_SEEPROM_INVALID  = 0xFF,
-};
-
-/**
- * @brief Determines which Seeprom was used to boot the SBE
- *
- * @param[in] i_target      Target processor to customize
- *
- * @param[out] o_bootSide   The Seeprom the SBE booted from
- *
- * @return errlHndl_t       Error log handle on failure.
- */
-errlHndl_t getSbeBootSeeprom(TARGETING::Target* i_target,
-                             sbeSeepromSide_t& o_bootSide);
-
 }
 
 #endif
diff --git a/src/usr/hwas/hwasPlatDeconfigGard.C b/src/usr/hwas/hwasPlatDeconfigGard.C
index 2911cf3..912f7d4 100644
--- a/src/usr/hwas/hwasPlatDeconfigGard.C
+++ b/src/usr/hwas/hwasPlatDeconfigGard.C
@@ -5,7 +5,7 @@
 /*                                                                        */
 /* OpenPOWER HostBoot Project                                             */
 /*                                                                        */
-/* Contributors Listed Below - COPYRIGHT 2013,2015                        */
+/* Contributors Listed Below - COPYRIGHT 2013,2014                        */
 /* [+] Google Inc.                                                        */
 /* [+] International Business Machines Corp.                              */
 /*                                                                        */
@@ -52,15 +52,6 @@ using namespace HWAS::COMMON;
 using namespace TARGETING;
 
 const uint32_t EMPTY_GARD_RECORDID = 0xFFFFFFFF;
-/**
- * @brief Guard PNOR section info, obtained once for efficiency
- */
-static PNOR::SectionInfo_t g_GardSectionInfo;
-
-/**
- * @brief Flag indicating if getGardSectionInfo() was called previously
- */
-static bool getGardSectionInfoCalled;
 
 void _flush(void *i_addr);
 errlHndl_t _GardRecordIdSetup(void *&io_platDeconfigGard);
@@ -99,7 +90,7 @@ errlHndl_t DeconfigGard::platClearGardRecords(
 
     HWAS_MUTEX_LOCK(iv_mutex);
     l_pErr = _GardRecordIdSetup(iv_platDeconfigGard);
-    if (!l_pErr && iv_platDeconfigGard)
+    if (!l_pErr)
     {
         uint32_t l_gardRecordsCleared = 0;
         HBDeconfigGard *l_hbDeconfigGard =
@@ -136,6 +127,10 @@ errlHndl_t DeconfigGard::platClearGardRecords(
 
         HWAS_INF("GARD Records Cleared: %d", l_gardRecordsCleared);
     }
+    else
+    {
+        HWAS_ERR("Error from _GardRecordIdSetup");
+    }
 
     HWAS_MUTEX_UNLOCK(iv_mutex);
 #endif // CONFIG_NO_GARD_SUPPORT
@@ -158,7 +153,7 @@ errlHndl_t DeconfigGard::platGetGardRecords(
 
     HWAS_MUTEX_LOCK(iv_mutex);
     l_pErr = _GardRecordIdSetup(iv_platDeconfigGard);
-    if (!l_pErr && iv_platDeconfigGard)
+    if (!l_pErr)
     {
         HBDeconfigGard *l_hbDeconfigGard =
                 (HBDeconfigGard *)iv_platDeconfigGard;
@@ -188,6 +183,10 @@ errlHndl_t DeconfigGard::platGetGardRecords(
             }
         } // for
     }
+    else
+    {
+        HWAS_ERR("Error from _GardRecordIdSetup");
+    }
 
     HWAS_MUTEX_UNLOCK(iv_mutex);
     HWAS_INF("Get returning %d GARD Records", o_records.size());
@@ -270,8 +269,9 @@ errlHndl_t DeconfigGard::platCreateGardRecord(
         }
 
         l_pErr = _GardRecordIdSetup(iv_platDeconfigGard);
-        if (l_pErr && iv_platDeconfigGard)
+        if (l_pErr)
         {
+            HWAS_ERR("Error from _GardRecordIdSetup");
             break;
         }
 
@@ -394,27 +394,20 @@ errlHndl_t _GardRecordIdSetup( void *&io_platDeconfigGard)
             break;
         }
 
-        // Get the PNOR Guard information
+        // allocate our memory and set things up
+        io_platDeconfigGard = malloc(sizeof(HBDeconfigGard));
+        HBDeconfigGard *l_hbDeconfigGard =
+                (HBDeconfigGard *)io_platDeconfigGard;
+
+        // get the PNOR address.
         PNOR::SectionInfo_t l_section;
-        l_pErr = getGardSectionInfo(l_section);
+        l_pErr = PNOR::getSectionInfo(PNOR::GUARD_DATA, l_section);
         if (l_pErr)
         {
-            HWAS_ERR("_GardRecordIdSetup: getGardSectionInfo failed!!!");
+            HWAS_ERR("PNOR::getSectionInfo failed!!!");
             // no support for GARD in this configuration.
             break;
         }
-        // Check if guard section exists, as certain configs ignore the above
-        // error (e.g. golden side has no GARD section)
-        if (l_section.size == 0)
-        {
-            HWAS_ERR("_GardRecordIdSetup: No guard section skipping function");
-            break;
-        }
-
-        // allocate our memory and set things up
-        io_platDeconfigGard = malloc(sizeof(HBDeconfigGard));
-        HBDeconfigGard *l_hbDeconfigGard =
-                (HBDeconfigGard *)io_platDeconfigGard;
 
         l_hbDeconfigGard->iv_pGardRecords =
             reinterpret_cast<DeconfigGard::GardRecord *> (l_section.vaddr);
@@ -473,44 +466,4 @@ void _flush(void *i_addr)
     }
 }
 
-errlHndl_t getGardSectionInfo(PNOR::SectionInfo_t& o_sectionInfo)
-{
-    errlHndl_t l_errl = NULL;
-    do
-    {
-        // getSectionInfo has already been called for GUARD_DATA
-        if(getGardSectionInfoCalled)
-        {
-            o_sectionInfo = g_GardSectionInfo;
-            break;
-        }
-
-        // Get Guard Section Info and set gardSectionInfo
-        l_errl = PNOR::getSectionInfo(PNOR::GUARD_DATA, g_GardSectionInfo);
-        if (l_errl)
-        {
-            g_GardSectionInfo.size = 0;
-// @TODO RTC: 120061 - replace config flag with a pnor interface call to say if
-//                     there is a guard section on the current (active) side
-//                     of pnor
-#ifdef CONFIG_TWO_SIDE_SUPPORT
-            HWAS_INF("getGardSectionInfo: No guard section disabling guard support");
-            l_errl = NULL;
-#else
-            HWAS_ERR("getGardSectionInfo:getSectionInfo failed");
-#endif
-        }
-        else
-        {
-            HWAS_INF("getGardSectionInfo: Section %s found, size %d",
-                      g_GardSectionInfo.name, g_GardSectionInfo.size);
-        }
-
-        o_sectionInfo = g_GardSectionInfo;
-        getGardSectionInfoCalled = true;
-    } while(0);
-
-    return l_errl;
-}
-
 } // namespace HWAS
diff --git a/src/usr/pnor/HBconfig b/src/usr/pnor/HBconfig
index 21082f4..298144c 100644
--- a/src/usr/pnor/HBconfig
+++ b/src/usr/pnor/HBconfig
@@ -37,8 +37,3 @@ config PNOR_IS_32MB
     default n
     help
         Size of the attached flash chip is 32MB, if not set then 64MB is default
-
-config TWO_SIDE_SUPPORT
-    default n
-    help
-        This is used to turn on/off two sided pnor support
diff --git a/src/usr/pnor/common/ffs_hb.H b/src/usr/pnor/common/ffs_hb.H
index c96911b..b638021 100644
--- a/src/usr/pnor/common/ffs_hb.H
+++ b/src/usr/pnor/common/ffs_hb.H
@@ -5,9 +5,7 @@
 /*                                                                        */
 /* OpenPOWER HostBoot Project                                             */
 /*                                                                        */
-/* Contributors Listed Below - COPYRIGHT 2012,2015                        */
-/* [+] International Business Machines Corp.                              */
-/*                                                                        */
+/* COPYRIGHT International Business Machines Corp. 2012,2014              */
 /*                                                                        */
 /* Licensed under the Apache License, Version 2.0 (the "License");        */
 /* you may not use this file except in compliance with the License.       */
@@ -27,7 +25,7 @@
 
 /*
  * FSP Destination: src/hbfw/fsp/pnor/common/ffs_hb.H
- *
+ * 
  * NOTE: Do NOT modify this file in CMVC directly!  It comes from the Hostboot
  *      repository and will be overwritten.
 */
@@ -65,7 +63,6 @@ enum
 
     /* Miscellaneous Bits : 1 byte */
     FFS_MISC_PRESERVED     = 0x80,    /**< Preserved across code updates */
-    FFS_MISC_READ_ONLY     = 0x40,    /**< Read only section */
     FFS_MISC_UNUSED        = 0x1F,    /**< Unused MISC Flags */
 };
 
diff --git a/src/usr/pnor/makefile b/src/usr/pnor/makefile
index 2f0a4e1..31087a4 100644
--- a/src/usr/pnor/makefile
+++ b/src/usr/pnor/makefile
@@ -32,7 +32,6 @@ OBJS += pnor_common.o
 OBJS += pnorvalid.o
 OBJS += ecc.o
 OBJS += sfcdd.o
-OBJS += pnorsbe.o
 
 #SFC Implementations
 OBJS += $(if $(CONFIG_SFC_IS_IBM_DPSS),sfc_ibm.o)
diff --git a/src/usr/pnor/pnor_common.C b/src/usr/pnor/pnor_common.C
index 00931ec..e8972e2 100644
--- a/src/usr/pnor/pnor_common.C
+++ b/src/usr/pnor/pnor_common.C
@@ -24,15 +24,14 @@
 /* IBM_PROLOG_END_TAG                                                     */
 
 #include "pnor_common.H"
+#include <pnor/pnorif.H>
 #include <pnor/pnor_reasoncodes.H>
 
 #include "ffs.h"           //Common header file with BuildingBlock.
 #include "common/ffs_hb.H" //Hostboot def of user data in ffs_entry struct
-#include <sys/mm.h>
 
 #include <initservice/initserviceif.H>
 #include <util/align.H>
-#include <errl/errlmanager.H>
 
 // Trace definition
 trace_desc_t* g_trac_pnor = NULL;
@@ -46,29 +45,28 @@ TRAC_INIT(&g_trac_pnor, PNOR_COMP_NAME, 4*KILOBYTE, TRACE::BUFFER_SLOW); //4K
  * Eyecatcher strings for PNOR TOC entries
  */
 const char* cv_EYECATCHER[] = {
-    "part",      /**< PNOR::TOC            : Table of Contents */
-    "HBI",       /**< PNOR::HB_EXT_CODE    : Hostboot Extended Image */
-    "GLOBAL",    /**< PNOR::GLOBAL_DATA    : Global Data */
-    "HBB",       /**< PNOR::HB_BASE_CODE   : Hostboot Base Image */
-    "SBEC",      /**< PNOR::CENTAUR_SBE    : Centaur Self-Boot Engine image */
-    "SBE",       /**< PNOR::SBE_IPL        : Self-Boot Enginer IPL image */
-    "WINK",      /**< PNOR::WINK           : Sleep Winkle Reference image */
-    "PAYLOAD",   /**< PNOR::PAYLOAD        : HAL/OPAL */
-    "HBRT",      /**< PNOR::HB_RUNTIME     : Hostboot Runtime (for Sapphire) */
-    "HBD",       /**< PNOR::HB_DATA        : Hostboot Data */
-    "GUARD",     /**< PNOR::GUARD_DATA     : Hostboot Data */
-    "HBEL",      /**< PNOR::HB_ERRLOGS     : Hostboot Error log Repository */
-    "DJVPD",     /**< PNOR::DIMM_JEDEC_VPD : Dimm JEDEC VPD */
-    "MVPD",      /**< PNOR::MODULE_VPD     : Module VPD */
-    "CVPD",      /**< PNOR::CENTAUR_VPD    : Centaur VPD */
-    "NVRAM",     /**< PNOR::NVRAM          : OPAL Storage */
-    "OCC",       /**< PNOR::OCC            : OCC LID */
-    "FIRDATA",   /**< PNOR::FIRDATA        : FIRDATA */
+    "part",     /**< PNOR::TOC            : Table of Contents */
+    "HBI",      /**< PNOR::HB_EXT_CODE    : Hostboot Extended Image */
+    "GLOBAL",   /**< PNOR::GLOBAL_DATA    : Global Data */
+    "HBB",      /**< PNOR::HB_BASE_CODE   : Hostboot Base Image */
+    "SBEC",     /**< PNOR::CENTAUR_SBE    : Centaur Self-Boot Engine image */
+    "SBE",      /**< PNOR::SBE_IPL        : Self-Boot Enginer IPL image */
+    "WINK",     /**< PNOR::WINK           : Sleep Winkle Reference image */
+    "PAYLOAD",  /**< PNOR::PAYLOAD        : HAL/OPAL */
+    "HBRT",     /**< PNOR::HB_RUNTIME     : Hostboot Runtime (for Sapphire) */
+    "HBD",      /**< PNOR::HB_DATA        : Hostboot Data */
+    "GUARD",    /**< PNOR::GUARD_DATA     : Hostboot Data */
+    "HBEL",     /**< PNOR::HB_ERRLOGS     : Hostboot Error log Repository */
+    "DJVPD",    /**< PNOR::DIMM_JEDEC_VPD : Dimm JEDEC VPD */
+    "MVPD",     /**< PNOR::MODULE_VPD     : Module VPD */
+    "CVPD",     /**< PNOR::CENTAUR_VPD    : Centaur VPD */
+    "NVRAM",    /**< PNOR::NVRAM          : OPAL Storage */
+    "OCC",      /**< PNOR::OCC            : OCC LID */
+    "FIRDATA",  /**< PNOR::FIRDATA        : FIRDATA */
     "ATTR_TMP",  /**< PNOR::ATTR_TMP       : Temporary Attribute Overrides */
     "ATTR_PERM", /**< PNOR::ATTR_PERM      : Permanent Attribute Overrides */
-    "CAPP",      /**< PNOR::CAPP            : CAPP LID */
-    "TEST",      /**< PNOR::TEST           : Test space for PNOR*/
-    "TESTRO",    /**< PNOR::TESTRO         : ReadOnly Test space for PNOR */
+    "CAPP",     /**< PNOR::CAPP           : CAPP LID */
+    "TEST",     /**< PNOR::TEST           : Test space for PNOR*/
     //Not currently used
 //    "XXX",    /**< NUM_SECTIONS       : Used as invalid entry */
 };
@@ -91,7 +89,7 @@ uint32_t PNOR::pnor_ffs_checksum(void* data, size_t size)
 }
 
 errlHndl_t PNOR::parseTOC(uint8_t* i_toc0Buffer, uint8_t* i_toc1Buffer,
-           TOCS & o_TOC_used, SectionData_t * o_TOC, uint64_t i_baseVAddr)
+           uint32_t & o_TOC_used, SectionData_t * o_TOC, uint64_t i_baseVAddr)
 {
     TRACUCOMP(g_trac_pnor,"PNOR::parseTOC>");
     errlHndl_t l_errhdl = NULL;
@@ -99,10 +97,9 @@ errlHndl_t PNOR::parseTOC(uint8_t* i_toc0Buffer, uint8_t* i_toc1Buffer,
     bool TOC_0_failed = false;
 
     do{
-        o_TOC_used = TOC_0;
+        o_TOC_used = 0;
 
-        for (TOCS cur_TOC = TOC_0; cur_TOC < NUM_TOCS;
-            cur_TOC = (TOCS)(cur_TOC+1))
+        for (uint32_t cur_TOC = 0; cur_TOC < NUM_TOCS; ++cur_TOC)
         {
             TRACFCOMP(g_trac_pnor, "PNOR::parseTOC verifying TOC: %d",cur_TOC);
             uint64_t nextVAddr = i_baseVAddr;
@@ -137,10 +134,10 @@ errlHndl_t PNOR::parseTOC(uint8_t* i_toc0Buffer, uint8_t* i_toc1Buffer,
                 {
                     TRACFCOMP(g_trac_pnor, "PNOR::parseTOC TOC 0 failed header checksum");
                     TOC_0_failed = true;
-                    o_TOC_used = TOC_1;
+                    o_TOC_used = 1;
                     continue;
                 }
-                else if (cur_TOC == TOC_1 && TOC_0_failed)
+                else if (cur_TOC == 1 && TOC_0_failed)
                 {
                     // Both TOC's failed
                     TRACFCOMP(g_trac_pnor, "PNOR::parseTOC both TOCs are corrupted");
@@ -167,7 +164,7 @@ errlHndl_t PNOR::parseTOC(uint8_t* i_toc0Buffer, uint8_t* i_toc1Buffer,
             }
 
             // Only check header if on first TOC or the first TOC failed
-            if (cur_TOC == TOC_0 || TOC_0_failed)
+            if (cur_TOC == 0 || TOC_0_failed)
             {
                 TRACFCOMP(g_trac_pnor, "PNOR::parseTOC: FFS Block size=0x%.8X,"
                  " Partition Table Size = 0x%.8x, entry_count=%d",
@@ -273,15 +270,15 @@ errlHndl_t PNOR::parseTOC(uint8_t* i_toc0Buffer, uint8_t* i_toc1Buffer,
                     // in SP-less config
                     TRACFCOMP(g_trac_pnor, "PNOR::parseTOC pnor_ffs_checksum"
                             " entry checksums do not match");
-                    if (cur_TOC == TOC_0)
+                    if (cur_TOC == 0)
                     {
                         TRACFCOMP(g_trac_pnor,"PNOR::parseTOC TOC 0 entry"
                                 " checksum failed");
                         TOC_0_failed = true;
-                        o_TOC_used = TOC_1;
+                        o_TOC_used = 1;
                         break;
                     }
-                    else if (cur_TOC == TOC_1 && TOC_0_failed)
+                    else if (cur_TOC == 1 && TOC_0_failed)
                     {
                         // Both TOC's failed
                         TRACFCOMP(g_trac_pnor, "PNOR::parseTOC both TOC's are"
@@ -309,7 +306,7 @@ errlHndl_t PNOR::parseTOC(uint8_t* i_toc0Buffer, uint8_t* i_toc1Buffer,
                 }
 
                 // Only set data if on first TOC or the first TOC failed
-                if (cur_TOC == TOC_0 || TOC_0_failed)
+                if (cur_TOC == 0 || TOC_0_failed)
                 {
                     //Figure out section enum
                     for(uint32_t eyeIndex=PNOR::TOC;eyeIndex<PNOR::NUM_SECTIONS;
@@ -396,120 +393,25 @@ errlHndl_t PNOR::parseTOC(uint8_t* i_toc0Buffer, uint8_t* i_toc1Buffer,
                                               0, 0, true);
                         break;
                     }
-
-# ifndef __HOSTBOOT_RUNTIME
-                    // Handle section permissions
-                    if (o_TOC[secId].misc & FFS_MISC_READ_ONLY)
-                    {
-                        // Need to set permissions to allow writing to virtual
-                        // addresses, but prevents the kernel from ejecting
-                        // dirty pages (no WRITE_TRACKED).
-                        int rc = mm_set_permission(
-                                                (void*)o_TOC[secId].virtAddr,
-                                                o_TOC[secId].size,
-                                                WRITABLE);
-                        if (rc)
-                        {
-                            TRACFCOMP(g_trac_pnor, "E>PnorRP::readTOC: Failed to set block permissions to WRITABLE for section %s.",
-                                      cv_EYECATCHER[secId]);
-                            /*@
-                            * @errortype
-                            * @moduleid PNOR::MOD_PNORRP_READTOC
-                            * @reasoncode PNOR::RC_WRITABLE_PERM_FAIL
-                            * @userdata1 PNOR section id
-                            * @userdata2 PNOR section vaddr
-                            * @devdesc Could not set permissions of the
-                            * given PNOR section to WRITABLE
-                            * @custdesc A problem occurred while reading PNOR partition table
-                            */
-                            l_errhdl = new ERRORLOG::ErrlEntry(
-                                            ERRORLOG::ERRL_SEV_UNRECOVERABLE,
-                                            PNOR::MOD_PNORRP_READTOC,
-                                            PNOR::RC_WRITABLE_PERM_FAIL,
-                                            secId,
-                                            o_TOC[secId].virtAddr,
-                                            true /*Add HB SW Callout*/);
-                            l_errhdl->collectTrace(PNOR_COMP_NAME);
-                        }
-                    }
-                    else
-                    {
-                        // Need to set permissions to R/W
-                        int rc = mm_set_permission(
-                                            (void*)o_TOC[secId].virtAddr,
-                                            o_TOC[secId].size,
-                                            WRITABLE | WRITE_TRACKED);
-                        if (rc)
-                        {
-                            TRACFCOMP(g_trac_pnor, "E>PnorRP::readTOC: Failed to set block permissions to WRITABLE/WRITE_TRACKED for section %s.",
-                                      cv_EYECATCHER[secId]);
-                            /*@
-                            * @errortype
-                            * @moduleid PNOR::MOD_PNORRP_READTOC
-                            * @reasoncode PNOR::RC_WRITE_TRACKED_PERM_FAIL
-                            * @userdata1 PNOR section id
-                            * @userdata2 PNOR section vaddr
-                            * @devdesc Could not set permissions of the
-                            * given PNOR section to
-                            * WRITABLE/WRITE_TRACKED
-                            * @custdesc A problem occurred while reading
-                            * PNOR partition table
-                            */
-                            l_errhdl = new ERRORLOG::ErrlEntry(
-                                            ERRORLOG::ERRL_SEV_UNRECOVERABLE,
-                                            PNOR::MOD_PNORRP_READTOC,
-                                            PNOR::RC_WRITE_TRACKED_PERM_FAIL,
-                                            secId,
-                                            o_TOC[secId].virtAddr,
-                                            true /*Add HB SW Callout*/);
-                            l_errhdl->collectTrace(PNOR_COMP_NAME);
-                        }
-                    }
-#endif
-                    if( l_errhdl )
-                    {
-                        // If both toc0 and toc1 fail break and return the error
-                        if ( (cur_TOC == TOC_1) && (TOC_0_failed) )
-                        {
-                            TRACFCOMP(g_trac_pnor, "PNOR::parseTOC readFromDevice Failed on both TOCs");
-                            break;
-                        }
-
-                        // Toc 1 has not been read yet or Toc 0 was read
-                        // successfully
-                        // Commit error and break to continue checking the next
-                        // TOC
-                        else
-                        {
-                            TRACFCOMP(g_trac_pnor, "PNOR::parseTOC readFromDevice Failed on TOC %d, commit error",
-                                      cur_TOC);
-                            errlCommit(l_errhdl,PNOR_COMP_ID);
-                            l_errhdl = NULL;
-                            break;
-                        }
-                    }
                 }
-            } // For TOC Entries
+            }
             if (l_errhdl)
             {
+                TRACFCOMP(g_trac_pnor, ERR_MRK"PNOR::parseTOC: error parsing");
                 break;
             }
-        } // For TOC's
-        if (l_errhdl)
-        {
-            break;
+
+            for(PNOR::SectionId tmpId = PNOR::FIRST_SECTION;
+                tmpId < PNOR::NUM_SECTIONS;
+                tmpId = (PNOR::SectionId) (tmpId + 1) )
+            {
+                TRACFCOMP(g_trac_pnor, "%s:    size=0x%.8X  flash=0x%.8X  "
+                       "virt=0x%.16X", cv_EYECATCHER[tmpId], o_TOC[tmpId].size,
+                       o_TOC[tmpId].flashAddr, o_TOC[tmpId].virtAddr );
+            }
         }
     } while(0);
 
-    for(PNOR::SectionId tmpId = PNOR::FIRST_SECTION;
-        tmpId < PNOR::NUM_SECTIONS;
-        tmpId = (PNOR::SectionId) (tmpId + 1) )
-    {
-        TRACFCOMP(g_trac_pnor, "%s:    size=0x%.8X  flash=0x%.8X  "
-               "virt=0x%.16X", cv_EYECATCHER[tmpId], o_TOC[tmpId].size,
-               o_TOC[tmpId].flashAddr, o_TOC[tmpId].virtAddr );
-    }
-
     TRACUCOMP(g_trac_pnor, "< PNOR::parseTOC" );
     return l_errhdl;
 }
diff --git a/src/usr/pnor/pnor_common.H b/src/usr/pnor/pnor_common.H
index 5eb8934..3944e27 100644
--- a/src/usr/pnor/pnor_common.H
+++ b/src/usr/pnor/pnor_common.H
@@ -41,22 +41,11 @@ namespace PNOR {
         uint8_t misc; /**< Misc Flags */
     } PACKED;
 
-    // Simple enum of TOC's per PNOR side
-    enum TOCS
-    {
-        TOC_0 = 0,
-        TOC_1 = 1,
-        NUM_TOCS,
-    };
-
     enum
     {
-        // @TODO RTC: 120061 - Determine TOC locations
-        // TOC offsets based on pnor layout
-        SIDE_A_TOC_0_OFFSET = 0,
-        SIDE_A_TOC_1_OFFSET = 0x8000,
-        SIDE_B_TOC_0_OFFSET = 0x2000000,
-        SIDE_B_TOC_1_OFFSET = 0x2008000,
+        NUM_TOCS = 2,
+        TOC_0_OFFSET = 0,
+        TOC_1_OFFSET = 0x8000,
 
         /** Real number of bytes required to read 1 logical page */
         PAGESIZE_PLUS_ECC = ((PAGESIZE * 9)/8),  // 8B data + 1B of ECC
@@ -90,7 +79,7 @@ namespace PNOR {
      * @return Error
      */
     errlHndl_t parseTOC(uint8_t* i_toc0Buffer, uint8_t* i_toc1Buffer,
-           TOCS & o_TOC_used, SectionData_t * o_TOC, uint64_t i_baseVAddr);
+           uint32_t & o_TOC_used, SectionData_t * o_TOC, uint64_t i_baseVAddr);
 }
 
 #endif
diff --git a/src/usr/pnor/pnorrp.C b/src/usr/pnor/pnorrp.C
index aeaeb22..299a063 100644
--- a/src/usr/pnor/pnorrp.C
+++ b/src/usr/pnor/pnorrp.C
@@ -44,7 +44,6 @@
 #include <endian.h>
 #include <util/align.H>
 #include <config.h>
-#include "pnor_common.H"
 
 
 extern trace_desc_t* g_trac_pnor;
@@ -193,9 +192,7 @@ void* wait_for_message( void* unused )
  * @brief  Constructor
  */
 PnorRP::PnorRP()
-: iv_activeTocOffsets(SIDE_A_TOC_0_OFFSET,SIDE_A_TOC_1_OFFSET)
-,iv_altTocOffsets(SIDE_B_TOC_0_OFFSET,SIDE_B_TOC_1_OFFSET)
-,iv_TOC_used(TOC_0)
+: iv_TOC_used(0)
 ,iv_msgQ(NULL)
 ,iv_startupRC(0)
 {
@@ -234,28 +231,12 @@ void PnorRP::initDaemon()
 
     do
     {
-        // @TODO RTC: 120062 - Determine which side is Golden
-        // Default TOC offsets set to side A. If two side support is enabled,
-        // check which SEEPROM hostboot booted from
-#ifdef CONFIG_TWO_SIDE_SUPPORT
-        TARGETING::Target* pnor_target = TARGETING::
-                                         MASTER_PROCESSOR_CHIP_TARGET_SENTINEL;
-        // Get correct TOC
-        PNOR::sbeSeepromSide_t l_bootSide;
-        PNOR::getSbeBootSeeprom(pnor_target, l_bootSide);
-        if (l_bootSide == PNOR::SBE_SEEPROM1)
-        {
-            TRACFCOMP( g_trac_pnor, "PnorRP::initDaemon> Booting from Side B");
-            iv_activeTocOffsets.first = SIDE_B_TOC_0_OFFSET;
-            iv_activeTocOffsets.second = SIDE_B_TOC_1_OFFSET;
-            iv_altTocOffsets.first = SIDE_A_TOC_0_OFFSET;
-            iv_altTocOffsets.second = SIDE_A_TOC_0_OFFSET;
-        }
-        else
+        // read the TOC in the PNOR to compute the sections
+        l_errhdl = readTOC();
+        if( l_errhdl )
         {
-            TRACFCOMP( g_trac_pnor, "PnorRP::initDaemon> Booting from Side A");
+            break;
         }
-#endif
 
         // create a message queue
         iv_msgQ = msg_q_create();
@@ -272,7 +253,7 @@ void PnorRP::initDaemon()
              * @userdata1    Requested Address
              * @userdata2    rc from mm_alloc_block
              * @devdesc      PnorRP::initDaemon> Error from mm_alloc_block
-             * @custdesc     A problem occurred while accessing the boot flash.
+             * @custdesc    A problem occurred while accessing the boot flash.
              */
             l_errhdl = new ERRORLOG::ErrlEntry(
                            ERRORLOG::ERRL_SEV_UNRECOVERABLE,
@@ -289,14 +270,9 @@ void PnorRP::initDaemon()
         INITSERVICE::registerBlock(reinterpret_cast<void*>(BASE_VADDR),
                                    TOTAL_SIZE,PNOR_PRIORITY);
 
-        // Read the TOC in the PNOR to compute the sections and set their
-        // correct permissions
-        l_errhdl = readTOC();
-        if( l_errhdl )
-        {
-            TRACFCOMP(g_trac_pnor, ERR_MRK"PnorRP::initDaemon: Failed to readTOC");
-            break;
-        }
+        // Need to set permissions to R/W
+        rc = mm_set_permission((void*) BASE_VADDR,TOTAL_SIZE,
+                               WRITABLE | WRITE_TRACKED);
 
         // start task to wait on the queue
         task_create( wait_for_message, NULL );
@@ -343,7 +319,7 @@ errlHndl_t PnorRP::getSectionInfo( PNOR::SectionId i_section,
              * @userdata1    Requested Section
              * @userdata2    Startup RC
              * @devdesc      PnorRP::getSectionInfo> RP not properly initialized
-             * @custdesc     A problem occurred while accessing the boot flash.
+             * @custdesc    A problem occurred while accessing the boot flash.
              */
             l_errhdl = new ERRORLOG::ErrlEntry(ERRORLOG::ERRL_SEV_UNRECOVERABLE,
                                                PNOR::MOD_PNORRP_GETSECTIONINFO,
@@ -370,7 +346,7 @@ errlHndl_t PnorRP::getSectionInfo( PNOR::SectionId i_section,
              * @userdata1    Requested Section
              * @userdata2    TOC used
              * @devdesc      PnorRP::getSectionInfo> Invalid Address for read/write
-             * @custdesc     A problem occurred while accessing the boot flash.
+             * @custdesc    A problem occurred while accessing the boot flash.
             */
             l_errhdl = new ERRORLOG::ErrlEntry(ERRORLOG::ERRL_SEV_UNRECOVERABLE,
                                                PNOR::MOD_PNORRP_GETSECTIONINFO,
@@ -402,13 +378,12 @@ errlHndl_t PnorRP::getSectionInfo( PNOR::SectionId i_section,
                                  != 0) ? true : false;
         o_info.sha512perEC = ((iv_TOC[id].version & FFS_VERS_SHA512_PER_EC)
                                != 0) ? true : false;
-        o_info.readOnly = ((iv_TOC[id].misc & FFS_MISC_READ_ONLY)
-                               != 0) ? true : false;
     }
 
     return l_errhdl;
 }
 
+
 /**
  * @brief Read the TOC and store section information
  */
@@ -420,7 +395,7 @@ errlHndl_t PnorRP::readTOC()
     uint8_t* toc1Buffer = new uint8_t[PAGESIZE];
     uint64_t fatal_error = 0;
     do {
-        l_errhdl = readFromDevice( iv_activeTocOffsets.first, 0, false,
+        l_errhdl = readFromDevice( TOC_0_OFFSET, 0, false,
                                 toc0Buffer, fatal_error );
         if (l_errhdl)
         {
@@ -428,7 +403,7 @@ errlHndl_t PnorRP::readTOC()
             break;
         }
 
-        l_errhdl = readFromDevice( iv_activeTocOffsets.second, 0, false,
+        l_errhdl = readFromDevice( TOC_1_OFFSET, 0, false,
                                    toc1Buffer, fatal_error );
         if (l_errhdl)
         {
@@ -437,7 +412,7 @@ errlHndl_t PnorRP::readTOC()
         }
 
         l_errhdl = PNOR::parseTOC(toc0Buffer, toc1Buffer, iv_TOC_used, iv_TOC,
-                                  BASE_VADDR);
+                   BASE_VADDR);
         if (l_errhdl)
         {
             TRACFCOMP(g_trac_pnor, "readTOC: parseTOC failed");
@@ -762,63 +737,59 @@ errlHndl_t PnorRP::computeDeviceAddr( void* i_vaddr,
     o_chip = 99;
     uint64_t l_vaddr = (uint64_t)i_vaddr;
 
-    do
+    // make sure this is one of our addresses
+    if( !((l_vaddr >= BASE_VADDR)
+          && (l_vaddr < LAST_VADDR)) )
     {
-        // make sure this is one of our addresses
-        if( !((l_vaddr >= BASE_VADDR)
-              && (l_vaddr < LAST_VADDR)) )
-        {
-            TRACFCOMP( g_trac_pnor, "PnorRP::computeDeviceAddr> Virtual Address outside known PNOR range : i_vaddr=%p", i_vaddr );
-            /*@
-             * @errortype
-             * @moduleid     PNOR::MOD_PNORRP_WAITFORMESSAGE
-             * @reasoncode   PNOR::RC_INVALID_ADDRESS
-             * @userdata1    Virtual Address
-             * @userdata2    Base PNOR Address
-             * @devdesc      PnorRP::computeDeviceAddr> Virtual Address outside
-             *               known PNOR range
-             * @custdesc    A problem occurred while accessing the boot flash.
-             */
-            l_errhdl = new ERRORLOG::ErrlEntry(ERRORLOG::ERRL_SEV_UNRECOVERABLE,
-                                            PNOR::MOD_PNORRP_COMPUTEDEVICEADDR,
-                                            PNOR::RC_INVALID_ADDRESS,
-                                            l_vaddr,
-                                            BASE_VADDR,
-                                            true /*Add HB SW Callout*/);
-            l_errhdl->collectTrace(PNOR_COMP_NAME);
-            break;
-        }
+        TRACFCOMP( g_trac_pnor, "PnorRP::computeDeviceAddr> Virtual Address outside known PNOR range : i_vaddr=%p", i_vaddr );
+        /*@
+         * @errortype
+         * @moduleid     PNOR::MOD_PNORRP_WAITFORMESSAGE
+         * @reasoncode   PNOR::RC_INVALID_ADDRESS
+         * @userdata1    Virtual Address
+         * @userdata2    Base PNOR Address
+         * @devdesc      PnorRP::computeDeviceAddr> Virtual Address outside
+         *               known PNOR range
+         * @custdesc    A problem occurred while accessing the boot flash.
+         */
+        l_errhdl = new ERRORLOG::ErrlEntry(ERRORLOG::ERRL_SEV_UNRECOVERABLE,
+                                        PNOR::MOD_PNORRP_COMPUTEDEVICEADDR,
+                                        PNOR::RC_INVALID_ADDRESS,
+                                        l_vaddr,
+                                        BASE_VADDR,
+                                        true /*Add HB SW Callout*/);
+        l_errhdl->collectTrace(PNOR_COMP_NAME);
+        return l_errhdl;
+    }
 
-        // find the matching section
-        PNOR::SectionId id = PNOR::INVALID_SECTION;
-        l_errhdl = computeSection( l_vaddr, id );
-        if( l_errhdl )
-        {
-            TRACFCOMP( g_trac_pnor, "PnorRP::computeDeviceAddr> Virtual address does not match any pnor sections : i_vaddr=%p", i_vaddr );
-            break;
-        }
+    // find the matching section
+    PNOR::SectionId id = PNOR::INVALID_SECTION;
+    l_errhdl = computeSection( l_vaddr, id );
+    if( l_errhdl )
+    {
+        return l_errhdl;
+    }
 
-        // pull out the information we need to return from our global copy
-        o_chip = iv_TOC[id].chip;
-        o_ecc = (bool)(iv_TOC[id].integrity & FFS_INTEG_ECC_PROTECT);
-        o_offset = l_vaddr - iv_TOC[id].virtAddr; //offset into section
+    // pull out the information we need to return from our global copy
+    o_chip = iv_TOC[id].chip;
+    o_ecc = (bool)(iv_TOC[id].integrity & FFS_INTEG_ECC_PROTECT);
+    o_offset = l_vaddr - iv_TOC[id].virtAddr; //offset into section
 
-        // for ECC we need to figure out where the ECC-enhanced offset is
-        //  before tacking on the offset to the section
-        if( o_ecc )
-        {
-            o_offset = (o_offset * 9) / 8;
-        }
-        // add on the offset of the section itself
-        o_offset += iv_TOC[id].flashAddr;
-    } while(0);
+    // for ECC we need to figure out where the ECC-enhanced offset is
+    //  before tacking on the offset to the section
+    if( o_ecc )
+    {
+        o_offset = (o_offset * 9) / 8;
+    }
+    // add on the offset of the section itself
+    o_offset += iv_TOC[id].flashAddr;
 
     TRACUCOMP( g_trac_pnor, "< PnorRP::computeDeviceAddr: i_vaddr=%X, o_offset=0x%X, o_chip=%d", l_vaddr, o_offset, o_chip );
     return l_errhdl;
 }
 
 /**
- * @brief Static instance function
+ * @brief Static instance function for testcase only
  */
 PnorRP& PnorRP::getInstance()
 {
@@ -1016,10 +987,3 @@ errlHndl_t PnorRP::fixECC (PNOR::SectionId i_section)
     TRACFCOMP(g_trac_pnor, EXIT_MRK"PnorRP::fixECC");
     return l_err;
 }
-
-uint64_t PnorRP::getTocOffset(TOCS i_toc) const
-{
-    // Can use a ternary operator because there are only 2 TOCs per side
-    return (i_toc == TOC_0) ? iv_activeTocOffsets.first :
-                              iv_activeTocOffsets.second;
-}
diff --git a/src/usr/pnor/pnorrp.H b/src/usr/pnor/pnorrp.H
index 509cf14..3703afe 100644
--- a/src/usr/pnor/pnorrp.H
+++ b/src/usr/pnor/pnorrp.H
@@ -76,18 +76,9 @@ class PnorRP
      */
     errlHndl_t fixECC(PNOR::SectionId i_section);
 
-    /**
-     * @brief  Get TOC offset of specified TOC on active side
-     *
-     * @param[in] i_toc     TOC offset desired on active side
-     *
-     * @return uint64_t     TOC offset
-     */
-    uint64_t getTocOffset(PNOR::TOCS i_toc) const;
-
   protected:
     /**
-     * @brief  Constructor, default TOC offsets to side A
+     * @brief  Constructor
      */
     PnorRP();
 
@@ -98,23 +89,16 @@ class PnorRP
 
 
   private:
-
-    // TOC 0 and 1 offsets of both PNOR sides. The active PNOR side determined
-    // by the Seeprom the SBE booted from
-    std::pair<uint64_t, uint64_t> iv_activeTocOffsets;
-    std::pair<uint64_t, uint64_t> iv_altTocOffsets;
-
     enum
     {
         BASE_VADDR = VMM_VADDR_PNOR_RP, /**< 2GB = 0x80000000*/
         TOTAL_SIZE = 64*MEGABYTE, /**< Allocate 64 MB (0x4000000)*/
         LAST_VADDR = BASE_VADDR + TOTAL_SIZE,  /**< End of our VA range */
     };
-
     /**
      * Which TOC (0 or 1) is used after verifying both.
      */
-    PNOR::TOCS iv_TOC_used;
+    uint32_t iv_TOC_used;
 
     /**
      * Flash statistics
@@ -154,8 +138,7 @@ class PnorRP
 
     /**
      * @brief Verify both TOC's and store section information from one of the
-     *        verified TOC's. Additionally set each section permissions
-     *        (e.g. readOnly)
+     *        verified TOC's
      *
      * @return Error from device
      */
@@ -241,6 +224,7 @@ class PnorRP
         return false;
     };
 
+
     // allow local helper function to call private methods
     friend void* wait_for_message( void* unused );
 
@@ -253,7 +237,7 @@ class PnorRP
     friend errlHndl_t PNOR::validateAltMaster( void );
 
     /**
-     * @brief Static instance function
+     * @brief Static instance function for testcase only
      */
     static PnorRP& getInstance();
 };
diff --git a/src/usr/pnor/pnorsbe.C b/src/usr/pnor/pnorsbe.C
deleted file mode 100644
index 0b61173..0000000
--- a/src/usr/pnor/pnorsbe.C
+++ /dev/null
@@ -1,87 +0,0 @@
-/* IBM_PROLOG_BEGIN_TAG                                                   */
-/* This is an automatically generated prolog.                             */
-/*                                                                        */
-/* $Source: src/usr/pnor/pnorsbe.C $                                      */
-/*                                                                        */
-/* OpenPOWER HostBoot Project                                             */
-/*                                                                        */
-/* Contributors Listed Below - COPYRIGHT 2014,2015                        */
-/* [+] International Business Machines Corp.                              */
-/*                                                                        */
-/*                                                                        */
-/* Licensed under the Apache License, Version 2.0 (the "License");        */
-/* you may not use this file except in compliance with the License.       */
-/* You may obtain a copy of the License at                                */
-/*                                                                        */
-/*     http://www.apache.org/licenses/LICENSE-2.0                         */
-/*                                                                        */
-/* Unless required by applicable law or agreed to in writing, software    */
-/* distributed under the License is distributed on an "AS IS" BASIS,      */
-/* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or        */
-/* implied. See the License for the specific language governing           */
-/* permissions and limitations under the License.                         */
-/*                                                                        */
-/* IBM_PROLOG_END_TAG                                                     */
-/**
- *  @file pnorsbe.C
- *
- *  @brief Implements PNOR::getSbeBootSeeprom(), which Determines which
- *         Seeprom was used to boot the SB
- */
-
-#include <pnor/pnorif.H>
-#include <trace/interface.H>
-#include <errl/errlmanager.H>
-#include <errl/errlentry.H>
-#include <devicefw/userif.H>
-
-extern trace_desc_t* g_trac_pnor;
-
-namespace PNOR
-{
-
-//Used to read SBE Boot Side from processor
-const uint64_t SBE_VITAL_REG_0x0005001C = 0x005001C;
-const uint64_t SBE_BOOT_SELECT_MASK = 0x0080000000000000;
-
-errlHndl_t getSbeBootSeeprom(TARGETING::Target* i_target,
-                             sbeSeepromSide_t& o_bootSide)
-{
-    TRACFCOMP( g_trac_pnor, ENTER_MRK"PNOR::getSbeBootSeeprom()" );
-
-    errlHndl_t err = NULL;
-    uint64_t scomData = 0x0;
-
-    o_bootSide = SBE_SEEPROM0;
-
-    do{
-
-        size_t op_size = sizeof(scomData);
-        err = deviceRead( i_target,
-                          &scomData,
-                          op_size,
-                          DEVICE_SCOM_ADDRESS(SBE_VITAL_REG_0x0005001C) );
-        if( err )
-        {
-            TRACFCOMP( g_trac_pnor, ERR_MRK"PNOR::getSbeBootSeeprom() -Error "
-                       "reading SBE VITAL REG (0x%.8X) from Target :"
-                       "HUID=0x%.8X",
-                       SBE_VITAL_REG_0x0005001C,
-                       TARGETING::get_huid(i_target));
-            break;
-        }
-        if(scomData & SBE_BOOT_SELECT_MASK)
-        {
-            o_bootSide = SBE_SEEPROM1;
-        }
-
-    }while(0);
-
-    TRACFCOMP( g_trac_pnor,
-               EXIT_MRK"PNOR::getSbeBootSeeprom(): o_bootSide=0x%X (reg=0x%X)",
-               o_bootSide, scomData );
-
-    return err;
-}
-
-} // end namespace
\ No newline at end of file
diff --git a/src/usr/pnor/pnorvalid.C b/src/usr/pnor/pnorvalid.C
index 46204ca..1bc09a2 100644
--- a/src/usr/pnor/pnorvalid.C
+++ b/src/usr/pnor/pnorvalid.C
@@ -102,7 +102,7 @@ errlHndl_t validateAltMaster( void )
     // When reading PNOR TOC assume a single page and no ECC
     uint8_t* tocBuffer = new uint8_t[PAGESIZE];
     size_t read_size = PAGESIZE;
-    const uint64_t toc0_offset = PnorRP::getInstance().getTocOffset(TOC_0);
+    const uint64_t toc0_offset = PNOR::TOC_0_OFFSET;
 
     do{
 
@@ -176,7 +176,8 @@ errlHndl_t validateAltMaster( void )
             pnordd = new PnorDD(procList[i]);
 
             // Read Flash
-            l_err = pnordd->readFlash(tocBuffer, read_size, toc0_offset);
+            l_err = pnordd->readFlash(tocBuffer, read_size,
+                                      PNOR::TOC_0_OFFSET);
             if ( l_err )
             {
                 // Commit Error Log, but continue the test
diff --git a/src/usr/pnor/runtime/rt_pnor.C b/src/usr/pnor/runtime/rt_pnor.C
index c61aa1d..c43160f 100644
--- a/src/usr/pnor/runtime/rt_pnor.C
+++ b/src/usr/pnor/runtime/rt_pnor.C
@@ -297,7 +297,7 @@ errlHndl_t RtPnor::flush( PNOR::SectionId i_section)
 }
 /*******Protected Methods**************/
 RtPnor::RtPnor()
-:iv_TOC_used(PNOR::TOC_0)
+:iv_TOC_used(0)
 {
     errlHndl_t l_err = readTOC();
     if (l_err)
@@ -588,10 +588,7 @@ errlHndl_t RtPnor::readTOC ()
             break;
         }
 
-        // @TODO RTC:120733
-        // RT code needs a way to get the active side tocs vs just defaulting
-        // to SIDE_A
-        l_err = readFromDevice (l_procId, PNOR::TOC, PNOR::SIDE_A_TOC_0_OFFSET,
+        l_err = readFromDevice (l_procId, PNOR::TOC, PNOR::TOC_0_OFFSET,
                 PAGESIZE,false,toc0Buffer);
         if (l_err)
         {
@@ -599,7 +596,7 @@ errlHndl_t RtPnor::readTOC ()
                       " for TOC0");
             break;
         }
-        l_err = readFromDevice (l_procId, PNOR::TOC, PNOR::SIDE_A_TOC_1_OFFSET,
+        l_err = readFromDevice (l_procId, PNOR::TOC, PNOR::TOC_1_OFFSET,
                 PAGESIZE, false,toc1Buffer);
         if (l_err)
         {
@@ -608,7 +605,7 @@ errlHndl_t RtPnor::readTOC ()
             break;
         }
 
-        l_err = PNOR::parseTOC(toc0Buffer, toc1Buffer, iv_TOC_used, iv_TOC, 0);
+        l_err = PNOR::parseTOC(toc0Buffer, toc1Buffer, iv_TOC_used, iv_TOC,0);
         if (l_err)
         {
             TRACFCOMP(g_trac_pnor, "RtPnor::readTOC: parseTOC failed");
diff --git a/src/usr/pnor/runtime/rt_pnor.H b/src/usr/pnor/runtime/rt_pnor.H
index f3a03a5..43041fc 100644
--- a/src/usr/pnor/runtime/rt_pnor.H
+++ b/src/usr/pnor/runtime/rt_pnor.H
@@ -81,7 +81,7 @@ class RtPnor
         /**
         * Which TOC (0 or 1) is used after verifying both.
         */
-        PNOR::TOCS iv_TOC_used;
+        uint32_t iv_TOC_used;
 
         /**
          * Cached copy of section data
diff --git a/src/usr/pnor/test/pnorrptest.H b/src/usr/pnor/test/pnorrptest.H
index 427227b..04ca729 100644
--- a/src/usr/pnor/test/pnorrptest.H
+++ b/src/usr/pnor/test/pnorrptest.H
@@ -517,30 +517,22 @@ class PnorRpTest : public CxxTest::TestSuite
         uint8_t* corruptBuffer = new uint8_t[PAGESIZE];
 
         // Corrupt both ffs header and first entry for each TOC
-        for (PNOR::TOCS cur_TOC = PNOR::TOC_0; cur_TOC < PNOR::NUM_TOCS;
-             cur_TOC = (PNOR::TOCS)(cur_TOC+1))
+        for (uint32_t cur_TOC = 0; cur_TOC < PNOR::NUM_TOCS; ++cur_TOC)
         {
-            PNOR::TOCS TOC_used = cur_TOC;
+            uint32_t TOC_used = cur_TOC;
 
             if (cur_TOC == 0)
             {
-              offset =  PnorRP::getInstance().getTocOffset(PNOR::TOC_0);
+              offset =  PNOR::TOC_0_OFFSET;
             }
             else
             {
-              offset =  PnorRP::getInstance().getTocOffset(PNOR::TOC_1);
+              offset =  PNOR::TOC_1_OFFSET;
             }
 
             // Read cur_TOC header data
-            PnorRP::getInstance().readFromDevice( offset, 0, false,
-                                                  tocHeader, fatal_error );
-            if (fatal_error)
-            {
-                TRACFCOMP(g_trac_pnor, "PnorRpTest::test_TOC> ERROR : Could not read TOC header data at offset 0x%X RC=%X",
-                          offset, fatal_error);
-                TS_FAIL("PnorRpTest::test_TOC> ERROR : Could not read TOC header data at offset 0x%X RC=%X",
-                          offset, fatal_error);
-            }
+            PnorRP::getInstance().readFromDevice( offset, 0, false, tocHeader,
+                                                  fatal_error );
 
             // Corrupt cur_TOC header data
             memcpy(corruptBuffer, tocHeader, PAGESIZE);
@@ -567,13 +559,6 @@ class PnorRpTest : public CxxTest::TestSuite
             PnorRP::getInstance().readFromDevice( offset + FFS_HDR_SIZE, 0,
                                                   false, tocEntry,
                                                   fatal_error );
-            if (fatal_error)
-            {
-                TRACFCOMP(g_trac_pnor, "PnorRpTest::test_TOC> ERROR : Could not read first TOC entry data at offset 0x%X RC=%X",
-                          offset, fatal_error);
-                TS_FAIL("PnorRpTest::test_TOC> ERROR : Could not read first TOC entry data at offset 0x%X RC=%X",
-                          offset, fatal_error);
-            }
 
             // Corrupt cur_TOC header data
             memcpy(corruptBuffer, tocEntry, PAGESIZE);
@@ -606,83 +591,6 @@ class PnorRpTest : public CxxTest::TestSuite
         TRACFCOMP(g_trac_pnor, "PnorRpTest::test_TOC End");
     }
 
-    /**
-     * @brief PNOR RP test - ReadOnlyTag
-     *        Tests if readOnly tag on a section is being processed correctly
-     *
-     */
-    void test_ReadOnlyTag(void)
-    {
-        TRACFCOMP(g_trac_pnor, "PnorRpTest::test_ReadOnlyTag Start" );
-        PNOR::SectionInfo_t l_info;
-        errlHndl_t l_errhdl = NULL;
-        uint64_t chip_select = 0xF;
-        bool needs_ecc = false;
-
-        l_errhdl = PNOR::getSectionInfo(PNOR::TESTRO, l_info);
-        if( l_errhdl )
-        {
-            TRACFCOMP(g_trac_pnor, "PnorRpTest::test_ReadOnlyTag> ERROR : getSectionInfo returned error for %d : RC=%X",
-                      PNOR::TESTRO, l_errhdl->reasonCode());
-            ERRORLOG::errlCommit(l_errhdl, PNOR_COMP_ID);
-            TS_FAIL( "PnorRpTest::test_ReadOnlyTag> ERROR : could not read pnor section %d", PNOR::TESTRO);
-        }
-
-        // Write some data
-        const uint64_t l_writeData = 0x1122334455667788;
-        uint64_t* l_dataptr = reinterpret_cast<uint64_t*> (l_info.vaddr);
-        l_dataptr[0] = l_writeData;
-
-        // Flush the page to make sure it gets out to the device
-        // Due to ReadOnly permissions set on TESTRO should be a no-op
-        int rc = mm_remove_pages( RELEASE, l_dataptr, PAGESIZE );
-        if( rc )
-        {
-            TRACFCOMP( g_trac_pnor, "PnorRpTest::test_ReadOnlyTag> ERROR : error on RELEASE : rc=%X", rc );
-            TS_FAIL( "PnorRpTest::test_ReadOnlyTag> ERROR : error on RELEASE" );
-        }
-
-        // Get physical address of pnor section
-        uint64_t l_address = 0;
-        l_errhdl = PnorRP::getInstance().computeDeviceAddr((void*)l_info.vaddr,
-                                                        l_address,
-                                                        chip_select,
-                                                        needs_ecc);
-        if(l_errhdl)
-        {
-            TRACFCOMP(g_trac_pnor, "PnorRpTest::test_ReadOnlyTag> ERROR : computeDeviceAddr vaddr = 0x%X",l_info.vaddr);
-            errlCommit(l_errhdl,PNOR_COMP_ID);
-            TS_FAIL( "PnorRpTest::test_ReadOnlyTag> ERROR : computeDeviceAddr vaddr = 0x%X",l_info.vaddr);
-        }
-
-        // Read pnor section and check if write did not occur
-        uint64_t l_readData = 0;
-        size_t l_size = sizeof(uint64_t);
-        l_errhdl = deviceRead(TARGETING::MASTER_PROCESSOR_CHIP_TARGET_SENTINEL,
-                              &l_readData,
-                              l_size,
-                              DEVICE_PNOR_ADDRESS(0, l_address));
-        TRACFCOMP(g_trac_pnor, "PnorRpTest::test_ReadOnlyTag> Read Data = 0x%X",l_readData);
-        if(l_errhdl)
-        {
-            TS_FAIL("PnorRpTest::test_ReadOnlyTag: deviceRead() failed! Error committed.");
-            ERRORLOG::errlCommit(l_errhdl, PNOR_COMP_ID);
-        }
-        if(l_readData == l_writeData)
-        {
-            TS_FAIL("PnorRpTest::test_ReadOnlyTag: Data was written to readOnly section = %s",
-                     l_info.name);
-        }
-        if(l_size != sizeof(uint64_t))
-        {
-            TS_FAIL("PnorRpTest::test_ReadOnlyTag: deviceRead() Read length not expected value. Addr: 0x%llx, Exp: %d, Act: %d",
-                    l_address, sizeof(uint64_t), l_size);
-        }
-
-        TRACFCOMP(g_trac_pnor, "PnorRpTest::test_ReadOnlyTag End");
-    }
-
-
     //@todo - import config data from build and compare to section info
 
     /**
diff --git a/src/usr/sbe/sbe_update.C b/src/usr/sbe/sbe_update.C
index 698d41a..9dd9e0a 100644
--- a/src/usr/sbe/sbe_update.C
+++ b/src/usr/sbe/sbe_update.C
@@ -1214,6 +1214,49 @@ namespace SBE
     }
 
 /////////////////////////////////////////////////////////////////////
+    errlHndl_t getSbeBootSeeprom(TARGETING::Target* i_target,
+                                 sbeSeepromSide_t& o_bootSide)
+    {
+        TRACUCOMP( g_trac_sbe,
+                   ENTER_MRK"getSbeBootSeeprom()" );
+
+        errlHndl_t err = NULL;
+        uint64_t scomData = 0x0;
+
+        o_bootSide = SBE_SEEPROM0;
+
+        do{
+
+            size_t op_size = sizeof(scomData);
+            err = deviceRead( i_target,
+                              &scomData,
+                              op_size,
+                              DEVICE_SCOM_ADDRESS(SBE_VITAL_REG_0x0005001C) );
+            if( err )
+            {
+                TRACFCOMP( g_trac_sbe, ERR_MRK"getSbeBootSeeprom() -Error "
+                           "reading SBE VITAL REG (0x%.8X) from Target :"
+                           "HUID=0x%.8X",
+                           SBE_VITAL_REG_0x0005001C,
+                           TARGETING::get_huid(i_target));
+                break;
+            }
+            if(scomData & SBE_BOOT_SELECT_MASK)
+            {
+                o_bootSide = SBE_SEEPROM1;
+            }
+
+        }while(0);
+
+        TRACUCOMP( g_trac_sbe,
+                   EXIT_MRK"getSbeBootSeeprom(): o_bootSide=0x%X (reg=0x%X)",
+                   o_bootSide, scomData );
+
+        return err;
+    }
+
+
+/////////////////////////////////////////////////////////////////////
     errlHndl_t getSbeInfoState(sbeTargetState_t& io_sbeState)
     {
 
@@ -1308,11 +1351,11 @@ namespace SBE
             if(SEEPROM_0_PERMANENT_VALUE ==
                (io_sbeState.mvpdSbKeyword.flags & PERMANENT_FLAG_MASK))
             {
-                io_sbeState.permanent_seeprom_side = PNOR::SBE_SEEPROM0;
+                io_sbeState.permanent_seeprom_side = SBE_SEEPROM0;
             }
             else // Side 1 must be permanent
             {
-                io_sbeState.permanent_seeprom_side = PNOR::SBE_SEEPROM1;
+                io_sbeState.permanent_seeprom_side = SBE_SEEPROM1;
             }
 
 
@@ -1361,21 +1404,21 @@ namespace SBE
             /*  Determine which SEEPROM System Booted On   */
             /***********************************************/
             //Get Current (boot) Side
-            PNOR::sbeSeepromSide_t tmp_cur_side = PNOR::SBE_SEEPROM_INVALID;
-            err = PNOR::getSbeBootSeeprom(io_sbeState.target, tmp_cur_side);
+            sbeSeepromSide_t tmp_cur_side = SBE_SEEPROM_INVALID;
+            err = getSbeBootSeeprom(io_sbeState.target, tmp_cur_side);
             if(err)
             {
                 TRACFCOMP( g_trac_sbe, ERR_MRK"getSbeInfoState() - Error returned from getSbeBootSeeprom()");
                 break;
             }
             io_sbeState.cur_seeprom_side = tmp_cur_side;
-            if (io_sbeState.cur_seeprom_side == PNOR::SBE_SEEPROM0)
+            if (io_sbeState.cur_seeprom_side == SBE_SEEPROM0)
             {
-                io_sbeState.alt_seeprom_side = PNOR::SBE_SEEPROM1;
+                io_sbeState.alt_seeprom_side = SBE_SEEPROM1;
             }
-            else if ( io_sbeState.cur_seeprom_side == PNOR::SBE_SEEPROM1)
+            else if ( io_sbeState.cur_seeprom_side == SBE_SEEPROM1)
             {
-                io_sbeState.alt_seeprom_side = PNOR::SBE_SEEPROM0;
+                io_sbeState.alt_seeprom_side = SBE_SEEPROM0;
             }
             else
             {
@@ -2012,7 +2055,7 @@ namespace SBE
             /*  Determine what side to update                             */
             /**************************************************************/
             // Set cur and alt isDirty values
-            if( io_sbeState.cur_seeprom_side == PNOR::SBE_SEEPROM0 )
+            if( io_sbeState.cur_seeprom_side == SBE_SEEPROM0 )
             {
                 current_side_isDirty = seeprom_0_isDirty;
                 alt_side_isDirty     = seeprom_1_isDirty;
@@ -2179,14 +2222,14 @@ namespace SBE
                     io_sbeState.seeprom_side_to_update = EEPROM::SBE_PRIMARY;
 
                     // Update MVPD PERMANENT flag: make cur=perm
-                    ( io_sbeState.cur_seeprom_side == PNOR::SBE_SEEPROM0 ) ?
+                    ( io_sbeState.cur_seeprom_side == SBE_SEEPROM0 ) ?
                          // clear bit 0
                          io_sbeState.mvpdSbKeyword.flags &= ~PERMANENT_FLAG_MASK
                          : //set bit 0
                          io_sbeState.mvpdSbKeyword.flags |= PERMANENT_FLAG_MASK;
 
                     // Update MVPD RE-IPL SEEPROM flag: re-IPL on ALT:
-                    ( io_sbeState.alt_seeprom_side == PNOR::SBE_SEEPROM0 ) ?
+                    ( io_sbeState.alt_seeprom_side == SBE_SEEPROM0 ) ?
                          // clear bit 1
                          io_sbeState.mvpdSbKeyword.flags &= ~REIPL_SEEPROM_MASK
                          : //set bit 1
@@ -2252,18 +2295,18 @@ namespace SBE
 
                     // Set Update side to alt
                     io_sbeState.seeprom_side_to_update =
-                                ( io_sbeState.alt_seeprom_side == PNOR::SBE_SEEPROM0 )
+                                ( io_sbeState.alt_seeprom_side == SBE_SEEPROM0 )
                                   ? EEPROM::SBE_PRIMARY : EEPROM::SBE_BACKUP ;
 
                     // Update MVPD PERMANENT flag: make cur=perm
-                    ( io_sbeState.cur_seeprom_side == PNOR::SBE_SEEPROM0 ) ?
+                    ( io_sbeState.cur_seeprom_side == SBE_SEEPROM0 ) ?
                          // clear bit 0
                          io_sbeState.mvpdSbKeyword.flags &= ~PERMANENT_FLAG_MASK
                          : //set bit 0
                          io_sbeState.mvpdSbKeyword.flags |= PERMANENT_FLAG_MASK;
 
                     // Update MVPD RE-IPL SEEPROM flag: re-IPL on ALT:
-                    ( io_sbeState.alt_seeprom_side == PNOR::SBE_SEEPROM0 ) ?
+                    ( io_sbeState.alt_seeprom_side == SBE_SEEPROM0 ) ?
                          // clear bit 1
                          io_sbeState.mvpdSbKeyword.flags &= ~REIPL_SEEPROM_MASK
                          : //set bit 1
@@ -2298,13 +2341,13 @@ namespace SBE
 
                     // Set Update side to alt
                     io_sbeState.seeprom_side_to_update =
-                                ( io_sbeState.alt_seeprom_side == PNOR::SBE_SEEPROM0 )
+                                ( io_sbeState.alt_seeprom_side == SBE_SEEPROM0 )
                                   ? EEPROM::SBE_PRIMARY : EEPROM::SBE_BACKUP ;
 
 
                     // MVPD flag Update
                     // Update MVPD flag make cur=perm
-                    ( io_sbeState.cur_seeprom_side == PNOR::SBE_SEEPROM0 ) ?
+                    ( io_sbeState.cur_seeprom_side == SBE_SEEPROM0 ) ?
                          // clear bit 0
                          io_sbeState.mvpdSbKeyword.flags &= ~PERMANENT_FLAG_MASK
                          : // set bit 0
@@ -2358,11 +2401,11 @@ namespace SBE
 
                     // Set Update side to alt
                     io_sbeState.seeprom_side_to_update =
-                                ( io_sbeState.alt_seeprom_side == PNOR::SBE_SEEPROM0 )
+                                ( io_sbeState.alt_seeprom_side == SBE_SEEPROM0 )
                                   ? EEPROM::SBE_PRIMARY : EEPROM::SBE_BACKUP ;
 
                     // Update MVPD RE-IPL SEEPROM flag: re-IPL on ALT:
-                    ( io_sbeState.alt_seeprom_side == PNOR::SBE_SEEPROM0 ) ?
+                    ( io_sbeState.alt_seeprom_side == SBE_SEEPROM0 ) ?
                          // clear bit 1
                          io_sbeState.mvpdSbKeyword.flags &= ~REIPL_SEEPROM_MASK
                          : // set bit 1
@@ -2373,7 +2416,7 @@ namespace SBE
                     if ( g_istep_mode )
                     {
                         // Update MVPD PERMANENT flag: make alt=perm
-                        (io_sbeState.alt_seeprom_side == PNOR::SBE_SEEPROM0 ) ?
+                        (io_sbeState.alt_seeprom_side == SBE_SEEPROM0 ) ?
                          // clear bit 0
                          io_sbeState.mvpdSbKeyword.flags &= ~PERMANENT_FLAG_MASK
                          : //set bit 0
@@ -2455,11 +2498,11 @@ namespace SBE
 
                         // Set Update side to alt
                         io_sbeState.seeprom_side_to_update =
-                                ( io_sbeState.alt_seeprom_side == PNOR::SBE_SEEPROM0 )
+                                ( io_sbeState.alt_seeprom_side == SBE_SEEPROM0 )
                                   ? EEPROM::SBE_PRIMARY : EEPROM::SBE_BACKUP ;
 
                         // Update MVPD RE-IPL SEEPROM flag: re-IPL on ALT:
-                        ( io_sbeState.alt_seeprom_side == PNOR::SBE_SEEPROM0 ) ?
+                        ( io_sbeState.alt_seeprom_side == SBE_SEEPROM0 ) ?
                           // clear bit 1
                           io_sbeState.mvpdSbKeyword.flags &= ~REIPL_SEEPROM_MASK
                           : // set bit 1
@@ -2491,7 +2534,7 @@ namespace SBE
 
                     // Set Update side to alt
                     io_sbeState.seeprom_side_to_update =
-                                ( io_sbeState.alt_seeprom_side == PNOR::SBE_SEEPROM0 )
+                                ( io_sbeState.alt_seeprom_side == SBE_SEEPROM0 )
                                   ? EEPROM::SBE_PRIMARY : EEPROM::SBE_BACKUP ;
 
                     TRACFCOMP( g_trac_sbe, INFO_MRK"SBE Update tgt=0x%X: "
@@ -3201,12 +3244,12 @@ namespace SBE
 
                     // Compare against 'current' Master side in case there is
                     // an issue with the other side
-                    if (io_sbeStates_v[i].cur_seeprom_side == PNOR::SBE_SEEPROM0)
+                    if (io_sbeStates_v[i].cur_seeprom_side == SBE_SEEPROM0)
                     {
                         ver_ptr =
                             &(io_sbeStates_v[i].seeprom_0_ver.image_version);
                     }
-                    else // PNOR::SBE_SEEPROM1
+                    else // SBE_SEEPROM1
                     {
                         ver_ptr =
                             &(io_sbeStates_v[i].seeprom_1_ver.image_version);
@@ -3346,12 +3389,12 @@ namespace SBE
                 else
                 {
                     // Not Master, so get 'current' version
-                    if (io_sbeStates_v[i].cur_seeprom_side == PNOR::SBE_SEEPROM0)
+                    if (io_sbeStates_v[i].cur_seeprom_side == SBE_SEEPROM0)
                     {
                         ver_ptr =
                             &(io_sbeStates_v[i].seeprom_0_ver.image_version);
                     }
-                    else // PNOR::SBE_SEEPROM1
+                    else // SBE_SEEPROM1
                     {
                         ver_ptr =
                             &(io_sbeStates_v[i].seeprom_1_ver.image_version);
diff --git a/src/usr/sbe/sbe_update.H b/src/usr/sbe/sbe_update.H
index e49c582..aa880b2 100644
--- a/src/usr/sbe/sbe_update.H
+++ b/src/usr/sbe/sbe_update.H
@@ -5,9 +5,7 @@
 /*                                                                        */
 /* OpenPOWER HostBoot Project                                             */
 /*                                                                        */
-/* Contributors Listed Below - COPYRIGHT 2013,2015                        */
-/* [+] International Business Machines Corp.                              */
-/*                                                                        */
+/* COPYRIGHT International Business Machines Corp. 2013,2014              */
 /*                                                                        */
 /* Licensed under the Apache License, Version 2.0 (the "License");        */
 /* you may not use this file except in compliance with the License.       */
@@ -55,6 +53,10 @@ namespace SBE
     const uint64_t SBE_IMAGE_SEEPROM_ADDRESS    = 0x400; // 1KB
     const uint64_t SBE_VERSION_SEEPROM_ADDRESS  = 0x300; // 1KB - 256B
 
+    //Used to read SBE Boot Side from processor
+    const uint64_t SBE_VITAL_REG_0x0005001C = 0x005001C;
+    const uint64_t SBE_BOOT_SELECT_MASK = 0x0080000000000000;
+
     // PNOR SBE and SBEC Partition constants
     const uint32_t MAX_SBE_ENTRIES = 9;
     const uint32_t SBETOC_EYECATCH = 0x53424500;  //'SBE\0'
@@ -104,6 +106,14 @@ namespace SBE
         MVPDOP_WRITE,     // Write version data to MVPD
     };
 
+    // Used to keep track of perm/temp, and cur/alt
+    enum sbeSeepromSide_t
+    {
+        SBE_SEEPROM0         = 0x00,   // corresponds to EEPROM::SBE_PRIMARY
+        SBE_SEEPROM1         = 0x01,   // corresponts to EEPROM::SBE_BACKUP
+        SBE_SEEPROM_INVALID  = 0xFF,
+    };
+
     // Actions can be combined
     enum sbeUpdateActions_t
     {
@@ -117,6 +127,7 @@ namespace SBE
         UNSUPPORTED_SITUATION  = 0x80000000,
     };
 
+
     /******************************************/
     /*  Structs                               */
     /******************************************/
@@ -196,9 +207,9 @@ namespace SBE
         bool                     seeprom_0_ver_ECC_fail;
         bool                     seeprom_1_ver_ECC_fail;
 
-        PNOR::sbeSeepromSide_t         cur_seeprom_side; // aka 'booted' side
-        PNOR::sbeSeepromSide_t         alt_seeprom_side;
-        PNOR::sbeSeepromSide_t         permanent_seeprom_side;
+        sbeSeepromSide_t         cur_seeprom_side; // aka 'booted' side
+        sbeSeepromSide_t         alt_seeprom_side;
+        sbeSeepromSide_t         permanent_seeprom_side;
 
         // Customized Image Information for this Target
         size_t                   customizedImage_size;
@@ -318,6 +329,21 @@ namespace SBE
                                    void* io_imgPtr,
                                    size_t& o_actImgSize);
 
+
+    /**
+     * @brief Determines which Seeprom was used to boot the SBE
+     *
+     * @param[in] i_target      Target processor to customize
+     *
+     * @param[out] o_bootSide   The Seeprom the SBE booted from
+     *
+     * @return errlHndl_t    Error log handle on failure.
+     */
+
+    errlHndl_t getSbeBootSeeprom(TARGETING::Target* i_target,
+                                 sbeSeepromSide_t& o_bootSide);
+
+
     /**
      * @brief Collects Version information from a specific SEEPROM
      *
diff --git a/src/usr/sbe/test/sbeupdatetest.H b/src/usr/sbe/test/sbeupdatetest.H
index 5e25706..d235141 100644
--- a/src/usr/sbe/test/sbeupdatetest.H
+++ b/src/usr/sbe/test/sbeupdatetest.H
@@ -580,7 +580,7 @@ class SBEUpdateTest: public CxxTest::TestSuite
         {
             // Inputs
             uint8_t                      i_situation;
-            PNOR::sbeSeepromSide_t       i_cur;     // current_seeprom_side
+            sbeSeepromSide_t             i_cur;     // current_seeprom_side
             uint8_t                      i_flags;   // mvpdSbKeyword.flags
 
             // Expected Output
@@ -596,7 +596,7 @@ class SBEUpdateTest: public CxxTest::TestSuite
             // - update alt=1
             // - make cur=perm
             // - re-IPL
-            { 0xE0, PNOR::SBE_SEEPROM0, 0x80,
+            { 0xE0, SBE_SEEPROM0, 0x80,
               static_cast<sbeUpdateActions_t>
                      (DO_UPDATE|IPL_RESTART|UPDATE_MVPD|UPDATE_SBE),
               EEPROM::SBE_BACKUP, 0x40 },
@@ -606,7 +606,7 @@ class SBEUpdateTest: public CxxTest::TestSuite
             // - update alt=0
             // - make cur=perm
             // - re-IPL
-            { 0xC0, PNOR::SBE_SEEPROM1, 0x00,
+            { 0xC0, SBE_SEEPROM1, 0x00,
               static_cast<sbeUpdateActions_t>
                      (DO_UPDATE|IPL_RESTART|UPDATE_MVPD|UPDATE_SBE),
               EEPROM::SBE_PRIMARY, 0x80 },
@@ -616,7 +616,7 @@ class SBEUpdateTest: public CxxTest::TestSuite
             // - update alt=0
             // - make cur=perm
             // - Continue IPL
-            { 0xA0, PNOR::SBE_SEEPROM1, 0x00,
+            { 0xA0, SBE_SEEPROM1, 0x00,
               static_cast<sbeUpdateActions_t>
                      (DO_UPDATE|UPDATE_MVPD|UPDATE_SBE),
               EEPROM::SBE_PRIMARY, 0x80 },
@@ -625,7 +625,7 @@ class SBEUpdateTest: public CxxTest::TestSuite
             // Arbitrarily set cur side to 1 (therefore perm set to 0)
             // - No updates
             // - Continue IPL
-            { 0x80, PNOR::SBE_SEEPROM1, 0x00,
+            { 0x80, SBE_SEEPROM1, 0x00,
               static_cast<sbeUpdateActions_t>(CLEAR_ACTIONS),
               EEPROM::LAST_CHIP_TYPE, 0x00 },
 
@@ -633,7 +633,7 @@ class SBEUpdateTest: public CxxTest::TestSuite
             // Arbitrarily set cur side to 0 (therefore perm set to 0)
             // - update alt=1
             // - re-IPL
-            { 0x60, PNOR::SBE_SEEPROM0, 0x00,
+            { 0x60, SBE_SEEPROM0, 0x00,
               static_cast<sbeUpdateActions_t>
                      (DO_UPDATE|IPL_RESTART|UPDATE_MVPD|UPDATE_SBE),
               EEPROM::SBE_BACKUP, 0x40 },
@@ -644,14 +644,14 @@ class SBEUpdateTest: public CxxTest::TestSuite
             // Arbitrarily set cur side to 1 (therefore perm set to 1)
             // - update alt=0
             // - re-IPL
-            { 0x40, PNOR::SBE_SEEPROM1, 0x80,
+            { 0x40, SBE_SEEPROM1, 0x80,
               static_cast<sbeUpdateActions_t>
                      (DO_UPDATE|IPL_RESTART|UPDATE_MVPD|UPDATE_SBE),
               EEPROM::SBE_PRIMARY, 0x80 },
 
             // Repeat previous case to make sure global variables are used
             // correctly to save MBOX value
-            { 0x40, PNOR::SBE_SEEPROM1, 0x80,
+            { 0x40, SBE_SEEPROM1, 0x80,
               static_cast<sbeUpdateActions_t>
                      (DO_UPDATE|IPL_RESTART|UPDATE_MVPD|UPDATE_SBE),
               EEPROM::SBE_PRIMARY, 0x80 },
@@ -660,7 +660,7 @@ class SBEUpdateTest: public CxxTest::TestSuite
             // Arbitrarily set cur side to 0 (therefore perm set to 0)
             // - update alt=1
             // - Continue IPL
-            { 0x20, PNOR::SBE_SEEPROM0, 0x00,
+            { 0x20, SBE_SEEPROM0, 0x00,
               static_cast<sbeUpdateActions_t>(DO_UPDATE|UPDATE_SBE),
               EEPROM::SBE_BACKUP, 0x00 },
 
@@ -670,7 +670,7 @@ class SBEUpdateTest: public CxxTest::TestSuite
             // - Continue IPL
             // NOTE: this will test that right-most-bit is ignored:
             //  so techincally case 0x01, which should be = case 0x00
-            { 0x01, PNOR::SBE_SEEPROM0, 0x00,
+            { 0x01, SBE_SEEPROM0, 0x00,
               static_cast<sbeUpdateActions_t>(CLEAR_ACTIONS),
               EEPROM::LAST_CHIP_TYPE, 0x00 },
 #endif // SBE_UPDATE_SEQUENTIAL
@@ -708,8 +708,8 @@ class SBEUpdateTest: public CxxTest::TestSuite
                 sbeState.cur_seeprom_side = testData[i].i_cur;
 
                 sbeState.alt_seeprom_side =
-                             ( ( testData[i].i_cur == PNOR::SBE_SEEPROM0 )
-                               ? PNOR::SBE_SEEPROM1 : PNOR::SBE_SEEPROM0 );
+                             ( ( testData[i].i_cur == SBE_SEEPROM0 )
+                               ? SBE_SEEPROM1 : SBE_SEEPROM0 );
 
                 sbeState.mvpdSbKeyword.flags = testData[i].i_flags;
 
-- 
1.8.2.2

