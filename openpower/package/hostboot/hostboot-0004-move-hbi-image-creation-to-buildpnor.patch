From e46b106d92e22fb2432b847c3b5a1e2e7a933c1b Mon Sep 17 00:00:00 2001
From: Stephen Cprek <smcprek@us.ibm.com>
Date: Thu, 14 Apr 2016 14:13:10 -0500
Subject: [PATCH] Move HBI image creation to buildpnor script

Change-Id: Ibddba1d799ecfcc0b5b139255f4760397309d06f
RTC: 125298
---
 src/build/buildpnor/buildpnor.pl    | 172 ++++++++++++++++++++++++++++++++++--
 src/build/mkrules/hbfw/img/makefile |  36 ++------
 2 files changed, 169 insertions(+), 39 deletions(-)

diff --git a/src/build/buildpnor/buildpnor.pl b/src/build/buildpnor/buildpnor.pl
index b303c8b..58ab0c0 100755
--- a/src/build/buildpnor/buildpnor.pl
+++ b/src/build/buildpnor/buildpnor.pl
@@ -35,6 +35,7 @@ use strict;
 use XML::Simple;
 use Data::Dumper;
 use File::Basename;
+use POSIX;
 
 # Digest::SHA1 module is now Digest::SHA in newer version of perl.  Need to
 # do the below eval blocks to support both modules.
@@ -63,6 +64,7 @@ my $programName = File::Basename::basename $0;
 my %pnorLayout;
 my %PhysicalOffsets;
 my %binFiles;
+my %finalBinFiles=();
 my $pnorLayoutFile;
 my $pnorBinName = "";
 my $tocVersion = 0x1;
@@ -76,6 +78,7 @@ my %SideOptions = (
         B => "B",
         sideless => "sideless",
     );
+my $bin_dir;
 use constant PAGE_SIZE => 4096;
 
 if ($#ARGV < 0) {
@@ -116,6 +119,10 @@ for (my $i=0; $i < $#ARGV + 1; $i++)
     elsif($ARGV[$i] =~ /--test/) {
         $testRun = 1;
     }
+    elsif($ARGV[$i] =~ /--binDir/) {
+        $bin_dir = $ARGV[++$i];
+        print "Found bin_dir = $bin_dir\n";
+    }
     else {
         traceErr("Unrecognized Input: $ARGV[$i]");
         exit 1;
@@ -132,6 +139,9 @@ if (-e $pnorBinName)
     unlink $pnorBinName or warn "Could not unlink $pnorBinName: $!";
 }
 
+my $image_target = basename($pnorBinName);
+$image_target =~ s/.pnor//;
+
 #Load PNOR Layout XML file
 loadPnorLayout($pnorLayoutFile, \%pnorLayout, \%PhysicalOffsets);
 
@@ -139,9 +149,9 @@ loadPnorLayout($pnorLayoutFile, \%pnorLayout, \%PhysicalOffsets);
 verifyFilesExist(\%pnorLayout, \%binFiles);
 
 #Perform any data integrity manipulation (ECC, shaw-hash, etc)
-robustifyImgs(\%pnorLayout, \%binFiles);
+manipulateImages(\%pnorLayout, \%binFiles, \%finalBinFiles);
 
-checkSpaceConstraints(\%pnorLayout, \%binFiles);
+checkSpaceConstraints(\%pnorLayout, \%finalBinFiles);
 trace(1, "Done checkSpaceConstraints");
 
 # Create all Partition Tables at each TOC offset
@@ -176,7 +186,7 @@ foreach my $sideId ( keys %{$pnorLayout{metadata}{sides}} )
 {
     my $tocOffset = $pnorLayout{metadata}{sides}{$sideId}{toc}{primary};
 
-    fillPnorImage($pnorBinName, \%pnorLayout, \%binFiles, $sideId,
+    fillPnorImage($pnorBinName, \%pnorLayout, \%finalBinFiles, $sideId,
                         $tocOffset);
 }
 
@@ -597,21 +607,139 @@ sub addTOCInfo
         $sideShift = $sideShift + $numOfTOCs;
     }
 }
+
 ################################################################################
-# robustifyImgs - Perform any ECC or ShawHash manipulations
+# manipulateImages - Perform any ECC/padding/sha/signing manipulations
 ################################################################################
-sub robustifyImgs
+sub manipulateImages
 {
-    my ($i_pnorLayoutRef, $i_binFiles) = @_;
+    my ($i_pnorLayoutRef, $i_binFiles, $o_finalBinFiles) = @_;
     my $this_func = (caller(0))[3];
 
-    #@TODO: ECC Correction
-    #@TODO: maybe a little SHA hashing?
+    my %sectionHash = %{$$i_pnorLayoutRef{sections}};
+    trace(1, "manipulateImages");
+
+    my %tempImages = (
+        HDR_PHASE => "$bin_dir/$image_target.temp.hdr.bin",
+        TEMP_SHA_IMG => "$bin_dir/$image_target.temp.sha.bin",
+        PAD_PHASE => "$bin_dir/$image_target.temp.pad.bin",
+        ECC_PHASE => "$bin_dir/$image_target.temp.bin.ecc"
+    );
+
+    # Remove when all partitions supported by secureboot
+    my %supportedPartitions = (
+        HBI => 1,
+    );
+
+    foreach my $key (keys %{$i_binFiles})
+    {
+        my $layoutKey = findLayoutKeyByEyeCatch($key, \%$i_pnorLayoutRef);
+        if( $layoutKey == -1)
+        {
+            die "ERROR: $this_func: entry not found in PNOR layout for file $$i_binFiles{$key}, under eyecatcher $key" if($?);
+        }
+
+        my $eyeCatch = $sectionHash{$layoutKey}{eyeCatch};
+        my $size = $sectionHash{$layoutKey}{physicalRegionSize};
+
+        my $bin_file = $$i_binFiles{$key};
+        my $final_bin_file = "$bin_dir/$eyeCatch.$image_target.bin";
+
+        if ($sectionHash{$layoutKey}{ecc} eq "yes")
+        {
+            $size = page_aligned_size_wo_ecc($size);
+        }
+        $size = byte_to_metric_notation($size);
+
+        # Remove after all partitions supported
+        if (exists $supportedPartitions{$eyeCatch})
+        {
+            # FSP workaround
+            my $fsp_prefix = "";
+            # Header Phase
+            if( ($sectionHash{$layoutKey}{sha512Version} eq "yes") )
+            {
+                $fsp_prefix.=".header";
+                run_command("env echo -en VERSION\\\\0 > $tempImages{TEMP_SHA_IMG}");
+                run_command("sha512sum $bin_file | awk \'{print \$1}\' | xxd -pr -r >> $tempImages{TEMP_SHA_IMG}");
+                run_command("dd if=$tempImages{TEMP_SHA_IMG} of=$tempImages{HDR_PHASE} ibs=4k conv=sync");
+                run_command("cat $bin_file >> $tempImages{HDR_PHASE}");
+            }
+            elsif( ($sectionHash{$layoutKey}{sha512perEC} eq "yes") )
+            {
+
+            }
+            else
+            {
+                run_command("cp $bin_file $tempImages{HDR_PHASE}");
+            }
+
+            # Padding Phase
+            if ($eyeCatch eq "HBI" && $testRun)
+            {
+                # If "--test" flag set do not pad as the test HBI images is
+                # possibly larger than parition size and does not need to be
+                # fully padded. Size adjustments made in checkSpaceConstraints
+                run_command("dd if=$tempImages{HDR_PHASE} of=$tempImages{PAD_PHASE} ibs=4k conv=sync");
+            }
+            else
+            {
+                run_command("dd if=$tempImages{HDR_PHASE} of=$tempImages{PAD_PHASE} ibs=$size conv=sync");
+            }
+
+            # FSP workaround
+            my $fsp_file = $bin_file;
+            $fsp_file =~ s/.bin/$fsp_prefix.bin/;
+            run_command("cp $tempImages{PAD_PHASE} $fsp_file");
+
+            # ECC Phase
+            if( ($sectionHash{$layoutKey}{ecc} eq "yes") )
+            {
+                run_command("ecc --inject $tempImages{PAD_PHASE} --output $tempImages{ECC_PHASE} --p8");
+            }
+            else
+            {
+                run_command("cp $tempImages{PAD_PHASE} $tempImages{ECC_PHASE}");
+            }
+
+            # Compression phase
+            if( ($sectionHash{$layoutKey}{compressed}{algorithm} eq "xz"))
+            {
+                # Placeholder for compression partitions
+            }
+
+            # Move content to final bin filename
+            run_command("cp $tempImages{ECC_PHASE} $final_bin_file");
+            $$o_finalBinFiles{$key} = $final_bin_file;
+        }
+        else
+        {
+            $$o_finalBinFiles{$key} = $bin_file;
+        }
+
+    }
+
+    # Clean up temp images
+    foreach my $image (keys %tempImages)
+    {
+        run_command("rm -f $tempImages{$image}");
+    }
 
     return 0;
 }
 
 ################################################################################
+# page_aligned_size_wo_ecc : Size of partition without ECC, rounded down to
+#                            nearest multiple of PAGE_SIZE
+################################################################################
+sub page_aligned_size_wo_ecc
+{
+    my ($size) = @_;
+
+    return floor((($size * 8) / 9) / PAGE_SIZE) * PAGE_SIZE;
+}
+
+################################################################################
 # align_down: Align the input to the lower end of the PNOR side
 ################################################################################
 sub align_down
@@ -945,6 +1073,34 @@ sub getOtherSide
     return $other_side;
 }
 
+################################################################################
+# run_command - First print, and then run a system command, erroring out if the
+#               command does not complete successfully
+################################################################################
+sub run_command
+{
+    my $command = shift;
+    trace(1, "$command");
+    my $rc = system($command);
+    die "Error running command: $command. Nonzero return code of ($rc) returned.\n" if ($rc !=0);
+}
+
+################################################################################
+# byte_to_metric_notation - Convert bytes to their proper metric notation
+#                           i.e. 4096 = 4K
+################################################################################
+sub byte_to_metric_notation {
+  my $size = shift;
+  my @args = qw/B K M G T P/;
+
+  while (@args && $size > 1024)
+  {
+    shift @args;
+    $size /= 1024;
+  }
+
+  return "$size$args[0]";
+}
 
 ################################################################################
 # print usage instructions
diff --git a/src/build/mkrules/hbfw/img/makefile b/src/build/mkrules/hbfw/img/makefile
index 2dc9441..679a6ed 100755
--- a/src/build/mkrules/hbfw/img/makefile
+++ b/src/build/mkrules/hbfw/img/makefile
@@ -62,11 +62,6 @@ BASE_W_HEADER_IMAGE = hostboot.header.bin
 BASE_W_HEADER_ECC_IMAGE = hostboot.header.bin.ecc
 BASE_ECC_IMAGE = hostboot.bin.ecc
 BASE_SHA_IMAGE = hostboot.sha.bin
-EXT_PAD_IMAGE = hostboot_extended.bin.pad
-EXT_ECC_IMAGE = hostboot_extended.bin.ecc
-EXT_ECC_HEADER_IMAGE = hostboot_extended.header.bin.ecc
-EXT_SHA_IMAGE = hostboot_extended.sha.bin
-EXT_HEADER_IMAGE = hostboot_extended.header.bin
 TEMP_IMAGE = hostboot.temp.bin
 TESTDATA = hbtestdata.bin
 TESTDATA_ECC = hbtestdata.bin.ecc
@@ -80,13 +75,10 @@ PAYLOAD_ECC_IMAGE = payload.bin.ecc
 
 ALL_HB_IMAGES = ${BASE_IMAGES} \
                 ${BASE_W_HEADER_IMAGE} \
-                ${BASE_ECC_IMAGE} ${EXT_ECC_IMAGE} \
+                ${BASE_ECC_IMAGE}\
                 ${BASE_W_HEADER_ECC_IMAGE} ${BASE_SHA_IMAGE}\
                 ${HBRT_SHA_IMAGE} \
                 ${HBRT_HEADER_IMAGE} ${HBRT_ECC_HEADER_IMAGE} \
-                ${EXT_PAD_IMAGE} \
-                ${EXT_SHA_IMAGE} ${EXT_HEADER_IMAGE} \
-                ${EXT_ECC_HEADER_IMAGE} \
                 ${TESTDATA} ${TESTDATA_ECC} \
                 ${HBEL_ECC_IMAGE} ${GUARD_ECC_IMAGE} ${GLOBAL_ECC_IMAGE} \
                 ${DJVPD_ECC_IMAGE} ${MVPD_ECC_IMAGE} ${CVPD_ECC_IMAGE} \
@@ -105,32 +97,14 @@ cp_hbfiles: .SPECTARG
 	currentsb -chain
 	ecc --inject ${BASE_IMAGE} --output ${BASE_ECC_IMAGE} --p8
 	ecc --inject ${BASE_W_HEADER_IMAGE} --output ${BASE_W_HEADER_ECC_IMAGE} --p8
-	# dd command will pad image up to the next 4K page
-	dd if=${EXT_IMAGE} of=${EXT_PAD_IMAGE} ibs=4k count=1280 conv=sync
-	ecc --inject ${EXT_PAD_IMAGE} --output ${EXT_ECC_IMAGE} --p8
 	# Add version header w/ HBRT sha hash
 	echo -en VERSION\\0 > ${HBRT_SHA_IMAGE}
 	sha512sum ${HBRT_IMAGE} | awk '{print $$1}' | xxd -pr -r >> ${HBRT_SHA_IMAGE}
 	dd if=${HBRT_SHA_IMAGE} of=${TEMP_IMAGE} ibs=4k conv=sync
 	cat ${HBRT_IMAGE} >> ${TEMP_IMAGE}
 	# HBRT partition size w/o ECC = 2MB (2048K)
-	dd if=${TEMP_IMAGE} of=${HBRT_HEADER_IMAGE} ibs=2048K conv=sync
+	dd if=${TEMP_IMAGE} of=${HBRT_HEADER_IMAGE} ibs=3072K conv=sync
 	ecc --inject ${HBRT_HEADER_IMAGE} --output ${HBRT_ECC_HEADER_IMAGE} --p8
-	# Add version header w/ HBI sha hash
-	echo -en VERSION\\0 > ${EXT_SHA_IMAGE}
-	sha512sum ${EXT_IMAGE} | awk '{print $$1}' | xxd -pr -r >> ${EXT_SHA_IMAGE}
-	dd if=${EXT_SHA_IMAGE} of=${TEMP_IMAGE} ibs=4k conv=sync
-	cat ${EXT_IMAGE} >> ${TEMP_IMAGE}
-	# HBI partition size w/o ECC = 5MB (5120K)
-	# If "--test" flag set do not pad to ibs=5120k, as the test HBI images is
-	# possibly larger than parition size and does not need to be fully padded.
-	# Size adjustments made in buildpnor.pl
-	.if(${TARGET_TEST})
-		dd if=${TEMP_IMAGE} of=${EXT_HEADER_IMAGE} ibs=4k conv=sync
-	.else
-		dd if=${TEMP_IMAGE} of=${EXT_HEADER_IMAGE} ibs=5120k conv=sync
-	.endif
-	ecc --inject ${EXT_HEADER_IMAGE} --output ${EXT_ECC_HEADER_IMAGE} --p8
 	# create data for a test partition in pnor
 	dd if=/dev/urandom of=${TESTDATA} count=1 bs=32K
 	ecc --inject ${TESTDATA} --output ${TESTDATA_ECC} --p8
@@ -232,7 +206,7 @@ PNOR_BUILD_SCRIPT = ${buildpnor.pl:P}
 #so need to use tryinclude for now.
 .tryinclude <${.PATH:Ffips_pnor.mk}>
 
-HOSTBOOT_DEFAULT_SECTIONS = HBB=${BASE_W_HEADER_ECC_IMAGE},HBI=${EXT_ECC_HEADER_IMAGE},HBRT=${HBRT_ECC_HEADER_IMAGE},TEST=${TESTDATA_ECC},TESTRO=${TESTDATA_ECC},HBEL=${HBEL_ECC_IMAGE},GUARD=${GUARD_ECC_IMAGE},GLOBAL=${GLOBAL_ECC_IMAGE},PAYLOAD=${PAYLOAD_ECC_IMAGE},CVPD=${CVPD_ECC_IMAGE},MVPD=${MVPD_ECC_IMAGE},DJVPD=${DJVPD_ECC_IMAGE}
+HOSTBOOT_DEFAULT_SECTIONS = HBB=${BASE_W_HEADER_ECC_IMAGE},HBI=${EXT_IMAGE},HBRT=${HBRT_ECC_HEADER_IMAGE},TEST=${TESTDATA_ECC},TESTRO=${TESTDATA_ECC},HBEL=${HBEL_ECC_IMAGE},GUARD=${GUARD_ECC_IMAGE},GLOBAL=${GLOBAL_ECC_IMAGE},PAYLOAD=${PAYLOAD_ECC_IMAGE},CVPD=${CVPD_ECC_IMAGE},MVPD=${MVPD_ECC_IMAGE},DJVPD=${DJVPD_ECC_IMAGE}
 
 
 HBFW_OBJPATH = ${.PATH:M*obj*}
@@ -326,7 +300,8 @@ ${IMAGE_TARGET}: ${IMAGE_LAYOUT} ${IMAGE_BINS} ${PNOR_BUILD_SCRIPT}
 	.if(${PNOR} == ${IMAGE_TARGET} || ${PNOR} == "")
 		${PNOR_BUILD_SCRIPT} --pnorOutBin ${IMAGE_TARGET} \
 			${TARGET_TEST:b--test} --pnorLayout ${IMAGE_LAYOUT} \
-			${IMAGE_BIN_OPTION} --fpartCmd "fpart" --fcpCmd "fcp"
+			${IMAGE_BIN_OPTION} --fpartCmd "fpart" --fcpCmd "fcp" \
+			--binDir ${PWD}
 	.endif
 .endif
 
@@ -348,6 +323,5 @@ update_images_for_sandbox: inject_ecc build_sbe_partitions build_pnor_images
 	${FLASH_IMG:@image@${baseimg:!cd ${FLASH_DEST}; cp -f ${.PATH:F${image}} ${image};!e}@}
 	#Copy pnor images to flash dir
 	${PNOR_IMG_INFO:@image@${pnorimg:!cd ${FLASH_DEST}; if [ "${PNOR}" == "${image:s/:/ /g:xs/ .*//}" ] || [ "${PNOR}" == "" ]; then cp -f ${.PATH:F${image:s/:/ /g:xs/ .*//}} ${image:s/:/ /g:xs/ .*//}; fi !e}@}
-
 .endif
 
-- 
2.6.4 (Apple Git-63)

